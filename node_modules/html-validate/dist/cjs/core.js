'use strict';

var Ajv = require('ajv');
var elements = require('./elements.js');
var betterAjvErrors = require('@sidvind/better-ajv-errors');
var utils_naturalJoin = require('./utils/natural-join.js');
var fs = require('fs');
var codeFrame = require('@babel/code-frame');
var kleur = require('kleur');
var stylish$2 = require('@html-validate/stylish');
var semver = require('semver');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var Ajv__default = /*#__PURE__*/_interopDefault(Ajv);
var betterAjvErrors__default = /*#__PURE__*/_interopDefault(betterAjvErrors);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var kleur__default = /*#__PURE__*/_interopDefault(kleur);
var semver__default = /*#__PURE__*/_interopDefault(semver);

const $schema$2 = "http://json-schema.org/draft-06/schema#";
const $id$2 = "http://json-schema.org/draft-06/schema#";
const title = "Core schema meta-schema";
const definitions$1 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
const type$2 = [
	"object",
	"boolean"
];
const properties$2 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": {
	},
	examples: {
		type: "array",
		items: {
		}
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": {
		}
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": {
	},
	"enum": {
		type: "array",
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var ajvSchemaDraft = {
	$schema: $schema$2,
	$id: $id$2,
	title: title,
	definitions: definitions$1,
	type: type$2,
	properties: properties$2,
	"default": {
}
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return Object.propertyIsEnumerable.call(target, symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

var cjs = deepmerge_1;

var deepmerge$1 = /*@__PURE__*/getDefaultExportFromCjs(cjs);

function stringify(value) {
  if (typeof value === "string") {
    return String(value);
  } else {
    return JSON.stringify(value);
  }
}
class WrappedError extends Error {
  constructor(message) {
    super(stringify(message));
  }
}

function ensureError(value) {
  if (value instanceof Error) {
    return value;
  } else {
    return new WrappedError(value);
  }
}

class NestedError extends Error {
  constructor(message, nested) {
    super(message);
    Error.captureStackTrace(this, NestedError);
    this.name = NestedError.name;
    if (nested == null ? void 0 : nested.stack) {
      this.stack ??= "";
      this.stack += `
Caused by: ${nested.stack}`;
    }
  }
}

class UserError extends NestedError {
  constructor(message, nested) {
    super(message, nested);
    Error.captureStackTrace(this, UserError);
    this.name = UserError.name;
  }
  /**
   * @public
   */
  /* istanbul ignore next: default implementation */
  prettyFormat() {
    return void 0;
  }
}

class InheritError extends UserError {
  constructor({ tagName, inherit }) {
    const message = `Element <${tagName}> cannot inherit from <${inherit}>: no such element`;
    super(message);
    Error.captureStackTrace(this, InheritError);
    this.name = InheritError.name;
    this.tagName = tagName;
    this.inherit = inherit;
    this.filename = null;
  }
  prettyFormat() {
    const { message, tagName, inherit } = this;
    const source = this.filename ? ["", "This error occurred when loading element metadata from:", `"${this.filename}"`, ""] : [""];
    return [
      message,
      ...source,
      "This usually occurs when the elements are defined in the wrong order, try one of the following:",
      "",
      `  - Ensure the spelling of "${inherit}" is correct.`,
      `  - Ensure the file containing "${inherit}" is loaded before the file containing "${tagName}".`,
      `  - Move the definition of "${inherit}" above the definition for "${tagName}".`
    ].join("\n");
  }
}

function getSummary(schema, obj, errors) {
  const output = betterAjvErrors__default.default(schema, obj, errors, {
    format: "js"
  });
  return output.length > 0 ? output[0].error : "unknown validation error";
}
class SchemaValidationError extends UserError {
  constructor(filename, message, obj, schema, errors) {
    const summary = getSummary(schema, obj, errors);
    super(`${message}: ${summary}`);
    this.filename = filename;
    this.obj = obj;
    this.schema = schema;
    this.errors = errors;
  }
}

function cyrb53(str) {
  const a = 2654435761;
  const b = 1597334677;
  const c = 2246822507;
  const d = 3266489909;
  const e = 4294967296;
  const f = 2097151;
  const seed = 0;
  let h1 = 3735928559 ^ seed;
  let h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, a);
    h2 = Math.imul(h2 ^ ch, b);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, c) ^ Math.imul(h2 ^ h2 >>> 13, d);
  h2 = Math.imul(h2 ^ h2 >>> 16, c) ^ Math.imul(h1 ^ h1 >>> 13, d);
  return e * (f & h2) + (h1 >>> 0);
}
const computeHash = cyrb53;

const $schema$1 = "http://json-schema.org/draft-06/schema#";
const $id$1 = "https://html-validate.org/schemas/elements.json";
const type$1 = "object";
const properties$1 = {
	$schema: {
		type: "string"
	}
};
const patternProperties = {
	"^[^$].*$": {
		type: "object",
		properties: {
			inherit: {
				title: "Inherit from another element",
				description: "Most properties from the parent element will be copied onto this one",
				type: "string"
			},
			embedded: {
				title: "Mark this element as belonging in the embedded content category",
				$ref: "#/definitions/contentCategory"
			},
			flow: {
				title: "Mark this element as belonging in the flow content category",
				$ref: "#/definitions/contentCategory"
			},
			heading: {
				title: "Mark this element as belonging in the heading content category",
				$ref: "#/definitions/contentCategory"
			},
			interactive: {
				title: "Mark this element as belonging in the interactive content category",
				$ref: "#/definitions/contentCategory"
			},
			metadata: {
				title: "Mark this element as belonging in the metadata content category",
				$ref: "#/definitions/contentCategory"
			},
			phrasing: {
				title: "Mark this element as belonging in the phrasing content category",
				$ref: "#/definitions/contentCategory"
			},
			sectioning: {
				title: "Mark this element as belonging in the sectioning content category",
				$ref: "#/definitions/contentCategory"
			},
			deprecated: {
				title: "Mark element as deprecated",
				description: "Deprecated elements should not be used. If a message is provided it will be included in the error",
				anyOf: [
					{
						type: "boolean"
					},
					{
						type: "string"
					},
					{
						$ref: "#/definitions/deprecatedElement"
					}
				]
			},
			foreign: {
				title: "Mark element as foreign",
				description: "Foreign elements are elements which have a start and end tag but is otherwize not parsed",
				type: "boolean"
			},
			"void": {
				title: "Mark element as void",
				description: "Void elements are elements which cannot have content and thus must not use an end tag",
				type: "boolean"
			},
			transparent: {
				title: "Mark element as transparent",
				description: "Transparent elements follows the same content model as its parent, i.e. the content must be allowed in the parent.",
				anyOf: [
					{
						type: "boolean"
					},
					{
						type: "array",
						items: {
							type: "string"
						}
					}
				]
			},
			implicitClosed: {
				title: "List of elements which implicitly closes this element",
				description: "Some elements are automatically closed when another start tag occurs",
				type: "array",
				items: {
					type: "string"
				}
			},
			implicitRole: {
				title: "Implicit ARIA role for this element",
				description: "Some elements have implicit ARIA roles.",
				deprecated: true,
				"function": true
			},
			aria: {
				title: "WAI-ARIA properties for this element",
				$ref: "#/definitions/Aria"
			},
			scriptSupporting: {
				title: "Mark element as script-supporting",
				description: "Script-supporting elements are elements which can be inserted where othersise not permitted to assist in templating",
				type: "boolean"
			},
			focusable: {
				title: "Mark this element as focusable",
				description: "This element may contain an associated label element.",
				anyOf: [
					{
						type: "boolean"
					},
					{
						"function": true
					}
				]
			},
			form: {
				title: "Mark element as a submittable form element",
				type: "boolean"
			},
			formAssociated: {
				title: "Mark element as a form-associated element",
				$ref: "#/definitions/FormAssociated"
			},
			labelable: {
				title: "Mark this element as labelable",
				description: "This element may contain an associated label element.",
				anyOf: [
					{
						type: "boolean"
					},
					{
						$ref: "#/definitions/expression"
					}
				]
			},
			deprecatedAttributes: {
				title: "List of deprecated attributes",
				type: "array",
				items: {
					type: "string"
				}
			},
			requiredAttributes: {
				title: "List of required attributes",
				type: "array",
				items: {
					type: "string"
				}
			},
			attributes: {
				title: "List of known attributes and allowed values",
				$ref: "#/definitions/PermittedAttribute"
			},
			permittedContent: {
				title: "List of elements or categories allowed as content in this element",
				$ref: "#/definitions/Permitted"
			},
			permittedDescendants: {
				title: "List of elements or categories allowed as descendants in this element",
				$ref: "#/definitions/Permitted"
			},
			permittedOrder: {
				title: "Required order of child elements",
				$ref: "#/definitions/PermittedOrder"
			},
			permittedParent: {
				title: "List of elements or categories allowed as parent to this element",
				$ref: "#/definitions/Permitted"
			},
			requiredAncestors: {
				title: "List of required ancestor elements",
				$ref: "#/definitions/RequiredAncestors"
			},
			requiredContent: {
				title: "List of required content elements",
				$ref: "#/definitions/RequiredContent"
			},
			textContent: {
				title: "Allow, disallow or require textual content",
				description: "This property controls whenever an element allows, disallows or requires text. Text from any descendant counts, not only direct children",
				"default": "default",
				type: "string",
				"enum": [
					"none",
					"default",
					"required",
					"accessible"
				]
			}
		},
		additionalProperties: false
	}
};
const definitions = {
	Aria: {
		type: "object",
		additionalProperties: false,
		properties: {
			implicitRole: {
				title: "Implicit ARIA role for this element",
				description: "Some elements have implicit ARIA roles.",
				anyOf: [
					{
						type: "string"
					},
					{
						"function": true
					}
				]
			},
			naming: {
				title: "Prohibit or allow this element to be named by aria-label or aria-labelledby",
				anyOf: [
					{
						type: "string",
						"enum": [
							"prohibited",
							"allowed"
						]
					},
					{
						"function": true
					}
				]
			}
		}
	},
	contentCategory: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#/definitions/expression"
			},
			{
				"function": true
			}
		]
	},
	expression: {
		type: "array",
		minItems: 2,
		maxItems: 2,
		items: [
			{
				type: "string",
				"enum": [
					"isDescendant",
					"hasAttribute",
					"matchAttribute"
				]
			},
			{
				anyOf: [
					{
						type: "string"
					},
					{
						$ref: "#/definitions/operation"
					}
				]
			}
		]
	},
	operation: {
		type: "array",
		minItems: 3,
		maxItems: 3,
		items: [
			{
				type: "string"
			},
			{
				type: "string",
				"enum": [
					"!=",
					"="
				]
			},
			{
				type: "string"
			}
		]
	},
	deprecatedElement: {
		type: "object",
		additionalProperties: false,
		properties: {
			message: {
				type: "string",
				title: "A short text message shown next to the regular error message."
			},
			documentation: {
				type: "string",
				title: "An extended markdown formatted message shown with the contextual rule documentation."
			},
			source: {
				type: "string",
				title: "Element source, e.g. what standard or library deprecated this element.",
				"default": "html5"
			}
		}
	},
	FormAssociated: {
		type: "object",
		additionalProperties: false,
		properties: {
			disablable: {
				type: "boolean",
				title: "Disablable elements can be disabled using the disabled attribute."
			},
			listed: {
				type: "boolean",
				title: "Listed elements have a name attribute and is listed in the form and fieldset elements property."
			}
		}
	},
	Permitted: {
		type: "array",
		items: {
			anyOf: [
				{
					type: "string"
				},
				{
					type: "array",
					items: {
						anyOf: [
							{
								type: "string"
							},
							{
								$ref: "#/definitions/PermittedGroup"
							}
						]
					}
				},
				{
					$ref: "#/definitions/PermittedGroup"
				}
			]
		}
	},
	PermittedAttribute: {
		type: "object",
		patternProperties: {
			"^.*$": {
				anyOf: [
					{
						type: "object",
						additionalProperties: false,
						properties: {
							allowed: {
								"function": true,
								title: "Set to a function to evaluate if this attribute is allowed in this context"
							},
							boolean: {
								type: "boolean",
								title: "Set to true if this is a boolean attribute"
							},
							deprecated: {
								title: "Set to true or string if this attribute is deprecated",
								oneOf: [
									{
										type: "boolean"
									},
									{
										type: "string"
									}
								]
							},
							list: {
								type: "boolean",
								title: "Set to true if this attribute is a list of space-separated tokens, each which must be valid by itself"
							},
							"enum": {
								type: "array",
								title: "Exhaustive list of values (string or regex) this attribute accepts",
								uniqueItems: true,
								items: {
									anyOf: [
										{
											type: "string"
										},
										{
											regexp: true
										}
									]
								}
							},
							omit: {
								type: "boolean",
								title: "Set to true if this attribute can optionally omit its value"
							},
							required: {
								type: "boolean",
								title: "Set to true if this attribute is required"
							}
						}
					},
					{
						type: "array",
						uniqueItems: true,
						items: {
							type: "string"
						}
					},
					{
						type: "null"
					}
				]
			}
		}
	},
	PermittedGroup: {
		type: "object",
		additionalProperties: false,
		properties: {
			exclude: {
				anyOf: [
					{
						items: {
							type: "string"
						},
						type: "array"
					},
					{
						type: "string"
					}
				]
			}
		}
	},
	PermittedOrder: {
		type: "array",
		items: {
			type: "string"
		}
	},
	RequiredAncestors: {
		type: "array",
		items: {
			type: "string"
		}
	},
	RequiredContent: {
		type: "array",
		items: {
			type: "string"
		}
	}
};
var schema = {
	$schema: $schema$1,
	$id: $id$1,
	type: type$1,
	properties: properties$1,
	patternProperties: patternProperties,
	definitions: definitions
};

const ajvRegexpValidate = function(data, dataCxt) {
  const valid = data instanceof RegExp;
  if (!valid) {
    ajvRegexpValidate.errors = [
      {
        instancePath: dataCxt == null ? void 0 : dataCxt.instancePath,
        schemaPath: void 0,
        keyword: "type",
        message: "should be a regular expression",
        params: {
          keyword: "type"
        }
      }
    ];
  }
  return valid;
};
const ajvRegexpKeyword = {
  keyword: "regexp",
  schema: false,
  errors: true,
  validate: ajvRegexpValidate
};

const ajvFunctionValidate = function(data, dataCxt) {
  const valid = typeof data === "function";
  if (!valid) {
    ajvFunctionValidate.errors = [
      {
        instancePath: (
          /* istanbul ignore next */
          dataCxt == null ? void 0 : dataCxt.instancePath
        ),
        schemaPath: void 0,
        keyword: "type",
        message: "should be a function",
        params: {
          keyword: "type"
        }
      }
    ];
  }
  return valid;
};
const ajvFunctionKeyword = {
  keyword: "function",
  schema: false,
  errors: true,
  validate: ajvFunctionValidate
};

var TextContent$1 = /* @__PURE__ */ ((TextContent2) => {
  TextContent2["NONE"] = "none";
  TextContent2["DEFAULT"] = "default";
  TextContent2["REQUIRED"] = "required";
  TextContent2["ACCESSIBLE"] = "accessible";
  return TextContent2;
})(TextContent$1 || {});
const MetaCopyableProperty = [
  "metadata",
  "flow",
  "sectioning",
  "heading",
  "phrasing",
  "embedded",
  "interactive",
  "transparent",
  "focusable",
  "form",
  "formAssociated",
  "labelable",
  "attributes",
  "aria",
  "permittedContent",
  "permittedDescendants",
  "permittedOrder",
  "permittedParent",
  "requiredAncestors",
  "requiredContent"
];
function setMetaProperty(dst, key, value) {
  dst[key] = value;
}

function isSet(value) {
  return typeof value !== "undefined";
}
function flag(value) {
  return value ? true : void 0;
}
function stripUndefined(src) {
  const entries = Object.entries(src).filter(([, value]) => isSet(value));
  return Object.fromEntries(entries);
}
function migrateSingleAttribute(src, key) {
  var _a, _b;
  const result = {};
  result.deprecated = flag((_a = src.deprecatedAttributes) == null ? void 0 : _a.includes(key));
  result.required = flag((_b = src.requiredAttributes) == null ? void 0 : _b.includes(key));
  result.omit = void 0;
  const attr = src.attributes ? src.attributes[key] : void 0;
  if (typeof attr === "undefined") {
    return stripUndefined(result);
  }
  if (attr === null) {
    result.delete = true;
    return stripUndefined(result);
  }
  if (Array.isArray(attr)) {
    if (attr.length === 0) {
      result.boolean = true;
    } else {
      result.enum = attr.filter((it) => it !== "");
      if (attr.includes("")) {
        result.omit = true;
      }
    }
    return stripUndefined(result);
  } else {
    return stripUndefined({ ...result, ...attr });
  }
}
function migrateAttributes(src) {
  const keys = [
    ...Object.keys(src.attributes ?? {}),
    ...src.requiredAttributes ?? [],
    ...src.deprecatedAttributes ?? []
  ].sort();
  const entries = keys.map((key) => {
    return [key, migrateSingleAttribute(src, key)];
  });
  return Object.fromEntries(entries);
}
function normalizeAriaImplicitRole(value) {
  if (!value) {
    return () => null;
  }
  if (typeof value === "string") {
    return () => value;
  }
  return value;
}
function normalizeAriaNaming(value) {
  if (!value) {
    return () => "allowed";
  }
  if (typeof value === "string") {
    return () => value;
  }
  return value;
}
function migrateElement(src) {
  var _a, _b;
  const implicitRole = normalizeAriaImplicitRole(src.implicitRole ?? ((_a = src.aria) == null ? void 0 : _a.implicitRole));
  const result = {
    ...src,
    ...{
      formAssociated: void 0
    },
    attributes: migrateAttributes(src),
    textContent: src.textContent,
    focusable: src.focusable ?? false,
    implicitRole,
    aria: {
      implicitRole,
      naming: normalizeAriaNaming((_b = src.aria) == null ? void 0 : _b.naming)
    }
  };
  delete result.deprecatedAttributes;
  delete result.requiredAttributes;
  if (!result.textContent) {
    delete result.textContent;
  }
  if (src.formAssociated) {
    result.formAssociated = {
      disablable: Boolean(src.formAssociated.disablable),
      listed: Boolean(src.formAssociated.listed)
    };
  } else {
    delete result.formAssociated;
  }
  return result;
}

function isDescendant(node, tagName) {
  let cur = node.parent;
  while (cur && !cur.isRootElement()) {
    if (cur.is(tagName)) {
      return true;
    }
    cur = cur.parent;
  }
  return false;
}

function hasAttribute(node, attr) {
  return node.hasAttribute(attr);
}

function matchAttribute(node, key, op, value) {
  const nodeValue = (node.getAttributeValue(key) ?? "").toLowerCase();
  switch (op) {
    case "!=":
      return nodeValue !== value;
    case "=":
      return nodeValue === value;
  }
}

const dynamicKeys = [
  "metadata",
  "flow",
  "sectioning",
  "heading",
  "phrasing",
  "embedded",
  "interactive",
  "labelable"
];
const functionTable = {
  isDescendant: isDescendantFacade,
  hasAttribute: hasAttributeFacade,
  matchAttribute: matchAttributeFacade
};
const schemaCache = /* @__PURE__ */ new Map();
function clone(src) {
  return JSON.parse(JSON.stringify(src));
}
function overwriteMerge$1(a, b) {
  return b;
}
class MetaTable {
  /**
   * @internal
   */
  constructor() {
    this.elements = {};
    this.schema = clone(schema);
  }
  /**
   * @internal
   */
  init() {
    this.resolveGlobal();
  }
  /**
   * Extend validation schema.
   *
   * @public
   */
  extendValidationSchema(patch) {
    if (patch.properties) {
      this.schema = deepmerge$1(this.schema, {
        patternProperties: {
          "^[^$].*$": {
            properties: patch.properties
          }
        }
      });
    }
    if (patch.definitions) {
      this.schema = deepmerge$1(this.schema, {
        definitions: patch.definitions
      });
    }
  }
  /**
   * Load metadata table from object.
   *
   * @public
   * @param obj - Object with metadata to load
   * @param filename - Optional filename used when presenting validation error
   */
  loadFromObject(obj, filename = null) {
    try {
      const validate = this.getSchemaValidator();
      if (!validate(obj)) {
        throw new SchemaValidationError(
          filename,
          `Element metadata is not valid`,
          obj,
          this.schema,
          /* istanbul ignore next: AJV sets .errors when validate returns false */
          validate.errors ?? []
        );
      }
      for (const [key, value] of Object.entries(obj)) {
        if (key === "$schema")
          continue;
        this.addEntry(key, migrateElement(value));
      }
    } catch (err) {
      if (err instanceof InheritError) {
        err.filename = filename;
        throw err;
      }
      if (err instanceof SchemaValidationError) {
        throw err;
      }
      if (!filename) {
        throw err;
      }
      throw new UserError(`Failed to load element metadata from "${filename}"`, ensureError(err));
    }
  }
  /**
   * Get [[MetaElement]] for the given tag. If no specific metadata is present
   * the global metadata is returned or null if no global is present.
   *
   * @public
   * @returns A shallow copy of metadata.
   */
  getMetaFor(tagName) {
    tagName = tagName.toLowerCase();
    if (this.elements[tagName]) {
      return { ...this.elements[tagName] };
    }
    if (this.elements["*"]) {
      return { ...this.elements["*"] };
    }
    return null;
  }
  /**
   * Find all tags which has enabled given property.
   *
   * @public
   */
  getTagsWithProperty(propName) {
    return Object.entries(this.elements).filter(([, entry]) => entry[propName]).map(([tagName]) => tagName);
  }
  /**
   * Find tag matching tagName or inheriting from it.
   *
   * @public
   */
  getTagsDerivedFrom(tagName) {
    return Object.entries(this.elements).filter(([key, entry]) => key === tagName || entry.inherit === tagName).map(([tagName2]) => tagName2);
  }
  addEntry(tagName, entry) {
    let parent = this.elements[tagName] || {};
    if (entry.inherit) {
      const name = entry.inherit;
      parent = this.elements[name];
      if (!parent) {
        throw new InheritError({
          tagName,
          inherit: name
        });
      }
    }
    const expanded = this.mergeElement(parent, { ...entry, tagName });
    expandRegex(expanded);
    this.elements[tagName] = expanded;
  }
  /**
   * Construct a new AJV schema validator.
   */
  getSchemaValidator() {
    const hash = computeHash(JSON.stringify(this.schema));
    const cached = schemaCache.get(hash);
    if (cached) {
      return cached;
    } else {
      const ajv = new Ajv__default.default({ strict: true, strictTuples: true, strictTypes: true });
      ajv.addMetaSchema(ajvSchemaDraft);
      ajv.addKeyword(ajvFunctionKeyword);
      ajv.addKeyword(ajvRegexpKeyword);
      ajv.addKeyword({ keyword: "copyable" });
      const validate = ajv.compile(this.schema);
      schemaCache.set(hash, validate);
      return validate;
    }
  }
  /**
   * @public
   */
  getJSONSchema() {
    return this.schema;
  }
  /**
   * Finds the global element definition and merges each known element with the
   * global, e.g. to assign global attributes.
   */
  resolveGlobal() {
    if (!this.elements["*"])
      return;
    const global = this.elements["*"];
    delete this.elements["*"];
    delete global.tagName;
    delete global.void;
    for (const [tagName, entry] of Object.entries(this.elements)) {
      this.elements[tagName] = this.mergeElement(global, entry);
    }
  }
  mergeElement(a, b) {
    const merged = deepmerge$1(a, b, { arrayMerge: overwriteMerge$1 });
    const filteredAttrs = Object.entries(
      merged.attributes
    ).filter(([, attr]) => {
      const val = !attr.delete;
      delete attr.delete;
      return val;
    });
    merged.attributes = Object.fromEntries(filteredAttrs);
    return merged;
  }
  /**
   * @internal
   */
  resolve(node) {
    if (node.meta) {
      expandProperties(node, node.meta);
    }
  }
}
function expandProperties(node, entry) {
  for (const key of dynamicKeys) {
    const property = entry[key];
    if (!property) {
      continue;
    }
    if (typeof property === "function") {
      setMetaProperty(entry, key, property(node._adapter));
    } else if (typeof property !== "boolean") {
      setMetaProperty(entry, key, evaluateProperty(node, property));
    }
  }
  if (typeof entry.focusable === "function") {
    setMetaProperty(entry, "focusable", entry.focusable(node._adapter));
  }
}
function expandRegexValue(value) {
  if (value instanceof RegExp) {
    return value;
  }
  const match = value.match(/^\/(.*(?=\/))\/(i?)$/);
  if (match) {
    const [, expr, flags] = match;
    if (expr.startsWith("^") || expr.endsWith("$")) {
      return new RegExp(expr, flags);
    } else {
      return new RegExp(`^${expr}$`, flags);
    }
  } else {
    return value;
  }
}
function expandRegex(entry) {
  for (const [name, values] of Object.entries(entry.attributes)) {
    if (values.enum) {
      entry.attributes[name].enum = values.enum.map(expandRegexValue);
    }
  }
}
function evaluateProperty(node, expr) {
  const [func, options] = parseExpression(expr);
  return func(node, options);
}
function parseExpression(expr) {
  if (typeof expr === "string") {
    return parseExpression([expr, {}]);
  } else {
    const [funcName, options] = expr;
    const func = functionTable[funcName];
    if (!func) {
      throw new Error(`Failed to find function "${funcName}" when evaluating property expression`);
    }
    return [func, options];
  }
}
function isDescendantFacade(node, tagName) {
  if (typeof tagName !== "string") {
    throw new Error(
      `Property expression "isDescendant" must take string argument when evaluating metadata for <${node.tagName}>`
    );
  }
  return isDescendant(node, tagName);
}
function hasAttributeFacade(node, attr) {
  if (typeof attr !== "string") {
    throw new Error(
      `Property expression "hasAttribute" must take string argument when evaluating metadata for <${node.tagName}>`
    );
  }
  return hasAttribute(node, attr);
}
function matchAttributeFacade(node, match) {
  if (!Array.isArray(match) || match.length !== 3) {
    throw new Error(
      `Property expression "matchAttribute" must take [key, op, value] array as argument when evaluating metadata for <${node.tagName}>`
    );
  }
  const [key, op, value] = match.map((x) => x.toLowerCase());
  switch (op) {
    case "!=":
    case "=":
      return matchAttribute(node, key, op, value);
    default:
      throw new Error(
        `Property expression "matchAttribute" has invalid operator "${op}" when evaluating metadata for <${node.tagName}>`
      );
  }
}

class DynamicValue {
  constructor(expr) {
    this.expr = expr;
  }
  toString() {
    return this.expr;
  }
}

class Attribute {
  /**
   * @param key - Attribute name.
   * @param value - Attribute value. Set to `null` for boolean attributes.
   * @param keyLocation - Source location of attribute name.
   * @param valueLocation - Source location of attribute value.
   * @param originalAttribute - If this attribute was dynamically added via a
   * transformation (e.g. vuejs `:id` generating the `id` attribute) this
   * parameter should be set to the attribute name of the source attribute (`:id`).
   */
  constructor(key, value, keyLocation, valueLocation, originalAttribute) {
    this.key = key;
    this.value = value;
    this.keyLocation = keyLocation;
    this.valueLocation = valueLocation;
    this.originalAttribute = originalAttribute;
    if (typeof this.value === "undefined") {
      this.value = null;
    }
  }
  /**
   * Flag set to true if the attribute value is static.
   */
  get isStatic() {
    return !this.isDynamic;
  }
  /**
   * Flag set to true if the attribute value is dynamic.
   */
  get isDynamic() {
    return this.value instanceof DynamicValue;
  }
  /**
   * Test attribute value.
   *
   * @param pattern - Pattern to match value against. Can be a RegExp, literal
   * string or an array of strings (returns true if any value matches the
   * array).
   * @param dynamicMatches - If true `DynamicValue` will always match, if false
   * it never matches.
   * @returns `true` if attribute value matches pattern.
   */
  valueMatches(pattern, dynamicMatches = true) {
    if (this.value === null) {
      return false;
    }
    if (this.value instanceof DynamicValue) {
      return dynamicMatches;
    }
    if (Array.isArray(pattern)) {
      return pattern.includes(this.value);
    }
    if (pattern instanceof RegExp) {
      return this.value.match(pattern) !== null;
    } else {
      return this.value === pattern;
    }
  }
}

function getCSSDeclarations(value) {
  return value.trim().split(";").filter(Boolean).map((it) => {
    const [property, value2] = it.split(":", 2);
    return [property.trim(), value2 ? value2.trim() : ""];
  });
}
function parseCssDeclaration(value) {
  if (!value || value instanceof DynamicValue) {
    return {};
  }
  const pairs = getCSSDeclarations(value);
  return Object.fromEntries(pairs);
}

function sliceSize(size, begin, end) {
  if (typeof size !== "number") {
    return size;
  }
  if (typeof end !== "number") {
    return size - begin;
  }
  if (end < 0) {
    end = size + end;
  }
  return Math.min(size, end - begin);
}
function sliceLocation(location, begin, end, wrap) {
  if (!location)
    return null;
  const size = sliceSize(location.size, begin, end);
  const sliced = {
    filename: location.filename,
    offset: location.offset + begin,
    line: location.line,
    column: location.column + begin,
    size
  };
  if (wrap) {
    let index = -1;
    const col = sliced.column;
    do {
      index = wrap.indexOf("\n", index + 1);
      if (index >= 0 && index < begin) {
        sliced.column = col - (index + 1);
        sliced.line++;
      } else {
        break;
      }
    } while (true);
  }
  return sliced;
}

var State = /* @__PURE__ */ ((State2) => {
  State2[State2["INITIAL"] = 1] = "INITIAL";
  State2[State2["DOCTYPE"] = 2] = "DOCTYPE";
  State2[State2["TEXT"] = 3] = "TEXT";
  State2[State2["TAG"] = 4] = "TAG";
  State2[State2["ATTR"] = 5] = "ATTR";
  State2[State2["CDATA"] = 6] = "CDATA";
  State2[State2["SCRIPT"] = 7] = "SCRIPT";
  State2[State2["STYLE"] = 8] = "STYLE";
  return State2;
})(State || {});

var ContentModel = /* @__PURE__ */ ((ContentModel2) => {
  ContentModel2[ContentModel2["TEXT"] = 1] = "TEXT";
  ContentModel2[ContentModel2["SCRIPT"] = 2] = "SCRIPT";
  ContentModel2[ContentModel2["STYLE"] = 3] = "STYLE";
  return ContentModel2;
})(ContentModel || {});
class Context {
  constructor(source) {
    this.state = State.INITIAL;
    this.string = source.data;
    this.filename = source.filename;
    this.offset = source.offset;
    this.line = source.line;
    this.column = source.column;
    this.contentModel = 1 /* TEXT */;
  }
  getTruncatedLine(n = 13) {
    return JSON.stringify(this.string.length > n ? `${this.string.slice(0, 10)}...` : this.string);
  }
  consume(n, state) {
    if (typeof n !== "number") {
      n = n[0].length;
    }
    let consumed = this.string.slice(0, n);
    let offset;
    while ((offset = consumed.indexOf("\n")) >= 0) {
      this.line++;
      this.column = 1;
      consumed = consumed.substr(offset + 1);
    }
    this.column += consumed.length;
    this.offset += n;
    this.string = this.string.substr(n);
    this.state = state;
  }
  getLocation(size) {
    return {
      filename: this.filename,
      offset: this.offset,
      line: this.line,
      column: this.column,
      size
    };
  }
}

function normalizeSource(source) {
  return {
    filename: "",
    offset: 0,
    line: 1,
    column: 1,
    ...source
  };
}

var NodeType = /* @__PURE__ */ ((NodeType2) => {
  NodeType2[NodeType2["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
  NodeType2[NodeType2["TEXT_NODE"] = 3] = "TEXT_NODE";
  NodeType2[NodeType2["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
  return NodeType2;
})(NodeType || {});

const DOCUMENT_NODE_NAME = "#document";
const TEXT_CONTENT = Symbol("textContent");
let counter = 0;
class DOMNode {
  /**
   * Create a new DOMNode.
   *
   * @param nodeType - What node type to create.
   * @param nodeName - What node name to use. For `HtmlElement` this corresponds
   * to the tagName but other node types have specific predefined values.
   * @param location - Source code location of this node.
   */
  constructor(nodeType, nodeName, location) {
    this.nodeType = nodeType;
    this.nodeName = nodeName ?? DOCUMENT_NODE_NAME;
    this.location = location;
    this.disabledRules = /* @__PURE__ */ new Set();
    this.blockedRules = /* @__PURE__ */ new Map();
    this.childNodes = [];
    this.unique = counter++;
    this.cache = null;
  }
  /**
   * Enable cache for this node.
   *
   * Should not be called before the node and all children are fully constructed.
   *
   * @internal
   */
  cacheEnable() {
    this.cache = /* @__PURE__ */ new Map();
  }
  cacheGet(key) {
    if (this.cache) {
      return this.cache.get(key);
    } else {
      return void 0;
    }
  }
  cacheSet(key, value) {
    if (this.cache) {
      this.cache.set(key, value);
    }
    return value;
  }
  cacheRemove(key) {
    if (this.cache) {
      return this.cache.delete(key);
    } else {
      return false;
    }
  }
  cacheExists(key) {
    return Boolean(this.cache && this.cache.has(key));
  }
  /**
   * Get the text (recursive) from all child nodes.
   */
  get textContent() {
    const cached = this.cacheGet(TEXT_CONTENT);
    if (cached) {
      return cached;
    }
    const text = this.childNodes.map((node) => node.textContent).join("");
    this.cacheSet(TEXT_CONTENT, text);
    return text;
  }
  append(node) {
    this.childNodes.push(node);
  }
  isRootElement() {
    return this.nodeType === NodeType.DOCUMENT_NODE;
  }
  /**
   * Tests if two nodes are the same (references the same object).
   *
   * @since v4.11.0
   */
  isSameNode(otherNode) {
    return this.unique === otherNode.unique;
  }
  /**
   * Returns a DOMNode representing the first direct child node or `null` if the
   * node has no children.
   */
  get firstChild() {
    return this.childNodes[0] || null;
  }
  /**
   * Returns a DOMNode representing the last direct child node or `null` if the
   * node has no children.
   */
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  /**
   * Block a rule for this node.
   *
   * @internal
   */
  blockRule(ruleId, blocker) {
    const current = this.blockedRules.get(ruleId);
    if (current) {
      current.push(blocker);
    } else {
      this.blockedRules.set(ruleId, [blocker]);
    }
  }
  /**
   * Blocks multiple rules.
   *
   * @internal
   */
  blockRules(rules, blocker) {
    for (const rule of rules) {
      this.blockRule(rule, blocker);
    }
  }
  /**
   * Disable a rule for this node.
   *
   * @internal
   */
  disableRule(ruleId) {
    this.disabledRules.add(ruleId);
  }
  /**
   * Disables multiple rules.
   *
   * @internal
   */
  disableRules(rules) {
    for (const rule of rules) {
      this.disableRule(rule);
    }
  }
  /**
   * Enable a previously disabled rule for this node.
   */
  enableRule(ruleId) {
    this.disabledRules.delete(ruleId);
  }
  /**
   * Enables multiple rules.
   */
  enableRules(rules) {
    for (const rule of rules) {
      this.enableRule(rule);
    }
  }
  /**
   * Test if a rule is enabled for this node.
   *
   * @internal
   */
  ruleEnabled(ruleId) {
    return !this.disabledRules.has(ruleId);
  }
  /**
   * Test if a rule is blocked for this node.
   *
   * @internal
   */
  ruleBlockers(ruleId) {
    return this.blockedRules.get(ruleId) ?? [];
  }
  generateSelector() {
    return null;
  }
}

function parse(text, baseLocation) {
  const tokens = [];
  const locations = baseLocation ? [] : null;
  for (let begin = 0; begin < text.length; ) {
    let end = text.indexOf(" ", begin);
    if (end === -1) {
      end = text.length;
    }
    const size = end - begin;
    if (size === 0) {
      begin++;
      continue;
    }
    const token = text.substring(begin, end);
    tokens.push(token);
    if (locations && baseLocation) {
      const location = sliceLocation(baseLocation, begin, end);
      locations.push(location);
    }
    begin += size + 1;
  }
  return { tokens, locations };
}
class DOMTokenList extends Array {
  constructor(value, location) {
    var __super = (...args) => {
      super(...args);
    };
    if (value && typeof value === "string") {
      const normalized = value.replace(/[\t\r\n]/g, " ");
      const { tokens, locations } = parse(normalized, location);
      __super(...tokens);
      this.locations = locations;
    } else {
      __super(0);
      this.locations = null;
    }
    if (value instanceof DynamicValue) {
      this.value = value.expr;
    } else {
      this.value = value ?? "";
    }
  }
  item(n) {
    return this[n];
  }
  location(n) {
    if (this.locations) {
      return this.locations[n];
    } else {
      throw new Error("Trying to access DOMTokenList location when base location isn't set");
    }
  }
  contains(token) {
    return this.includes(token);
  }
  *iterator() {
    for (let index = 0; index < this.length; index++) {
      const item = this.item(index);
      const location = this.location(index);
      yield { index, item, location };
    }
  }
}

var Combinator = /* @__PURE__ */ ((Combinator2) => {
  Combinator2[Combinator2["DESCENDANT"] = 1] = "DESCENDANT";
  Combinator2[Combinator2["CHILD"] = 2] = "CHILD";
  Combinator2[Combinator2["ADJACENT_SIBLING"] = 3] = "ADJACENT_SIBLING";
  Combinator2[Combinator2["GENERAL_SIBLING"] = 4] = "GENERAL_SIBLING";
  Combinator2[Combinator2["SCOPE"] = 5] = "SCOPE";
  return Combinator2;
})(Combinator || {});
function parseCombinator(combinator, pattern) {
  if (pattern === ":scope") {
    return 5 /* SCOPE */;
  }
  switch (combinator) {
    case void 0:
    case null:
    case "":
      return 1 /* DESCENDANT */;
    case ">":
      return 2 /* CHILD */;
    case "+":
      return 3 /* ADJACENT_SIBLING */;
    case "~":
      return 4 /* GENERAL_SIBLING */;
    default:
      throw new Error(`Unknown combinator "${combinator}"`);
  }
}

function firstChild(node) {
  return node.previousSibling === null;
}

function lastChild(node) {
  return node.nextSibling === null;
}

const cache = {};
function getNthChild(node) {
  if (!node.parent) {
    return -1;
  }
  if (!cache[node.unique]) {
    const parent = node.parent;
    const index = parent.childElements.findIndex((cur) => {
      return cur.unique === node.unique;
    });
    cache[node.unique] = index + 1;
  }
  return cache[node.unique];
}
function nthChild(node, args) {
  if (!args) {
    throw new Error("Missing argument to nth-child");
  }
  const n = parseInt(args.trim(), 10);
  const cur = getNthChild(node);
  return cur === n;
}

function scope(node) {
  return node.isSameNode(this.scope);
}

const table = {
  "first-child": firstChild,
  "last-child": lastChild,
  "nth-child": nthChild,
  scope
};
function factory$1(name, context) {
  const fn = table[name];
  if (fn) {
    return fn.bind(context);
  } else {
    throw new Error(`Pseudo-class "${name}" is not implemented`);
  }
}

const escapedCodepoints = ["9", "a", "d"];
function* splitSelectorElements(selector) {
  let begin = 0;
  let end = 0;
  function initialState(ch, p) {
    if (ch === "\\") {
      return 1 /* ESCAPED */;
    }
    if (ch === " ") {
      end = p;
      return 2 /* WHITESPACE */;
    }
    return 0 /* INITIAL */;
  }
  function escapedState(ch) {
    if (escapedCodepoints.includes(ch)) {
      return 1 /* ESCAPED */;
    }
    return 0 /* INITIAL */;
  }
  function* whitespaceState(ch, p) {
    if (ch === " ") {
      return 2 /* WHITESPACE */;
    }
    yield selector.slice(begin, end);
    begin = p;
    end = p;
    return 0 /* INITIAL */;
  }
  let state = 0 /* INITIAL */;
  for (let p = 0; p < selector.length; p++) {
    const ch = selector[p];
    switch (state) {
      case 0 /* INITIAL */:
        state = initialState(ch, p);
        break;
      case 1 /* ESCAPED */:
        state = escapedState(ch);
        break;
      case 2 /* WHITESPACE */:
        state = yield* whitespaceState(ch, p);
        break;
    }
  }
  if (begin !== selector.length) {
    yield selector.slice(begin);
  }
}

function stripslashes(value) {
  return value.replace(/\\(.)/g, "$1");
}
function unescapeCodepoint(value) {
  const replacement = {
    "\\9 ": "	",
    "\\a ": "\n",
    "\\d ": "\r"
  };
  return value.replace(
    /(\\[\u0039\u0061\u0064] )/g,
    (_, codepoint) => replacement[codepoint]
  );
}
function escapeSelectorComponent(text) {
  const codepoints = {
    "	": "\\9 ",
    "\n": "\\a ",
    "\r": "\\d "
  };
  return text.toString().replace(/([\t\n\r]|[^a-z0-9_-])/gi, (_, ch) => {
    if (codepoints[ch]) {
      return codepoints[ch];
    } else {
      return `\\${ch}`;
    }
  });
}
function generateIdSelector(id) {
  const escaped = escapeSelectorComponent(id);
  return escaped.match(/^\d/) ? `[id="${escaped}"]` : `#${escaped}`;
}
function isDelimiter(ch) {
  return /[.#[:]/.test(ch);
}
function isQuotationMark(ch) {
  return /['"]/.test(ch);
}
function isPseudoElement(ch, buffer) {
  return ch === ":" && buffer === ":";
}
function* splitPattern$1(pattern) {
  if (pattern === "") {
    return;
  }
  const end = pattern.length;
  let begin = 0;
  let cur = 1;
  let quoted = false;
  while (cur < end) {
    const ch = pattern[cur];
    const buffer = pattern.slice(begin, cur);
    if (ch === "\\") {
      cur += 2;
      continue;
    }
    if (quoted) {
      if (ch === quoted) {
        quoted = false;
      }
      cur += 1;
      continue;
    }
    if (isQuotationMark(ch)) {
      quoted = ch;
      cur += 1;
      continue;
    }
    if (isPseudoElement(ch, buffer)) {
      cur += 1;
      continue;
    }
    if (isDelimiter(ch)) {
      begin = cur;
      yield buffer;
    }
    cur += 1;
  }
  const tail = pattern.slice(begin, cur);
  yield tail;
}
class Matcher {
}
class ClassMatcher extends Matcher {
  constructor(classname) {
    super();
    this.classname = classname;
  }
  match(node) {
    return node.classList.contains(this.classname);
  }
}
class IdMatcher extends Matcher {
  constructor(id) {
    super();
    this.id = stripslashes(id);
  }
  match(node) {
    return node.id === this.id;
  }
}
class AttrMatcher extends Matcher {
  constructor(attr) {
    super();
    const [, key, op, value] = attr.match(/^(.+?)(?:([~^$*|]?=)"([^"]+?)")?$/);
    this.key = key;
    this.op = op;
    this.value = value;
  }
  match(node) {
    const attr = node.getAttribute(this.key, true) || [];
    return attr.some((cur) => {
      switch (this.op) {
        case void 0:
          return true;
        case "=":
          return cur.value === this.value;
        default:
          throw new Error(`Attribute selector operator ${this.op} is not implemented yet`);
      }
    });
  }
}
class PseudoClassMatcher extends Matcher {
  constructor(pseudoclass, context) {
    super();
    const match = pseudoclass.match(/^([^(]+)(?:\((.*)\))?$/);
    if (!match) {
      throw new Error(`Missing pseudo-class after colon in selector pattern "${context}"`);
    }
    const [, name, args] = match;
    this.name = name;
    this.args = args;
  }
  match(node, context) {
    const fn = factory$1(this.name, context);
    return fn(node, this.args);
  }
}
class Pattern {
  constructor(pattern) {
    const match = pattern.match(/^([~+\->]?)((?:[*]|[^.#[:]+)?)([^]*)$/);
    if (!match) {
      throw new Error(`Failed to create selector pattern from "${pattern}"`);
    }
    match.shift();
    this.selector = pattern;
    this.combinator = parseCombinator(match.shift(), pattern);
    this.tagName = match.shift() || "*";
    this.pattern = Array.from(splitPattern$1(match[0]), (it) => this.createMatcher(it));
  }
  match(node, context) {
    return node.is(this.tagName) && this.pattern.every((cur) => cur.match(node, context));
  }
  createMatcher(pattern) {
    switch (pattern[0]) {
      case ".":
        return new ClassMatcher(pattern.slice(1));
      case "#":
        return new IdMatcher(pattern.slice(1));
      case "[":
        return new AttrMatcher(pattern.slice(1, -1));
      case ":":
        return new PseudoClassMatcher(pattern.slice(1), this.selector);
      default:
        throw new Error(`Failed to create matcher for "${pattern}"`);
    }
  }
}
class Selector {
  constructor(selector) {
    this.pattern = Selector.parse(selector);
  }
  /**
   * Match this selector against a HtmlElement.
   *
   * @param root - Element to match against.
   * @returns Iterator with matched elements.
   */
  *match(root) {
    const context = { scope: root };
    yield* this.matchInternal(root, 0, context);
  }
  *matchInternal(root, level, context) {
    if (level >= this.pattern.length) {
      yield root;
      return;
    }
    const pattern = this.pattern[level];
    const matches = Selector.findCandidates(root, pattern);
    for (const node of matches) {
      if (!pattern.match(node, context)) {
        continue;
      }
      yield* this.matchInternal(node, level + 1, context);
    }
  }
  static parse(selector) {
    selector = selector.replace(/([+~>]) /g, "$1");
    return Array.from(splitSelectorElements(selector), (element) => {
      return new Pattern(unescapeCodepoint(element));
    });
  }
  static findCandidates(root, pattern) {
    switch (pattern.combinator) {
      case Combinator.DESCENDANT:
        return root.getElementsByTagName(pattern.tagName);
      case Combinator.CHILD:
        return root.childElements.filter((node) => node.is(pattern.tagName));
      case Combinator.ADJACENT_SIBLING:
        return Selector.findAdjacentSibling(root);
      case Combinator.GENERAL_SIBLING:
        return Selector.findGeneralSibling(root);
      case Combinator.SCOPE:
        return [root];
    }
    return [];
  }
  static findAdjacentSibling(node) {
    let adjacent = false;
    return node.siblings.filter((cur) => {
      if (adjacent) {
        adjacent = false;
        return true;
      }
      if (cur === node) {
        adjacent = true;
      }
      return false;
    });
  }
  static findGeneralSibling(node) {
    let after = false;
    return node.siblings.filter((cur) => {
      if (after) {
        return true;
      }
      if (cur === node) {
        after = true;
      }
      return false;
    });
  }
}

const TEXT_NODE_NAME = "#text";
function isTextNode(node) {
  return Boolean(node && node.nodeType === NodeType.TEXT_NODE);
}
class TextNode extends DOMNode {
  /**
   * @param text - Text to add. When a `DynamicValue` is used the expression is
   * used as "text".
   * @param location - Source code location of this node.
   */
  constructor(text, location) {
    super(NodeType.TEXT_NODE, TEXT_NODE_NAME, location);
    this.text = text;
  }
  /**
   * Get the text from node.
   */
  get textContent() {
    return this.text.toString();
  }
  /**
   * Flag set to true if the attribute value is static.
   */
  get isStatic() {
    return !this.isDynamic;
  }
  /**
   * Flag set to true if the attribute value is dynamic.
   */
  get isDynamic() {
    return this.text instanceof DynamicValue;
  }
}

const ROLE = Symbol("role");
const TABINDEX = Symbol("tabindex");
var NodeClosed = /* @__PURE__ */ ((NodeClosed2) => {
  NodeClosed2[NodeClosed2["Open"] = 0] = "Open";
  NodeClosed2[NodeClosed2["EndTag"] = 1] = "EndTag";
  NodeClosed2[NodeClosed2["VoidOmitted"] = 2] = "VoidOmitted";
  NodeClosed2[NodeClosed2["VoidSelfClosed"] = 3] = "VoidSelfClosed";
  NodeClosed2[NodeClosed2["ImplicitClosed"] = 4] = "ImplicitClosed";
  return NodeClosed2;
})(NodeClosed || {});
function isElementNode(node) {
  return Boolean(node && node.nodeType === NodeType.ELEMENT_NODE);
}
function isInvalidTagName(tagName) {
  return Boolean(tagName === "" || tagName === "*");
}
function createAdapter(node) {
  return {
    closest(selectors) {
      var _a;
      return (_a = node.closest(selectors)) == null ? void 0 : _a._adapter;
    },
    getAttribute(name) {
      var _a;
      return (_a = node.getAttribute(name)) == null ? void 0 : _a.value;
    },
    hasAttribute(name) {
      return node.hasAttribute(name);
    }
  };
}
class HtmlElement extends DOMNode {
  constructor(tagName, parent, closed, meta, location) {
    const nodeType = tagName ? NodeType.ELEMENT_NODE : NodeType.DOCUMENT_NODE;
    super(nodeType, tagName, location);
    if (isInvalidTagName(tagName)) {
      throw new Error(`The tag name provided ("${tagName}") is not a valid name`);
    }
    this.tagName = tagName ?? "#document";
    this.parent = parent ?? null;
    this.attr = {};
    this.metaElement = meta ?? null;
    this.closed = closed;
    this.voidElement = meta ? Boolean(meta.void) : false;
    this.depth = 0;
    this.annotation = null;
    this._adapter = createAdapter(this);
    if (parent) {
      parent.childNodes.push(this);
      let cur = parent;
      while (cur.parent) {
        this.depth++;
        cur = cur.parent;
      }
    }
  }
  /**
   * @internal
   */
  static rootNode(location) {
    const root = new HtmlElement(void 0, null, 1 /* EndTag */, null, location);
    root.setAnnotation("#document");
    return root;
  }
  /**
   * @internal
   *
   * @param namespace - If given it is appended to the tagName.
   */
  static fromTokens(startToken, endToken, parent, metaTable, namespace = "") {
    const name = startToken.data[2];
    const tagName = namespace ? `${namespace}:${name}` : name;
    if (!name) {
      throw new Error("tagName cannot be empty");
    }
    const meta = metaTable ? metaTable.getMetaFor(tagName) : null;
    const open = startToken.data[1] !== "/";
    const closed = isClosed(endToken, meta);
    const location = sliceLocation(startToken.location, 1);
    return new HtmlElement(tagName, open ? parent : null, closed, meta, location);
  }
  /**
   * Returns annotated name if set or defaults to `<tagName>`.
   *
   * E.g. `my-annotation` or `<div>`.
   */
  get annotatedName() {
    if (this.annotation) {
      return this.annotation;
    } else {
      return `<${this.tagName}>`;
    }
  }
  /**
   * Get list of IDs referenced by `aria-labelledby`.
   *
   * If the attribute is unset or empty this getter returns null.
   * If the attribute is dynamic the original {@link DynamicValue} is returned.
   *
   * @public
   */
  get ariaLabelledby() {
    const attr = this.getAttribute("aria-labelledby");
    if (!(attr == null ? void 0 : attr.value)) {
      return null;
    }
    if (attr.value instanceof DynamicValue) {
      return attr.value;
    }
    const list = new DOMTokenList(attr.value, attr.valueLocation);
    return list.length ? Array.from(list) : null;
  }
  /**
   * Similar to childNodes but only elements.
   */
  get childElements() {
    return this.childNodes.filter(isElementNode);
  }
  /**
   * Find the first ancestor matching a selector.
   *
   * Implementation of DOM specification of Element.closest(selectors).
   */
  closest(selectors) {
    let node = this;
    while (node) {
      if (node.matches(selectors)) {
        return node;
      }
      node = node.parent;
    }
    return null;
  }
  /**
   * Generate a DOM selector for this element. The returned selector will be
   * unique inside the current document.
   */
  generateSelector() {
    if (this.isRootElement()) {
      return null;
    }
    const parts = [];
    let root;
    for (root = this; root.parent; root = root.parent) {
    }
    for (let cur = this; cur.parent; cur = cur.parent) {
      if (cur.id) {
        const selector = generateIdSelector(cur.id);
        const matches = root.querySelectorAll(selector);
        if (matches.length === 1) {
          parts.push(selector);
          break;
        }
      }
      const parent = cur.parent;
      const child = parent.childElements;
      const index = child.findIndex((it) => it.unique === cur.unique);
      const numOfType = child.filter((it) => it.is(cur.tagName)).length;
      const solo = numOfType === 1;
      if (solo) {
        parts.push(cur.tagName.toLowerCase());
        continue;
      }
      parts.push(`${cur.tagName.toLowerCase()}:nth-child(${String(index + 1)})`);
    }
    return parts.reverse().join(" > ");
  }
  /**
   * Tests if this element has given tagname.
   *
   * If passing "*" this test will pass if any tagname is set.
   */
  is(tagName) {
    return tagName === "*" || this.tagName.toLowerCase() === tagName.toLowerCase();
  }
  /**
   * Load new element metadata onto this element.
   *
   * Do note that semantics such as `void` cannot be changed (as the element has
   * already been created). In addition the element will still "be" the same
   * element, i.e. even if loading meta for a `<p>` tag upon a `<div>` tag it
   * will still be a `<div>` as far as the rest of the validator is concerned.
   *
   * In fact only certain properties will be copied onto the element:
   *
   * - content categories (flow, phrasing, etc)
   * - required attributes
   * - attribute allowed values
   * - permitted/required elements
   *
   * Properties *not* loaded:
   *
   * - inherit
   * - deprecated
   * - foreign
   * - void
   * - implicitClosed
   * - scriptSupporting
   * - deprecatedAttributes
   *
   * Changes to element metadata will only be visible after `element:ready` (and
   * the subsequent `dom:ready` event).
   */
  loadMeta(meta) {
    if (!this.metaElement) {
      this.metaElement = {};
    }
    for (const key of MetaCopyableProperty) {
      const value = meta[key];
      if (typeof value !== "undefined") {
        setMetaProperty(this.metaElement, key, value);
      } else {
        delete this.metaElement[key];
      }
    }
  }
  /**
   * Match this element against given selectors. Returns true if any selector
   * matches.
   *
   * Implementation of DOM specification of Element.matches(selectors).
   */
  matches(selector) {
    let root = this;
    while (root.parent) {
      root = root.parent;
    }
    for (const match of root.querySelectorAll(selector)) {
      if (match.unique === this.unique) {
        return true;
      }
    }
    return false;
  }
  get meta() {
    return this.metaElement;
  }
  /**
   * Get current role for this element (explicit with `role` attribute or mapped
   * with implicit role).
   *
   * @since 8.9.1
   */
  get role() {
    const cached = this.cacheGet(ROLE);
    if (cached !== void 0) {
      return cached;
    }
    const role = this.getAttribute("role");
    if (role) {
      return this.cacheSet(ROLE, role.value);
    }
    if (this.metaElement) {
      const { aria } = this.metaElement;
      const implicitRole = aria.implicitRole(this._adapter);
      return this.cacheSet(ROLE, implicitRole);
    }
    return this.cacheSet(ROLE, null);
  }
  /**
   * Set annotation for this element.
   */
  setAnnotation(text) {
    this.annotation = text;
  }
  /**
   * Set attribute. Stores all attributes set even with the same name.
   *
   * @param key - Attribute name
   * @param value - Attribute value. Use `null` if no value is present.
   * @param keyLocation - Location of the attribute name.
   * @param valueLocation - Location of the attribute value (excluding quotation)
   * @param originalAttribute - If attribute is an alias for another attribute
   * (dynamic attributes) set this to the original attribute name.
   */
  setAttribute(key, value, keyLocation, valueLocation, originalAttribute) {
    key = key.toLowerCase();
    if (!this.attr[key]) {
      this.attr[key] = [];
    }
    this.attr[key].push(new Attribute(key, value, keyLocation, valueLocation, originalAttribute));
  }
  /**
   * Get parsed tabindex for this element.
   *
   * - If `tabindex` attribute is not present `null` is returned.
   * - If attribute value is omitted or the empty string `null` is returned.
   * - If attribute value cannot be parsed `null` is returned.
   * - If attribute value is dynamic `0` is returned.
   * - Otherwise the parsed value is returned.
   *
   * This property does *NOT* take into account if the element have a default
   * `tabindex` (such as `<input>` have). Instead use the `focusable` metadata
   * property to determine this.
   *
   * @public
   * @since 8.16.0
   */
  get tabIndex() {
    const cached = this.cacheGet(TABINDEX);
    if (cached !== void 0) {
      return cached;
    }
    const tabindex = this.getAttribute("tabindex");
    if (!tabindex) {
      return this.cacheSet(TABINDEX, null);
    }
    if (tabindex.value === null) {
      return this.cacheSet(TABINDEX, null);
    }
    if (tabindex.value instanceof DynamicValue) {
      return this.cacheSet(TABINDEX, 0);
    }
    const parsed = parseInt(tabindex.value, 10);
    if (isNaN(parsed)) {
      return this.cacheSet(TABINDEX, null);
    }
    return this.cacheSet(TABINDEX, parsed);
  }
  /**
   * Get a list of all attributes on this node.
   */
  get attributes() {
    return Object.values(this.attr).reduce((result, cur) => {
      return result.concat(cur);
    }, []);
  }
  hasAttribute(key) {
    key = key.toLowerCase();
    return key in this.attr;
  }
  getAttribute(key, all = false) {
    key = key.toLowerCase();
    if (key in this.attr) {
      const matches = this.attr[key];
      return all ? matches : matches[0];
    } else {
      return null;
    }
  }
  /**
   * Get attribute value.
   *
   * Returns the attribute value if present.
   *
   * - Missing attributes return `null`.
   * - Boolean attributes return `null`.
   * - `DynamicValue` returns attribute expression.
   *
   * @param key - Attribute name
   * @returns Attribute value or null.
   */
  getAttributeValue(key) {
    const attr = this.getAttribute(key);
    if (attr) {
      return attr.value !== null ? attr.value.toString() : null;
    } else {
      return null;
    }
  }
  /**
   * Add text as a child node to this element.
   *
   * @param text - Text to add.
   * @param location - Source code location of this text.
   */
  appendText(text, location) {
    this.childNodes.push(new TextNode(text, location));
  }
  /**
   * Return a list of all known classes on the element. Dynamic values are
   * ignored.
   */
  get classList() {
    if (!this.hasAttribute("class")) {
      return new DOMTokenList(null, null);
    }
    const classes = this.getAttribute("class", true).filter((attr) => attr.isStatic).map((attr) => attr.value).join(" ");
    return new DOMTokenList(classes, null);
  }
  /**
   * Get element ID if present.
   */
  get id() {
    return this.getAttributeValue("id");
  }
  get style() {
    const attr = this.getAttribute("style");
    return parseCssDeclaration(attr == null ? void 0 : attr.value);
  }
  /**
   * Returns the first child element or null if there are no child elements.
   */
  get firstElementChild() {
    const children = this.childElements;
    return children.length > 0 ? children[0] : null;
  }
  /**
   * Returns the last child element or null if there are no child elements.
   */
  get lastElementChild() {
    const children = this.childElements;
    return children.length > 0 ? children[children.length - 1] : null;
  }
  get siblings() {
    return this.parent ? this.parent.childElements : [this];
  }
  get previousSibling() {
    const i = this.siblings.findIndex((node) => node.unique === this.unique);
    return i >= 1 ? this.siblings[i - 1] : null;
  }
  get nextSibling() {
    const i = this.siblings.findIndex((node) => node.unique === this.unique);
    return i <= this.siblings.length - 2 ? this.siblings[i + 1] : null;
  }
  getElementsByTagName(tagName) {
    return this.childElements.reduce((matches, node) => {
      return matches.concat(node.is(tagName) ? [node] : [], node.getElementsByTagName(tagName));
    }, []);
  }
  querySelector(selector) {
    const it = this.querySelectorImpl(selector);
    const next = it.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  querySelectorAll(selector) {
    const it = this.querySelectorImpl(selector);
    const unique = new Set(it);
    return Array.from(unique.values());
  }
  *querySelectorImpl(selectorList) {
    if (!selectorList) {
      return;
    }
    for (const selector of selectorList.split(/,\s*/)) {
      const pattern = new Selector(selector);
      yield* pattern.match(this);
    }
  }
  /**
   * Visit all nodes from this node and down. Depth first.
   *
   * @internal
   */
  visitDepthFirst(callback) {
    function visit(node) {
      node.childElements.forEach(visit);
      if (!node.isRootElement()) {
        callback(node);
      }
    }
    visit(this);
  }
  /**
   * Evaluates callbackk on all descendants, returning true if any are true.
   *
   * @internal
   */
  someChildren(callback) {
    return this.childElements.some(visit);
    function visit(node) {
      if (callback(node)) {
        return true;
      } else {
        return node.childElements.some(visit);
      }
    }
  }
  /**
   * Evaluates callbackk on all descendants, returning true if all are true.
   *
   * @internal
   */
  everyChildren(callback) {
    return this.childElements.every(visit);
    function visit(node) {
      if (!callback(node)) {
        return false;
      }
      return node.childElements.every(visit);
    }
  }
  /**
   * Visit all nodes from this node and down. Breadth first.
   *
   * The first node for which the callback evaluates to true is returned.
   *
   * @internal
   */
  find(callback) {
    function visit(node) {
      if (callback(node)) {
        return node;
      }
      for (const child of node.childElements) {
        const match = child.find(callback);
        if (match) {
          return match;
        }
      }
      return null;
    }
    return visit(this);
  }
}
function isClosed(endToken, meta) {
  let closed = 0 /* Open */;
  if (meta && meta.void) {
    closed = 2 /* VoidOmitted */;
  }
  if (endToken.data[0] === "/>") {
    closed = 3 /* VoidSelfClosed */;
  }
  return closed;
}

class DOMTree {
  constructor(location) {
    this.root = HtmlElement.rootNode(location);
    this.active = this.root;
    this.doctype = null;
  }
  pushActive(node) {
    this.active = node;
  }
  popActive() {
    if (this.active.isRootElement()) {
      return;
    }
    this.active = this.active.parent ?? this.root;
  }
  getActive() {
    return this.active;
  }
  /**
   * Resolve dynamic meta expressions.
   */
  resolveMeta(table) {
    this.visitDepthFirst((node) => {
      table.resolve(node);
    });
  }
  getElementsByTagName(tagName) {
    return this.root.getElementsByTagName(tagName);
  }
  visitDepthFirst(callback) {
    this.root.visitDepthFirst(callback);
  }
  find(callback) {
    return this.root.find(callback);
  }
  querySelector(selector) {
    return this.root.querySelector(selector);
  }
  querySelectorAll(selector) {
    return this.root.querySelectorAll(selector);
  }
}

const allowedKeys = ["exclude"];
class Validator {
  /**
   * Test if element is used in a proper context.
   *
   * @param node - Element to test.
   * @param rules - List of rules.
   * @returns `true` if element passes all tests.
   */
  static validatePermitted(node, rules) {
    if (!rules) {
      return true;
    }
    return rules.some((rule) => {
      return Validator.validatePermittedRule(node, rule);
    });
  }
  /**
   * Test if an element is used the correct amount of times.
   *
   * For instance, a `<table>` element can only contain a single `<tbody>`
   * child. If multiple `<tbody>` exists this test will fail both nodes.
   * Note that this is called on the parent but will fail the children violating
   * the rule.
   *
   * @param children - Array of children to validate.
   * @param rules - List of rules of the parent element.
   * @returns `true` if the parent element of the children passes the test.
   */
  static validateOccurrences(children, rules, cb) {
    if (!rules) {
      return true;
    }
    let valid = true;
    for (const rule of rules) {
      if (typeof rule !== "string") {
        return false;
      }
      const [, category, quantifier] = rule.match(/^(@?.*?)([?*]?)$/);
      const limit = category && quantifier && parseQuantifier(quantifier);
      if (limit) {
        const siblings = children.filter(
          (cur) => Validator.validatePermittedCategory(cur, rule, true)
        );
        if (siblings.length > limit) {
          for (const child of siblings.slice(limit)) {
            cb(child, category);
          }
          valid = false;
        }
      }
    }
    return valid;
  }
  /**
   * Validate elements order.
   *
   * Given a parent element with children and metadata containing permitted
   * order it will validate each children and ensure each one exists in the
   * specified order.
   *
   * For instance, for a `<table>` element the `<caption>` element must come
   * before a `<thead>` which must come before `<tbody>`.
   *
   * @param children - Array of children to validate.
   */
  static validateOrder(children, rules, cb) {
    if (!rules) {
      return true;
    }
    let i = 0;
    let prev = null;
    for (const node of children) {
      const old = i;
      while (rules[i] && !Validator.validatePermittedCategory(node, rules[i], true)) {
        i++;
      }
      if (i >= rules.length) {
        const orderSpecified = rules.find(
          (cur) => Validator.validatePermittedCategory(node, cur, true)
        );
        if (orderSpecified) {
          cb(node, prev);
          return false;
        }
        i = old;
      }
      prev = node;
    }
    return true;
  }
  /**
   * Validate element ancestors.
   *
   * Check if an element has the required set of elements. At least one of the
   * selectors must match.
   */
  static validateAncestors(node, rules) {
    if (!rules || rules.length === 0) {
      return true;
    }
    return rules.some((rule) => node.closest(rule));
  }
  /**
   * Validate element required content.
   *
   * Check if an element has the required set of elements. At least one of the
   * selectors must match.
   *
   * Returns `[]` when valid or a list of required but missing tagnames or
   * categories.
   */
  static validateRequiredContent(node, rules) {
    if (!rules || rules.length === 0) {
      return [];
    }
    return rules.filter((tagName) => {
      const haveMatchingChild = node.childElements.some(
        (child) => Validator.validatePermittedCategory(child, tagName, false)
      );
      return !haveMatchingChild;
    });
  }
  /**
   * Test if an attribute has an allowed value and/or format.
   *
   * @param attr - Attribute to test.
   * @param rules - Element attribute metadta.
   * @returns `true` if attribute passes all tests.
   */
  static validateAttribute(attr, rules) {
    const rule = rules[attr.key];
    if (!rule) {
      return true;
    }
    const value = attr.value;
    if (value instanceof DynamicValue) {
      return true;
    }
    const empty = value === null || value === "";
    if (rule.boolean) {
      return empty || value === attr.key;
    }
    if (rule.omit && empty) {
      return true;
    }
    if (rule.list) {
      const tokens = new DOMTokenList(value, attr.valueLocation);
      return tokens.every((token) => {
        return this.validateAttributeValue(token, rule);
      });
    }
    return this.validateAttributeValue(value, rule);
  }
  static validateAttributeValue(value, rule) {
    if (!rule.enum) {
      return true;
    }
    if (value === null || value === void 0) {
      return false;
    }
    const caseInsensitiveValue = value.toLowerCase();
    return rule.enum.some((entry) => {
      if (entry instanceof RegExp) {
        return !!value.match(entry);
      } else {
        return caseInsensitiveValue === entry;
      }
    });
  }
  static validatePermittedRule(node, rule, isExclude = false) {
    if (typeof rule === "string") {
      return Validator.validatePermittedCategory(node, rule, !isExclude);
    } else if (Array.isArray(rule)) {
      return rule.every((inner) => {
        return Validator.validatePermittedRule(node, inner, isExclude);
      });
    } else {
      validateKeys(rule);
      if (rule.exclude) {
        if (Array.isArray(rule.exclude)) {
          return !rule.exclude.some((inner) => {
            return Validator.validatePermittedRule(node, inner, true);
          });
        } else {
          return !Validator.validatePermittedRule(node, rule.exclude, true);
        }
      } else {
        return true;
      }
    }
  }
  /**
   * Validate node against a content category.
   *
   * When matching parent nodes against permitted parents use the superset
   * parameter to also match for `@flow`. E.g. if a node expects a `@phrasing`
   * parent it should also allow `@flow` parent since `@phrasing` is a subset of
   * `@flow`.
   *
   * @param node - The node to test against
   * @param category - Name of category with `@` prefix or tag name.
   * @param defaultMatch - The default return value when node categories is not known.
   */
  /* eslint-disable-next-line complexity -- rule does not like switch */
  static validatePermittedCategory(node, category, defaultMatch) {
    const [, rawCategory] = category.match(/^(@?.*?)([?*]?)$/);
    if (!rawCategory.startsWith("@")) {
      return node.tagName === rawCategory;
    }
    if (!node.meta) {
      return defaultMatch;
    }
    switch (rawCategory) {
      case "@meta":
        return node.meta.metadata;
      case "@flow":
        return node.meta.flow;
      case "@sectioning":
        return node.meta.sectioning;
      case "@heading":
        return node.meta.heading;
      case "@phrasing":
        return node.meta.phrasing;
      case "@embedded":
        return node.meta.embedded;
      case "@interactive":
        return node.meta.interactive;
      case "@script":
        return Boolean(node.meta.scriptSupporting);
      case "@form":
        return Boolean(node.meta.form);
      default:
        throw new Error(`Invalid content category "${category}"`);
    }
  }
}
function validateKeys(rule) {
  for (const key of Object.keys(rule)) {
    if (!allowedKeys.includes(key)) {
      const str = JSON.stringify(rule);
      throw new Error(`Permitted rule "${str}" contains unknown property "${key}"`);
    }
  }
}
function parseQuantifier(quantifier) {
  switch (quantifier) {
    case "?":
      return 1;
    case "*":
      return null;
    default:
      throw new Error(`Invalid quantifier "${quantifier}" used`);
  }
}

const $schema = "http://json-schema.org/draft-06/schema#";
const $id = "https://html-validate.org/schemas/config.json";
const type = "object";
const additionalProperties = false;
const properties = {
	$schema: {
		type: "string"
	},
	root: {
		type: "boolean",
		title: "Mark as root configuration",
		description: "If this is set to true no further configurations will be searched.",
		"default": false
	},
	"extends": {
		type: "array",
		items: {
			type: "string"
		},
		title: "Configurations to extend",
		description: "Array of shareable or builtin configurations to extend."
	},
	elements: {
		type: "array",
		items: {
			anyOf: [
				{
					type: "string"
				},
				{
					type: "object"
				}
			]
		},
		title: "Element metadata to load",
		description: "Array of modules, plugins or files to load element metadata from. Use <rootDir> to refer to the folder with the package.json file.",
		examples: [
			[
				"html-validate:recommended",
				"plugin:recommended",
				"module",
				"./local-file.json"
			]
		]
	},
	plugins: {
		type: "array",
		items: {
			anyOf: [
				{
					type: "string"
				},
				{
					type: "object"
				}
			]
		},
		title: "Plugins to load",
		description: "Array of plugins load. Use <rootDir> to refer to the folder with the package.json file.",
		examples: [
			[
				"my-plugin",
				"./local-plugin"
			]
		]
	},
	transform: {
		type: "object",
		additionalProperties: {
			type: "string"
		},
		title: "File transformations to use.",
		description: "Object where key is regular expression to match filename and value is name of transformer.",
		examples: [
			{
				"^.*\\.foo$": "my-transformer",
				"^.*\\.bar$": "my-plugin",
				"^.*\\.baz$": "my-plugin:named"
			}
		]
	},
	rules: {
		type: "object",
		patternProperties: {
			".*": {
				anyOf: [
					{
						"enum": [
							0,
							1,
							2,
							"off",
							"warn",
							"error"
						]
					},
					{
						type: "array",
						minItems: 1,
						maxItems: 1,
						items: [
							{
								"enum": [
									0,
									1,
									2,
									"off",
									"warn",
									"error"
								]
							}
						]
					},
					{
						type: "array",
						minItems: 2,
						maxItems: 2,
						items: [
							{
								"enum": [
									0,
									1,
									2,
									"off",
									"warn",
									"error"
								]
							},
							{
							}
						]
					}
				]
			}
		},
		title: "Rule configuration.",
		description: "Enable/disable rules, set severity. Some rules have additional configuration like style or patterns to use.",
		examples: [
			{
				foo: "error",
				bar: "off",
				baz: [
					"error",
					{
						style: "camelcase"
					}
				]
			}
		]
	}
};
var configurationSchema = {
	$schema: $schema,
	$id: $id,
	type: type,
	additionalProperties: additionalProperties,
	properties: properties
};

const TRANSFORMER_API = {
  VERSION: 1
};

var Severity = /* @__PURE__ */ ((Severity2) => {
  Severity2[Severity2["DISABLED"] = 0] = "DISABLED";
  Severity2[Severity2["WARN"] = 1] = "WARN";
  Severity2[Severity2["ERROR"] = 2] = "ERROR";
  return Severity2;
})(Severity || {});
function parseSeverity(value) {
  switch (value) {
    case 0:
    case "off":
      return 0 /* DISABLED */;
    case 1:
    case "warn":
      return 1 /* WARN */;
    case 2:
    case "error":
      return 2 /* ERROR */;
    default:
      throw new Error(`Invalid severity "${String(value)}"`);
  }
}

function escape(value) {
  return JSON.stringify(value);
}
function format(value, quote = false) {
  if (value === null) {
    return "null";
  }
  if (typeof value === "number") {
    return value.toString();
  }
  if (typeof value === "string") {
    return quote ? escape(value) : value;
  }
  if (Array.isArray(value)) {
    const content = value.map((it) => format(it, true)).join(", ");
    return `[ ${content} ]`;
  }
  if (typeof value === "object") {
    const content = Object.entries(value).map(([key, nested]) => `${key}: ${format(nested, true)}`).join(", ");
    return `{ ${content} }`;
  }
  return String(value);
}
function interpolate(text, data) {
  return text.replace(/{{\s*([^\s{}]+)\s*}}/g, (match, key) => {
    return typeof data[key] !== "undefined" ? format(data[key]) : match;
  });
}

const cacheKey = Symbol("aria-naming");
const defaultValue = "allowed";
const prohibitedRoles = [
  "caption",
  "code",
  "deletion",
  "emphasis",
  "generic",
  "insertion",
  "paragraph",
  "presentation",
  "strong",
  "subscript",
  "superscript"
];
function byRole(role) {
  return prohibitedRoles.includes(role) ? "prohibited" : "allowed";
}
function byMeta(element, meta) {
  return meta.aria.naming(element._adapter);
}
function ariaNaming(element) {
  var _a;
  const cached = element.cacheGet(cacheKey);
  if (cached) {
    return cached;
  }
  const role = (_a = element.getAttribute("role")) == null ? void 0 : _a.value;
  if (role) {
    if (role instanceof DynamicValue) {
      return element.cacheSet(cacheKey, defaultValue);
    } else {
      return element.cacheSet(cacheKey, byRole(role));
    }
  }
  const meta = element.meta;
  if (!meta) {
    return element.cacheSet(cacheKey, defaultValue);
  }
  return element.cacheSet(cacheKey, byMeta(element, meta));
}

const patternCache = /* @__PURE__ */ new Map();
function compileStringPattern(pattern) {
  const regexp = pattern.replace(/[*]+/g, ".+");
  return new RegExp(`^${regexp}$`);
}
function compileRegExpPattern(pattern) {
  return new RegExp(`^${pattern}$`);
}
function compilePattern(pattern) {
  const cached = patternCache.get(pattern);
  if (cached) {
    return cached;
  }
  const match = pattern.match(/^\/(.*)\/$/);
  const regexp = match ? compileRegExpPattern(match[1]) : compileStringPattern(pattern);
  patternCache.set(pattern, regexp);
  return regexp;
}
function keywordPatternMatcher(list, keyword) {
  for (const pattern of list) {
    const regexp = compilePattern(pattern);
    if (regexp.test(keyword)) {
      return true;
    }
  }
  return false;
}
function isKeywordIgnored(options, keyword, matcher = (list, it) => list.includes(it)) {
  const { include, exclude } = options;
  if (include && !matcher(include, keyword)) {
    return true;
  }
  if (exclude && matcher(exclude, keyword)) {
    return true;
  }
  return false;
}

const ARIA_HIDDEN_CACHE = Symbol(isAriaHidden.name);
const HTML_HIDDEN_CACHE = Symbol(isHTMLHidden.name);
const INERT_CACHE = Symbol(isInert.name);
const ROLE_PRESENTATION_CACHE = Symbol(isPresentation.name);
const STYLE_HIDDEN_CACHE = Symbol(isStyleHidden.name);
function inAccessibilityTree(node) {
  if (isAriaHidden(node)) {
    return false;
  }
  if (isPresentation(node)) {
    return false;
  }
  if (isHTMLHidden(node)) {
    return false;
  }
  if (isInert(node)) {
    return false;
  }
  if (isStyleHidden(node)) {
    return false;
  }
  return true;
}
function isAriaHiddenImpl(node) {
  const getAriaHiddenAttr = (node2) => {
    const ariaHidden = node2.getAttribute("aria-hidden");
    return Boolean(ariaHidden && ariaHidden.value === "true");
  };
  return {
    byParent: node.parent ? isAriaHidden(node.parent) : false,
    bySelf: getAriaHiddenAttr(node)
  };
}
function isAriaHidden(node, details) {
  const cached = node.cacheGet(ARIA_HIDDEN_CACHE);
  if (cached) {
    return details ? cached : cached.byParent || cached.bySelf;
  }
  const result = node.cacheSet(ARIA_HIDDEN_CACHE, isAriaHiddenImpl(node));
  return details ? result : result.byParent || result.bySelf;
}
function isHTMLHiddenImpl(node) {
  const getHiddenAttr = (node2) => {
    const hidden = node2.getAttribute("hidden");
    return hidden !== null && hidden.isStatic;
  };
  return {
    byParent: node.parent ? isHTMLHidden(node.parent) : false,
    bySelf: getHiddenAttr(node)
  };
}
function isHTMLHidden(node, details) {
  const cached = node.cacheGet(HTML_HIDDEN_CACHE);
  if (cached) {
    return details ? cached : cached.byParent || cached.bySelf;
  }
  const result = node.cacheSet(HTML_HIDDEN_CACHE, isHTMLHiddenImpl(node));
  return details ? result : result.byParent || result.bySelf;
}
function isInertImpl(node) {
  const getInertAttr = (node2) => {
    const inert = node2.getAttribute("inert");
    return inert !== null && inert.isStatic;
  };
  return {
    byParent: node.parent ? isInert(node.parent) : false,
    bySelf: getInertAttr(node)
  };
}
function isInert(node, details) {
  const cached = node.cacheGet(INERT_CACHE);
  if (cached) {
    return details ? cached : cached.byParent || cached.bySelf;
  }
  const result = node.cacheSet(INERT_CACHE, isInertImpl(node));
  return details ? result : result.byParent || result.bySelf;
}
function isStyleHiddenImpl(node) {
  const getStyleAttr = (node2) => {
    const style = node2.getAttribute("style");
    const { display, visibility } = parseCssDeclaration(style == null ? void 0 : style.value);
    return display === "none" || visibility === "hidden";
  };
  const byParent = node.parent ? isStyleHidden(node.parent) : false;
  const bySelf = getStyleAttr(node);
  return byParent || bySelf;
}
function isStyleHidden(node) {
  const cached = node.cacheGet(STYLE_HIDDEN_CACHE);
  if (cached) {
    return cached;
  }
  return node.cacheSet(STYLE_HIDDEN_CACHE, isStyleHiddenImpl(node));
}
function isPresentation(node) {
  if (node.cacheExists(ROLE_PRESENTATION_CACHE)) {
    return Boolean(node.cacheGet(ROLE_PRESENTATION_CACHE));
  }
  const meta = node.meta;
  if (meta && meta.interactive) {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
  }
  const tabindex = node.getAttribute("tabindex");
  if (tabindex) {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
  }
  const role = node.getAttribute("role");
  if (role && (role.value === "presentation" || role.value === "none")) {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, true);
  } else {
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
  }
}

const cachePrefix = classifyNodeText.name;
const HTML_CACHE_KEY = Symbol(`${cachePrefix}|html`);
const A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y`);
const IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY = Symbol(`${cachePrefix}|html|ignore-hidden-root`);
const IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y|ignore-hidden-root`);
var TextClassification = /* @__PURE__ */ ((TextClassification2) => {
  TextClassification2[TextClassification2["EMPTY_TEXT"] = 0] = "EMPTY_TEXT";
  TextClassification2[TextClassification2["DYNAMIC_TEXT"] = 1] = "DYNAMIC_TEXT";
  TextClassification2[TextClassification2["STATIC_TEXT"] = 2] = "STATIC_TEXT";
  return TextClassification2;
})(TextClassification || {});
function getCachekey(options) {
  const { accessible = false, ignoreHiddenRoot = false } = options;
  if (accessible && ignoreHiddenRoot) {
    return IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY;
  } else if (ignoreHiddenRoot) {
    return IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY;
  } else if (accessible) {
    return A11Y_CACHE_KEY;
  } else {
    return HTML_CACHE_KEY;
  }
}
function isSpecialEmpty(node) {
  return node.is("select") || node.is("textarea");
}
function classifyNodeText(node, options = {}) {
  const { accessible = false, ignoreHiddenRoot = false } = options;
  const cacheKey = getCachekey(options);
  if (node.cacheExists(cacheKey)) {
    return node.cacheGet(cacheKey);
  }
  if (!ignoreHiddenRoot && isHTMLHidden(node)) {
    return node.cacheSet(cacheKey, 0 /* EMPTY_TEXT */);
  }
  if (!ignoreHiddenRoot && accessible && isAriaHidden(node)) {
    return node.cacheSet(cacheKey, 0 /* EMPTY_TEXT */);
  }
  if (isSpecialEmpty(node)) {
    return node.cacheSet(cacheKey, 0 /* EMPTY_TEXT */);
  }
  const text = findTextNodes(node, {
    ...options,
    ignoreHiddenRoot: false
  });
  if (text.some((cur) => cur.isDynamic)) {
    return node.cacheSet(cacheKey, 1 /* DYNAMIC_TEXT */);
  }
  if (text.some((cur) => cur.textContent.match(/\S/) !== null)) {
    return node.cacheSet(cacheKey, 2 /* STATIC_TEXT */);
  }
  return node.cacheSet(cacheKey, 0 /* EMPTY_TEXT */);
}
function findTextNodes(node, options) {
  const { accessible = false } = options;
  let text = [];
  for (const child of node.childNodes) {
    if (isTextNode(child)) {
      text.push(child);
    } else if (isElementNode(child)) {
      if (isHTMLHidden(child, true).bySelf) {
        continue;
      }
      if (accessible && isAriaHidden(child, true).bySelf) {
        continue;
      }
      text = text.concat(findTextNodes(child, options));
    }
  }
  return text;
}

function hasAltText(image) {
  const alt = image.getAttribute("alt");
  if (!alt) {
    return false;
  }
  if (alt.value === null) {
    return false;
  }
  return alt.isDynamic || alt.value.toString() !== "";
}

function hasAriaLabel(node) {
  const label = node.getAttribute("aria-label");
  if (!label) {
    return false;
  }
  if (label.value === null) {
    return false;
  }
  return label.isDynamic || label.value.toString() !== "";
}

function partition(values, predicate) {
  const initial = [[], []];
  return values.reduce((accumulator, value, index) => {
    const match = predicate(value, index, values);
    accumulator[match ? 0 : 1].push(value);
    return accumulator;
  }, initial);
}

const remapEvents = {
  "tag:open": "tag:start",
  "tag:close": "tag:end"
};
const ajv$1 = new Ajv__default.default({ strict: true, strictTuples: true, strictTypes: true });
ajv$1.addMetaSchema(ajvSchemaDraft);
function getSchemaValidator(ruleId, properties) {
  const $id = `rule/${ruleId}`;
  const cached = ajv$1.getSchema($id);
  if (cached) {
    return cached;
  }
  const schema = {
    $id,
    type: "object",
    additionalProperties: false,
    properties
  };
  return ajv$1.compile(schema);
}
function isErrorDescriptor(value) {
  return Boolean(value[0] && value[0].message);
}
function unpackErrorDescriptor(value) {
  if (isErrorDescriptor(value)) {
    return value[0];
  } else {
    const [node, message, location, context] = value;
    return { node, message, location, context };
  }
}
class Rule {
  constructor(options) {
    this.reporter = null;
    this.parser = null;
    this.meta = null;
    this.event = null;
    this.options = options;
    this.enabled = true;
    this.blockers = [];
    this.severity = Severity.DISABLED;
    this.name = "";
  }
  getSeverity() {
    return this.severity;
  }
  setServerity(severity) {
    this.severity = severity;
  }
  /**
   * Block this rule from generating errors. Pass in an id generated by
   * `createBlocker`. Can be unblocked by {@link Rule.unblock}.
   *
   * A blocked rule is similar to disabling it but it will still receive parser
   * events. A list of all blockers is passed to the `rule:error` event.
   *
   * @internal
   */
  block(id) {
    this.blockers.push(id);
  }
  /**
   * Unblock a rule previously blocked by {@link Rule.block}.
   *
   * @internal
   */
  unblock(id) {
    this.blockers = this.blockers.filter((it) => it !== id);
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns `true` if rule is deprecated.
   *
   * Overridden by subclasses.
   */
  get deprecated() {
    return false;
  }
  /**
   * Test if rule is enabled.
   *
   * To be considered enabled the enabled flag must be true and the severity at
   * least warning.
   *
   * @internal
   */
  isEnabled(node) {
    return this.enabled && this.severity >= Severity.WARN && (!node || node.ruleEnabled(this.name));
  }
  /**
   * Test if rule is enabled.
   *
   * To be considered enabled the enabled flag must be true and the severity at
   * least warning.
   *
   * @internal
   */
  isBlocked(node) {
    if (this.blockers.length > 0) {
      return true;
    }
    if (node && node.ruleBlockers(this.name).length > 0) {
      return true;
    }
    return false;
  }
  /**
   * Get a list of all blockers currently active this rule.
   *
   * @internal
   */
  getBlockers(node) {
    return [...this.blockers, ...node ? node.ruleBlockers(this.name) : []];
  }
  /**
   * Check if keyword is being ignored by the current rule configuration.
   *
   * This method requires the [[RuleOption]] type to include two properties:
   *
   * - include: string[] | null
   * - exclude: string[] | null
   *
   * This methods checks if the given keyword is included by "include" but not
   * excluded by "exclude". If any property is unset it is skipped by the
   * condition. Usually the user would use either one but not both but there is
   * no limitation to use both but the keyword must satisfy both conditions. If
   * either condition fails `true` is returned.
   *
   * For instance, given `{ include: ["foo"] }` the keyword `"foo"` would match
   * but not `"bar"`.
   *
   * Similarly, given `{ exclude: ["foo"] }` the keyword `"bar"` would match but
   * not `"foo"`.
   *
   * @param keyword - Keyword to match against `include` and `exclude` options.
   * @param matcher - Optional function to compare items with.
   * @returns `true` if keyword is not present in `include` or is present in
   * `exclude`.
   */
  isKeywordIgnored(keyword, matcher = (list, it) => list.includes(it)) {
    return isKeywordIgnored(this.options, keyword, matcher);
  }
  /**
   * Get [[MetaElement]] for the given tag. If no specific metadata is present
   * the global metadata is returned or null if no global is present.
   *
   * @public
   * @returns A shallow copy of metadata.
   */
  getMetaFor(tagName) {
    return this.meta.getMetaFor(tagName);
  }
  /**
   * Find all tags which has enabled given property.
   */
  getTagsWithProperty(propName) {
    return this.meta.getTagsWithProperty(propName);
  }
  /**
   * Find tag matching tagName or inheriting from it.
   */
  getTagsDerivedFrom(tagName) {
    return this.meta.getTagsDerivedFrom(tagName);
  }
  /**
   * JSON schema for rule options.
   *
   * Rules should override this to return an object with JSON schema to validate
   * rule options. If `null` or `undefined` is returned no validation is
   * performed.
   */
  static schema() {
    return null;
  }
  report(...args) {
    const { node, message, location, context } = unpackErrorDescriptor(args);
    const enabled = this.isEnabled(node);
    const blocked = this.isBlocked(node);
    const where = this.findLocation({ node, location, event: this.event });
    this.parser.trigger("rule:error", {
      location: where,
      ruleId: this.name,
      enabled,
      blockers: this.getBlockers(node)
    });
    if (enabled && !blocked) {
      const interpolated = interpolate(message, context ?? {});
      this.reporter.add(this, interpolated, this.severity, node, where, context);
    }
  }
  findLocation(src) {
    var _a, _b;
    if (src.location) {
      return src.location;
    }
    if ((_a = src.event) == null ? void 0 : _a.location) {
      return src.event.location;
    }
    if ((_b = src.node) == null ? void 0 : _b.location) {
      return src.node.location;
    }
    return {};
  }
  on(event, ...args) {
    const remap = remapEvents[event];
    if (remap) {
      event = remap;
    }
    const callback = args.pop();
    const filter = args.pop() ?? (() => true);
    return this.parser.on(event, (_event, data) => {
      if (this.isEnabled() && filter(data)) {
        this.event = data;
        callback(data);
      }
    });
  }
  /**
   * Called by [[Engine]] when initializing the rule.
   *
   * Do not override this, use the `setup` callback instead.
   *
   * @internal
   */
  init(parser, reporter, severity, meta) {
    this.parser = parser;
    this.reporter = reporter;
    this.severity = severity;
    this.meta = meta;
  }
  /**
   * Validate rule options against schema. Throws error if object does not validate.
   *
   * For rules without schema this function does nothing.
   *
   * @throws {@link SchemaValidationError}
   * Thrown when provided options does not validate against rule schema.
   *
   * @param cls - Rule class (constructor)
   * @param ruleId - Rule identifier
   * @param jsonPath - JSON path from which [[options]] can be found in [[config]]
   * @param options - User configured options to be validated
   * @param filename - Filename from which options originated
   * @param config - Configuration from which options originated
   *
   * @internal
   */
  static validateOptions(cls, ruleId, jsonPath, options, filename, config) {
    if (!cls) {
      return;
    }
    const schema = cls.schema();
    if (!schema) {
      return;
    }
    const isValid = getSchemaValidator(ruleId, schema);
    if (!isValid(options)) {
      const errors = isValid.errors ?? [];
      const mapped = errors.map((error) => {
        error.instancePath = `${jsonPath}${error.instancePath}`;
        return error;
      });
      throw new SchemaValidationError(filename, `Rule configuration error`, config, schema, mapped);
    }
  }
  /**
   * Rule documentation callback.
   *
   * Called when requesting additional documentation for a rule. Some rules
   * provide additional context to provide context-aware suggestions.
   *
   * @public
   * @virtual
   * @param context - Error context given by a reported error.
   * @returns Rule documentation and url with additional details or `null` if no
   * additional documentation is available.
   */
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- technical debt, prototype should be moved to interface */
  documentation(context) {
    return null;
  }
}

const defaults$x = {
  allowExternal: true,
  allowRelative: true,
  allowAbsolute: true,
  allowBase: true
};
const mapping = {
  a: "href",
  img: "src",
  link: "href",
  script: "src"
};
const description = {
  ["external" /* EXTERNAL */]: "External links are not allowed by current configuration.",
  ["relative-base" /* RELATIVE_BASE */]: "Links relative to <base> are not allowed by current configuration.",
  ["relative-path" /* RELATIVE_PATH */]: "Relative links are not allowed by current configuration.",
  ["absolute" /* ABSOLUTE */]: "Absolute links are not allowed by current configuration.",
  ["anchor" /* ANCHOR */]: null
};
function parseAllow(value) {
  if (typeof value === "boolean") {
    return value;
  }
  return {
    /* eslint-disable security/detect-non-literal-regexp -- expected to be regexp  */
    include: value.include ? value.include.map((it) => new RegExp(it)) : null,
    exclude: value.exclude ? value.exclude.map((it) => new RegExp(it)) : null
    /* eslint-enable security/detect-non-literal-regexp */
  };
}
function matchList(value, list) {
  if (list.include && !list.include.some((it) => it.test(value))) {
    return false;
  }
  if (list.exclude && list.exclude.some((it) => it.test(value))) {
    return false;
  }
  return true;
}
class AllowedLinks extends Rule {
  constructor(options) {
    super({ ...defaults$x, ...options });
    this.allowExternal = parseAllow(this.options.allowExternal);
    this.allowRelative = parseAllow(this.options.allowRelative);
    this.allowAbsolute = parseAllow(this.options.allowAbsolute);
  }
  static schema() {
    const booleanOrObject = {
      anyOf: [
        { type: "boolean" },
        {
          type: "object",
          properties: {
            include: {
              type: "array",
              items: { type: "string" }
            },
            exclude: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      ]
    };
    return {
      allowExternal: { ...booleanOrObject },
      allowRelative: { ...booleanOrObject },
      allowAbsolute: { ...booleanOrObject },
      allowBase: { type: "boolean" }
    };
  }
  documentation(context) {
    const message = description[context] ?? "This link type is not allowed by current configuration";
    return {
      description: message,
      url: "https://html-validate.org/rules/allowed-links.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (!event.value || !this.isRelevant(event)) {
        return;
      }
      const link = event.value.toString();
      const style = this.getStyle(link);
      switch (style) {
        case "anchor" /* ANCHOR */:
          break;
        case "absolute" /* ABSOLUTE */:
          this.handleAbsolute(link, event, style);
          break;
        case "external" /* EXTERNAL */:
          this.handleExternal(link, event, style);
          break;
        case "relative-base" /* RELATIVE_BASE */:
          this.handleRelativeBase(link, event, style);
          break;
        case "relative-path" /* RELATIVE_PATH */:
          this.handleRelativePath(link, event, style);
          break;
      }
    });
  }
  isRelevant(event) {
    const { target, key, value } = event;
    if (value instanceof DynamicValue) {
      return false;
    }
    const attr = mapping[target.tagName];
    return Boolean(attr && attr === key);
  }
  getStyle(value) {
    if (value.match(/^([a-z]+:)?\/\//g)) {
      return "external" /* EXTERNAL */;
    }
    switch (value[0]) {
      case "/":
        return "absolute" /* ABSOLUTE */;
      case ".":
        return "relative-path" /* RELATIVE_PATH */;
      case "#":
        return "anchor" /* ANCHOR */;
      default:
        return "relative-base" /* RELATIVE_BASE */;
    }
  }
  handleAbsolute(target, event, style) {
    const { allowAbsolute } = this;
    if (allowAbsolute === true) {
      return;
    } else if (allowAbsolute === false) {
      this.report(
        event.target,
        "Link destination must not be absolute url",
        event.valueLocation,
        style
      );
    } else if (!matchList(target, allowAbsolute)) {
      this.report(
        event.target,
        "Absolute link to this destination is not allowed by current configuration",
        event.valueLocation,
        style
      );
    }
  }
  handleExternal(target, event, style) {
    const { allowExternal } = this;
    if (allowExternal === true) {
      return;
    } else if (allowExternal === false) {
      this.report(
        event.target,
        "Link destination must not be external url",
        event.valueLocation,
        style
      );
    } else if (!matchList(target, allowExternal)) {
      this.report(
        event.target,
        "External link to this destination is not allowed by current configuration",
        event.valueLocation,
        style
      );
    }
  }
  handleRelativePath(target, event, style) {
    const { allowRelative } = this;
    if (allowRelative === true) {
      return false;
    } else if (allowRelative === false) {
      this.report(
        event.target,
        "Link destination must not be relative url",
        event.valueLocation,
        style
      );
      return true;
    } else if (!matchList(target, allowRelative)) {
      this.report(
        event.target,
        "Relative link to this destination is not allowed by current configuration",
        event.valueLocation,
        style
      );
      return true;
    }
    return false;
  }
  handleRelativeBase(target, event, style) {
    const { allowBase } = this.options;
    if (this.handleRelativePath(target, event, style)) {
      return;
    } else if (!allowBase) {
      this.report(
        event.target,
        "Relative links must be relative to current folder",
        event.valueLocation,
        style
      );
    }
  }
}

const defaults$w = {
  accessible: true
};
function findByTarget(target, siblings) {
  return siblings.filter((it) => it.getAttributeValue("href") === target);
}
function getAltText(node) {
  return node.getAttributeValue("alt");
}
function getDescription$1(context) {
  switch (context) {
    case "missing-alt" /* MISSING_ALT */:
      return [
        "The `alt` attribute must be set (and not empty) when the `href` attribute is present on an `<area>` element.",
        "",
        "The attribute is used to provide an alternative text description for the area of the image map.",
        "The text should describe the purpose of area and the resource referenced by the `href` attribute.",
        "",
        "Either add the `alt` attribute or remove the `href` attribute."
      ];
    case "missing-href" /* MISSING_HREF */:
      return [
        "The `alt` attribute must not be set when the `href` attribute is missing on an `<area>` element.",
        "",
        "Either add the `href` attribute or remove the `alt` attribute."
      ];
  }
}
class AreaAlt extends Rule {
  constructor(options) {
    super({ ...defaults$w, ...options });
  }
  static schema() {
    return {
      accessible: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    return {
      description: getDescription$1(context).join("\n"),
      url: "https://html-validate.org/rules/area-alt.html"
    };
  }
  setup() {
    this.on("element:ready", this.isRelevant, (event) => {
      const { target } = event;
      const siblings = target.querySelectorAll("area");
      for (const child of siblings) {
        this.validateArea(child, siblings);
      }
    });
  }
  validateArea(area, siblings) {
    const { accessible } = this.options;
    const href = area.getAttribute("href");
    const alt = area.getAttribute("alt");
    if (href) {
      if (alt && alt.isDynamic) {
        return;
      }
      const target = area.getAttributeValue("href");
      const altTexts = accessible ? [getAltText(area)] : findByTarget(target, siblings).map(getAltText);
      if (!altTexts.some(Boolean)) {
        this.report({
          node: area,
          message: `"alt" attribute must be set and non-empty when the "href" attribute is present`,
          location: alt ? alt.keyLocation : href.keyLocation,
          context: "missing-alt" /* MISSING_ALT */
        });
      }
    } else if (alt) {
      this.report({
        node: area,
        message: `"alt" attribute cannot be used unless the "href" attribute is present`,
        location: alt.keyLocation,
        context: "missing-href" /* MISSING_HREF */
      });
    }
  }
  isRelevant(event) {
    const { target } = event;
    return target.is("map");
  }
}

class AriaHiddenBody extends Rule {
  documentation() {
    return {
      description: "`aria-hidden` must not be used on the `<body>` element as it makes the page inaccessible to assistive technology such as screenreaders",
      url: "https://html-validate.org/rules/aria-hidden-body.html"
    };
  }
  setup() {
    this.on("tag:ready", this.isRelevant, (event) => {
      const { target } = event;
      const attr = target.getAttribute("aria-hidden");
      if (!attr || !attr.valueMatches("true", true)) {
        return;
      }
      this.report(target, "aria-hidden must not be used on <body>", attr.keyLocation);
    });
  }
  isRelevant(event) {
    return event.target.is("body");
  }
}

const defaults$v = {
  allowAnyNamable: false
};
const whitelisted = [
  "main",
  "nav",
  "table",
  "td",
  "th",
  "aside",
  "header",
  "footer",
  "section",
  "article",
  "form",
  "img",
  "area",
  "fieldset",
  "summary",
  "figure"
];
function isValidUsage(target, meta) {
  const explicit = meta.attributes["aria-label"];
  if (explicit) {
    return true;
  }
  if (whitelisted.includes(target.tagName)) {
    return true;
  }
  if (target.hasAttribute("role")) {
    return true;
  }
  if (target.hasAttribute("tabindex")) {
    return true;
  }
  if (Boolean(meta.interactive) || Boolean(meta.labelable)) {
    return true;
  }
  return false;
}
class AriaLabelMisuse extends Rule {
  constructor(options) {
    super({ ...defaults$v, ...options });
  }
  documentation() {
    const valid = [
      "Interactive elements",
      "Labelable elements",
      "Landmark elements",
      "Elements with roles inheriting from widget",
      "`<area>`",
      "`<form>` and `<fieldset>`",
      "`<iframe>`",
      "`<img>` and `<figure>`",
      "`<summary>`",
      "`<table>`, `<td>` and `<th>`"
    ];
    const lines = valid.map((it) => `- ${it}
`).join("");
    return {
      description: `\`aria-label\` can only be used on:

${lines}`,
      url: "https://html-validate.org/rules/aria-label-misuse.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      for (const target of document.querySelectorAll("[aria-label]")) {
        this.validateElement(target);
      }
    });
  }
  validateElement(target) {
    const attr = target.getAttribute("aria-label");
    if (!attr.value || attr.valueMatches("", false)) {
      return;
    }
    const meta = target.meta;
    if (!meta) {
      return;
    }
    if (isValidUsage(target, meta)) {
      return;
    }
    if (this.options.allowAnyNamable && ariaNaming(target) === "allowed") {
      return;
    }
    this.report(target, `"aria-label" cannot be used on this element`, attr.keyLocation);
  }
}

class ConfigError extends UserError {
  constructor(message, nested) {
    super(message, nested);
    Error.captureStackTrace(this, ConfigError);
    this.name = ConfigError.name;
  }
}

class CaseStyle {
  /**
   * @param style - Name of a valid case style.
   */
  constructor(style, ruleId) {
    if (!Array.isArray(style)) {
      style = [style];
    }
    if (style.length === 0) {
      throw new ConfigError(`Missing style for ${ruleId} rule`);
    }
    this.styles = this.parseStyle(style, ruleId);
  }
  /**
   * Test if a text matches this case style.
   */
  match(text) {
    return this.styles.some((style) => text.match(style.pattern));
  }
  get name() {
    const names = this.styles.map((style) => style.name);
    switch (this.styles.length) {
      case 1:
        return names[0];
      case 2:
        return names.join(" or ");
      default: {
        const last = names.slice(-1);
        const rest = names.slice(0, -1);
        return `${rest.join(", ")} or ${last[0]}`;
      }
    }
  }
  parseStyle(style, ruleId) {
    return style.map((cur) => {
      switch (cur.toLowerCase()) {
        case "lowercase":
          return { pattern: /^[a-z]*$/, name: "lowercase" };
        case "uppercase":
          return { pattern: /^[A-Z]*$/, name: "uppercase" };
        case "pascalcase":
          return { pattern: /^[A-Z][A-Za-z]*$/, name: "PascalCase" };
        case "camelcase":
          return { pattern: /^[a-z][A-Za-z]*$/, name: "camelCase" };
        default:
          throw new ConfigError(`Invalid style "${cur}" for ${ruleId} rule`);
      }
    });
  }
}

const defaults$u = {
  style: "lowercase",
  ignoreForeign: true
};
class AttrCase extends Rule {
  constructor(options) {
    super({ ...defaults$u, ...options });
    this.style = new CaseStyle(this.options.style, "attr-case");
  }
  static schema() {
    const styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
    return {
      ignoreForeign: {
        type: "boolean"
      },
      style: {
        anyOf: [
          {
            enum: styleEnum,
            type: "string"
          },
          {
            items: {
              enum: styleEnum,
              type: "string"
            },
            type: "array"
          }
        ]
      }
    };
  }
  documentation() {
    const { style } = this.options;
    return {
      description: Array.isArray(style) ? [`Attribute name must be in one of:`, "", ...style.map((it) => `- ${it}`)].join("\n") : `Attribute name must be in ${style}.`,
      url: "https://html-validate.org/rules/attr-case.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (this.isIgnored(event.target)) {
        return;
      }
      if (event.originalAttribute) {
        return;
      }
      const letters = event.key.replace(/[^a-z]+/gi, "");
      if (this.style.match(letters)) {
        return;
      }
      this.report({
        node: event.target,
        message: `Attribute "${event.key}" should be ${this.style.name}`,
        location: event.keyLocation
      });
    });
  }
  isIgnored(node) {
    if (this.options.ignoreForeign) {
      return Boolean(node.meta && node.meta.foreign);
    } else {
      return false;
    }
  }
}

var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2[TokenType2["UNICODE_BOM"] = 1] = "UNICODE_BOM";
  TokenType2[TokenType2["WHITESPACE"] = 2] = "WHITESPACE";
  TokenType2[TokenType2["DOCTYPE_OPEN"] = 3] = "DOCTYPE_OPEN";
  TokenType2[TokenType2["DOCTYPE_VALUE"] = 4] = "DOCTYPE_VALUE";
  TokenType2[TokenType2["DOCTYPE_CLOSE"] = 5] = "DOCTYPE_CLOSE";
  TokenType2[TokenType2["TAG_OPEN"] = 6] = "TAG_OPEN";
  TokenType2[TokenType2["TAG_CLOSE"] = 7] = "TAG_CLOSE";
  TokenType2[TokenType2["ATTR_NAME"] = 8] = "ATTR_NAME";
  TokenType2[TokenType2["ATTR_VALUE"] = 9] = "ATTR_VALUE";
  TokenType2[TokenType2["TEXT"] = 10] = "TEXT";
  TokenType2[TokenType2["TEMPLATING"] = 11] = "TEMPLATING";
  TokenType2[TokenType2["SCRIPT"] = 12] = "SCRIPT";
  TokenType2[TokenType2["STYLE"] = 13] = "STYLE";
  TokenType2[TokenType2["COMMENT"] = 14] = "COMMENT";
  TokenType2[TokenType2["CONDITIONAL"] = 15] = "CONDITIONAL";
  TokenType2[TokenType2["DIRECTIVE"] = 16] = "DIRECTIVE";
  TokenType2[TokenType2["EOF"] = 17] = "EOF";
  return TokenType2;
})(TokenType || {});

const MATCH_UNICODE_BOM = /^\uFEFF/;
const MATCH_WHITESPACE = /^(?:\r\n|\r|\n|[ \t]+(?:\r\n|\r|\n)?)/;
const MATCH_DOCTYPE_OPEN = /^<!(DOCTYPE)\s/i;
const MATCH_DOCTYPE_VALUE = /^[^>]+/;
const MATCH_DOCTYPE_CLOSE = /^>/;
const MATCH_XML_TAG = /^<\?xml.*?\?>\s+/;
const MATCH_TAG_OPEN = /^<(\/?)([a-zA-Z0-9\-:]+)/;
const MATCH_TAG_CLOSE = /^\/?>/;
const MATCH_TEXT = /^[^]*?(?=(?:[ \t]*(?:\r\n|\r|\n)|<[^ ]|$))/;
const MATCH_TEMPLATING = /^(?:<%.*?%>|<\?.*?\?>|<\$.*?\$>)/s;
const MATCH_TAG_LOOKAHEAD = /^[^]*?(?=<|$)/;
const MATCH_ATTR_START = /^([^\t\r\n\f \/><"'=]+)/;
const MATCH_ATTR_SINGLE = /^(\s*=\s*)'([^']*?)(')/;
const MATCH_ATTR_DOUBLE = /^(\s*=\s*)"([^"]*?)(")/;
const MATCH_ATTR_UNQUOTED = /^(\s*=\s*)([^\t\r\n\f "'<>][^\t\r\n\f <>]*)/;
const MATCH_CDATA_BEGIN = /^<!\[CDATA\[/;
const MATCH_CDATA_END = /^[^]*?]]>/;
const MATCH_SCRIPT_DATA = /^[^]*?(?=<\/script)/;
const MATCH_SCRIPT_END = /^<(\/)(script)/;
const MATCH_STYLE_DATA = /^[^]*?(?=<\/style)/;
const MATCH_STYLE_END = /^<(\/)(style)/;
const MATCH_DIRECTIVE = /^(<!--\s*\[html-validate-)([a-z0-9-]+)(\s*)(.*?)(]?\s*-->)/;
const MATCH_COMMENT = /^<!--([^]*?)-->/;
const MATCH_CONDITIONAL = /^<!\[([^\]]*?)\]>/;
class InvalidTokenError extends Error {
  constructor(location, message) {
    super(message);
    this.location = location;
  }
}
class Lexer {
  /* eslint-disable-next-line complexity -- there isn't really a good way to refactor this while keeping readability */
  *tokenize(source) {
    const context = new Context(source);
    let previousState = context.state;
    let previousLength = context.string.length;
    while (context.string.length > 0) {
      switch (context.state) {
        case State.INITIAL:
          yield* this.tokenizeInitial(context);
          break;
        case State.DOCTYPE:
          yield* this.tokenizeDoctype(context);
          break;
        case State.TAG:
          yield* this.tokenizeTag(context);
          break;
        case State.ATTR:
          yield* this.tokenizeAttr(context);
          break;
        case State.TEXT:
          yield* this.tokenizeText(context);
          break;
        case State.CDATA:
          yield* this.tokenizeCDATA(context);
          break;
        case State.SCRIPT:
          yield* this.tokenizeScript(context);
          break;
        case State.STYLE:
          yield* this.tokenizeStyle(context);
          break;
        default:
          this.unhandled(context);
      }
      if (context.state === previousState && context.string.length === previousLength) {
        this.errorStuck(context);
      }
      previousState = context.state;
      previousLength = context.string.length;
    }
    yield this.token(context, TokenType.EOF, []);
  }
  token(context, type, data) {
    const size = data.length > 0 ? data[0].length : 0;
    const location = context.getLocation(size);
    return {
      type,
      location,
      data: Array.from(data)
    };
  }
  /* istanbul ignore next: used to provide a better error when an unhandled state happens */
  unhandled(context) {
    const truncated = JSON.stringify(
      context.string.length > 13 ? `${context.string.slice(0, 15)}...` : context.string
    );
    const state = State[context.state];
    const message = `failed to tokenize ${truncated}, unhandled state ${state}.`;
    throw new InvalidTokenError(context.getLocation(1), message);
  }
  /* istanbul ignore next: used to provide a better error when lexer is detected to be stuck, no known way to reproduce */
  errorStuck(context) {
    const state = State[context.state];
    const message = `failed to tokenize ${context.getTruncatedLine()}, state ${state} failed to consume data or change state.`;
    throw new InvalidTokenError(context.getLocation(1), message);
  }
  evalNextState(nextState, token) {
    if (typeof nextState === "function") {
      return nextState(token);
    } else {
      return nextState;
    }
  }
  *match(context, tests, error) {
    const n = tests.length;
    for (let i = 0; i < n; i++) {
      const [regex, nextState, tokenType] = tests[i];
      const match = regex ? context.string.match(regex) : [""];
      if (match) {
        let token = null;
        if (tokenType !== false) {
          token = this.token(context, tokenType, match);
          yield token;
        }
        const state = this.evalNextState(nextState, token);
        context.consume(match, state);
        this.enter(context, state, match);
        return;
      }
    }
    const message = `failed to tokenize ${context.getTruncatedLine()}, ${error}.`;
    throw new InvalidTokenError(context.getLocation(1), message);
  }
  /**
   * Called when entering a new state.
   */
  enter(context, state, data) {
    if (state === State.TAG && data && data[0].startsWith("<")) {
      if (data[0] === "<script") {
        context.contentModel = ContentModel.SCRIPT;
      } else if (data[0] === "<style") {
        context.contentModel = ContentModel.STYLE;
      } else {
        context.contentModel = ContentModel.TEXT;
      }
    }
  }
  *tokenizeInitial(context) {
    yield* this.match(
      context,
      [
        [MATCH_UNICODE_BOM, State.INITIAL, TokenType.UNICODE_BOM],
        [MATCH_XML_TAG, State.INITIAL, false],
        [MATCH_DOCTYPE_OPEN, State.DOCTYPE, TokenType.DOCTYPE_OPEN],
        [MATCH_WHITESPACE, State.INITIAL, TokenType.WHITESPACE],
        [MATCH_DIRECTIVE, State.INITIAL, TokenType.DIRECTIVE],
        [MATCH_CONDITIONAL, State.INITIAL, TokenType.CONDITIONAL],
        [MATCH_COMMENT, State.INITIAL, TokenType.COMMENT],
        [false, State.TEXT, false]
      ],
      "expected doctype"
    );
  }
  *tokenizeDoctype(context) {
    yield* this.match(
      context,
      [
        [MATCH_WHITESPACE, State.DOCTYPE, TokenType.WHITESPACE],
        [MATCH_DOCTYPE_VALUE, State.DOCTYPE, TokenType.DOCTYPE_VALUE],
        [MATCH_DOCTYPE_CLOSE, State.TEXT, TokenType.DOCTYPE_CLOSE]
      ],
      "expected doctype name"
    );
  }
  *tokenizeTag(context) {
    function nextState(token) {
      const tagCloseToken = token;
      switch (context.contentModel) {
        case ContentModel.TEXT:
          return State.TEXT;
        case ContentModel.SCRIPT:
          if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
            return State.SCRIPT;
          } else {
            return State.TEXT;
          }
        case ContentModel.STYLE:
          if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
            return State.STYLE;
          } else {
            return State.TEXT;
          }
      }
    }
    yield* this.match(
      context,
      [
        [MATCH_TAG_CLOSE, nextState, TokenType.TAG_CLOSE],
        [MATCH_ATTR_START, State.ATTR, TokenType.ATTR_NAME],
        [MATCH_WHITESPACE, State.TAG, TokenType.WHITESPACE]
      ],
      'expected attribute, ">" or "/>"'
    );
  }
  *tokenizeAttr(context) {
    yield* this.match(
      context,
      [
        [MATCH_ATTR_SINGLE, State.TAG, TokenType.ATTR_VALUE],
        [MATCH_ATTR_DOUBLE, State.TAG, TokenType.ATTR_VALUE],
        [MATCH_ATTR_UNQUOTED, State.TAG, TokenType.ATTR_VALUE],
        [false, State.TAG, false]
      ],
      'expected attribute, ">" or "/>"'
    );
  }
  *tokenizeText(context) {
    yield* this.match(
      context,
      [
        [MATCH_WHITESPACE, State.TEXT, TokenType.WHITESPACE],
        [MATCH_CDATA_BEGIN, State.CDATA, false],
        [MATCH_DIRECTIVE, State.TEXT, TokenType.DIRECTIVE],
        [MATCH_CONDITIONAL, State.TEXT, TokenType.CONDITIONAL],
        [MATCH_COMMENT, State.TEXT, TokenType.COMMENT],
        [MATCH_TEMPLATING, State.TEXT, TokenType.TEMPLATING],
        [MATCH_TAG_OPEN, State.TAG, TokenType.TAG_OPEN],
        [MATCH_TEXT, State.TEXT, TokenType.TEXT],
        [MATCH_TAG_LOOKAHEAD, State.TEXT, TokenType.TEXT]
      ],
      'expected text or "<"'
    );
  }
  *tokenizeCDATA(context) {
    yield* this.match(context, [[MATCH_CDATA_END, State.TEXT, false]], "expected ]]>");
  }
  *tokenizeScript(context) {
    yield* this.match(
      context,
      [
        [MATCH_SCRIPT_END, State.TAG, TokenType.TAG_OPEN],
        [MATCH_SCRIPT_DATA, State.SCRIPT, TokenType.SCRIPT]
      ],
      "expected </script>"
    );
  }
  *tokenizeStyle(context) {
    yield* this.match(
      context,
      [
        [MATCH_STYLE_END, State.TAG, TokenType.TAG_OPEN],
        [MATCH_STYLE_DATA, State.STYLE, TokenType.STYLE]
      ],
      "expected </style>"
    );
  }
}

const whitespace = /(\s+)/;
class AttrDelimiter extends Rule {
  documentation() {
    return {
      description: `Attribute value must not be separated by whitespace.`,
      url: "https://html-validate.org/rules/attr-delimiter.html"
    };
  }
  setup() {
    this.on("token", (event) => {
      const { token } = event;
      if (token.type !== TokenType.ATTR_VALUE) {
        return;
      }
      const delimiter = token.data[1];
      const match = whitespace.exec(delimiter);
      if (match) {
        const location = sliceLocation(event.location, 0, delimiter.length);
        this.report(null, "Attribute value must not be delimited by whitespace", location);
      }
    });
  }
}

const DEFAULT_PATTERN = "[a-z0-9-:]+";
const defaults$t = {
  pattern: DEFAULT_PATTERN,
  ignoreForeign: true
};
function generateRegexp(pattern) {
  if (Array.isArray(pattern)) {
    return new RegExp(`^(${pattern.join("|")})$`, "i");
  } else {
    return new RegExp(`^${pattern}$`, "i");
  }
}
function generateMessage(name, pattern) {
  if (Array.isArray(pattern)) {
    const patterns = pattern.map((it) => `/${it}/`).join(", ");
    return `Attribute "${name}" should match one of [${patterns}]`;
  } else {
    return `Attribute "${name}" should match /${pattern}/`;
  }
}
function generateDescription(name, pattern) {
  if (Array.isArray(pattern)) {
    return [
      `Attribute "${name}" should match one of the configured regular expressions:`,
      "",
      ...pattern.map((it) => `- \`/${it}/\``)
    ].join("\n");
  } else {
    return `Attribute "${name}" should match the regular expression \`/${pattern}/\``;
  }
}
class AttrPattern extends Rule {
  constructor(options) {
    super({ ...defaults$t, ...options });
    this.pattern = generateRegexp(this.options.pattern);
  }
  static schema() {
    return {
      pattern: {
        oneOf: [{ type: "array", items: { type: "string" }, minItems: 1 }, { type: "string" }]
      },
      ignoreForeign: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    return {
      description: generateDescription(context.attr, context.pattern),
      url: "https://html-validate.org/rules/attr-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (this.isIgnored(event.target)) {
        return;
      }
      if (event.originalAttribute) {
        return;
      }
      if (this.pattern.test(event.key)) {
        return;
      }
      const message = generateMessage(event.key, this.options.pattern);
      const context = {
        attr: event.key,
        pattern: this.options.pattern
      };
      this.report(event.target, message, event.keyLocation, context);
    });
  }
  isIgnored(node) {
    if (this.options.ignoreForeign) {
      return Boolean(node.meta && node.meta.foreign);
    } else {
      return false;
    }
  }
}

const defaults$s = {
  style: "auto",
  unquoted: false
};
function describeError(context) {
  switch (context.error) {
    case "style":
      return `Attribute \`${context.attr}\` must use \`${context.expected}\` instead of \`${context.actual}\`.`;
    case "unquoted":
      return `Attribute \`${context.attr}\` must not be unquoted.`;
  }
}
function describeStyle(style, unquoted) {
  const description = [];
  switch (style) {
    case "auto" /* AUTO_QUOTE */:
      description.push(
        "- quoted with double quotes `\"` unless the value contains double quotes in which case single quotes `'` should be used instead"
      );
      break;
    case "any" /* ANY_QUOTE */:
      description.push("- quoted with single quotes `'`");
      description.push('- quoted with double quotes `"`');
      break;
    case "'" /* SINGLE_QUOTE */:
    case '"' /* DOUBLE_QUOTE */: {
      const name = style === "'" /* SINGLE_QUOTE */ ? "single" : "double";
      description.push(`- quoted with ${name} quotes \`${style}\``);
      break;
    }
  }
  if (unquoted) {
    description.push("- unquoted (if applicable)");
  }
  return `${description.join(" or\n")}
`;
}
class AttrQuotes extends Rule {
  constructor(options) {
    super({ ...defaults$s, ...options });
    this.style = parseStyle$3(this.options.style);
  }
  static schema() {
    return {
      style: {
        enum: ["auto", "double", "single", "any"],
        type: "string"
      },
      unquoted: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    const { style } = this;
    const { unquoted } = this.options;
    const description = [
      describeError(context),
      "",
      "Under the current configuration attributes must be:",
      "",
      describeStyle(style, unquoted)
    ];
    return {
      description: description.join("\n"),
      url: "https://html-validate.org/rules/attr-quotes.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (event.value === null) {
        return;
      }
      if (!event.quote) {
        if (!this.options.unquoted) {
          const message = `Attribute "${event.key}" using unquoted value`;
          const context = {
            error: "unquoted",
            attr: event.key
          };
          this.report(event.target, message, null, context);
        }
        return;
      }
      if (this.style === "any" /* ANY_QUOTE */) {
        return;
      }
      const expected = this.resolveQuotemark(event.value.toString(), this.style);
      if (event.quote !== expected) {
        const message = `Attribute "${event.key}" used ${event.quote} instead of expected ${expected}`;
        const context = {
          error: "style",
          attr: event.key,
          actual: event.quote,
          expected
        };
        this.report(event.target, message, null, context);
      }
    });
  }
  resolveQuotemark(value, style) {
    if (style === "auto" /* AUTO_QUOTE */) {
      return value.includes('"') ? "'" : '"';
    } else {
      return style;
    }
  }
}
function parseStyle$3(style) {
  switch (style.toLowerCase()) {
    case "auto":
      return "auto" /* AUTO_QUOTE */;
    case "double":
      return '"' /* DOUBLE_QUOTE */;
    case "single":
      return "'" /* SINGLE_QUOTE */;
    case "any":
      return "any" /* ANY_QUOTE */;
    default:
      throw new ConfigError(`Invalid style "${style}" for "attr-quotes" rule`);
  }
}

class AttrSpacing extends Rule {
  documentation() {
    return {
      description: `No space between attributes. At least one whitespace character (commonly space) must be used to separate attributes.`,
      url: "https://html-validate.org/rules/attr-spacing.html"
    };
  }
  setup() {
    let previousToken;
    this.on("token", (event) => {
      if (event.type === TokenType.ATTR_NAME && previousToken !== TokenType.WHITESPACE) {
        this.report(null, "No space between attributes", event.location);
      }
      previousToken = event.type;
    });
  }
}

function pick(attr) {
  const result = {};
  if (typeof attr.enum !== "undefined") {
    result.enum = attr.enum;
  }
  if (typeof attr.boolean !== "undefined") {
    result.boolean = attr.boolean;
  }
  return result;
}
class AttributeAllowedValues extends Rule {
  documentation(context) {
    const docs = {
      description: "Attribute has invalid value.",
      url: "https://html-validate.org/rules/attribute-allowed-values.html"
    };
    if (!context) {
      return docs;
    }
    const { allowed, attribute, element, value } = context;
    if (allowed.enum) {
      const allowedList = allowed.enum.map((value2) => {
        if (typeof value2 === "string") {
          return `- \`"${value2}"\``;
        } else {
          return `- \`${value2.toString()}\``;
        }
      });
      docs.description = [
        `The \`<${element}>\` element does not allow the attribute \`${attribute}\` to have the value \`"${value}"\`.`,
        "",
        "It must match one of the following:",
        "",
        ...allowedList
      ].join("\n");
    } else if (allowed.boolean) {
      docs.description = `The \`<${context.element}>\` attribute \`${context.attribute}\` must be a boolean attribute, e.g. \`<${context.element} ${context.attribute}>\``;
    }
    return docs;
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        const meta = node.meta;
        if (!(meta == null ? void 0 : meta.attributes))
          return;
        for (const attr of node.attributes) {
          if (Validator.validateAttribute(attr, meta.attributes)) {
            continue;
          }
          const value = attr.value ? attr.value.toString() : "";
          const context = {
            element: node.tagName,
            attribute: attr.key,
            value,
            allowed: pick(meta.attributes[attr.key])
          };
          const message = this.getMessage(attr);
          const location = this.getLocation(attr);
          this.report(node, message, location, context);
        }
      });
    });
  }
  getMessage(attr) {
    const { key, value } = attr;
    if (value !== null) {
      return `Attribute "${key}" has invalid value "${value.toString()}"`;
    } else {
      return `Attribute "${key}" is missing value`;
    }
  }
  getLocation(attr) {
    if (attr.value !== null) {
      return attr.valueLocation;
    } else {
      return attr.keyLocation;
    }
  }
}

const defaults$r = {
  style: "omit"
};
class AttributeBooleanStyle extends Rule {
  constructor(options) {
    super({ ...defaults$r, ...options });
    this.hasInvalidStyle = parseStyle$2(this.options.style);
  }
  static schema() {
    return {
      style: {
        enum: ["empty", "name", "omit"],
        type: "string"
      }
    };
  }
  documentation() {
    return {
      description: "Require a specific style when writing boolean attributes.",
      url: "https://html-validate.org/rules/attribute-boolean-style.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        const meta = node.meta;
        if (!(meta == null ? void 0 : meta.attributes))
          return;
        for (const attr of node.attributes) {
          if (!this.isBoolean(attr, meta.attributes))
            continue;
          if (attr.originalAttribute) {
            continue;
          }
          if (this.hasInvalidStyle(attr)) {
            this.report(node, reportMessage$1(attr, this.options.style), attr.keyLocation);
          }
        }
      });
    });
  }
  isBoolean(attr, rules) {
    const meta = rules[attr.key];
    return Boolean(meta == null ? void 0 : meta.boolean);
  }
}
function parseStyle$2(style) {
  switch (style.toLowerCase()) {
    case "omit":
      return (attr) => attr.value !== null;
    case "empty":
      return (attr) => attr.value !== "";
    case "name":
      return (attr) => attr.value !== attr.key;
    default:
      throw new Error(`Invalid style "${style}" for "attribute-boolean-style" rule`);
  }
}
function reportMessage$1(attr, style) {
  const key = attr.key;
  switch (style.toLowerCase()) {
    case "omit":
      return `Attribute "${key}" should omit value`;
    case "empty":
      return `Attribute "${key}" value should be empty string`;
    case "name":
      return `Attribute "${key}" should be set to ${key}="${key}"`;
  }
  return "";
}

const defaults$q = {
  style: "omit"
};
class AttributeEmptyStyle extends Rule {
  constructor(options) {
    super({ ...defaults$q, ...options });
    this.hasInvalidStyle = parseStyle$1(this.options.style);
  }
  static schema() {
    return {
      style: {
        enum: ["empty", "omit"],
        type: "string"
      }
    };
  }
  documentation() {
    return {
      description: "Require a specific style for attributes with empty values.",
      url: "https://html-validate.org/rules/attribute-empty-style.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        const meta = node.meta;
        if (!(meta == null ? void 0 : meta.attributes))
          return;
        for (const attr of node.attributes) {
          if (!allowsEmpty(attr, meta.attributes)) {
            continue;
          }
          if (!isEmptyValue(attr)) {
            continue;
          }
          if (!this.hasInvalidStyle(attr)) {
            continue;
          }
          this.report(node, reportMessage(attr, this.options.style), attr.keyLocation);
        }
      });
    });
  }
}
function allowsEmpty(attr, rules) {
  const meta = rules[attr.key];
  return Boolean(meta == null ? void 0 : meta.omit);
}
function isEmptyValue(attr) {
  if (attr.isDynamic) {
    return false;
  }
  return attr.value === null || attr.value === "";
}
function parseStyle$1(style) {
  switch (style.toLowerCase()) {
    case "omit":
      return (attr) => attr.value !== null;
    case "empty":
      return (attr) => attr.value !== "";
    default:
      throw new Error(`Invalid style "${style}" for "attribute-empty-style" rule`);
  }
}
function reportMessage(attr, style) {
  const key = attr.key;
  switch (style.toLowerCase()) {
    case "omit":
      return `Attribute "${key}" should omit value`;
    case "empty":
      return `Attribute "${key}" value should be empty string`;
  }
  return "";
}

function ruleDescription(context) {
  const { tagName, attr, details } = context;
  return `The \`${attr}\` attribute cannot be used on \`${tagName}\` in this context: ${details}`;
}
class AttributeMisuse extends Rule {
  documentation(context) {
    return {
      description: ruleDescription(context),
      url: "https://html-validate.org/rules/attribute-misuse.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const { target } = event;
      const { meta } = target;
      if (!meta) {
        return;
      }
      for (const attr of target.attributes) {
        const key = attr.key.toLowerCase();
        this.validateAttr(target, attr, meta.attributes[key]);
      }
    });
  }
  validateAttr(node, attr, meta) {
    if (!(meta == null ? void 0 : meta.allowed)) {
      return;
    }
    const details = meta.allowed(node._adapter, attr.value);
    if (details) {
      this.report({
        node,
        message: `"{{ attr }}" attribute cannot be used on {{ tagName }} in this context: {{ details }}`,
        location: attr.keyLocation,
        context: {
          tagName: node.annotatedName,
          attr: attr.key,
          details
        }
      });
    }
  }
}

function parsePattern(pattern) {
  switch (pattern) {
    case "kebabcase":
      return { regexp: /^[a-z][a-z0-9]*(?:-[a-z0-9]+)*$/, description: pattern };
    case "camelcase":
      return { regexp: /^[a-z][a-zA-Z0-9]*$/, description: pattern };
    case "snakecase":
    case "underscore":
      return { regexp: /^[a-z][a-z0-9]*(?:_[a-z0-9]+)*$/, description: pattern };
    case "bem": {
      const block = "[a-z][a-z0-9]*(?:-[a-z0-9]+)*";
      const element = "(?:__[a-z0-9]+(?:-[a-z0-9]+)*)?";
      const modifier = "(?:--[a-z0-9]+(?:-[a-z0-9]+)*){0,2}";
      return {
        regexp: new RegExp(`^${block}${element}${modifier}$`),
        description: pattern
      };
    }
    default: {
      const regexp = new RegExp(pattern);
      return { regexp, description: regexp.toString() };
    }
  }
}

function toArray$1(value) {
  return Array.isArray(value) ? value : [value];
}
class BasePatternRule extends Rule {
  /**
   * @param attr - Attribute holding the value.
   * @param options - Rule options with defaults expanded.
   */
  constructor(attr, options) {
    super(options);
    const { pattern } = this.options;
    this.attr = attr;
    this.patterns = toArray$1(pattern).map((it) => parsePattern(it));
  }
  static schema() {
    return {
      pattern: {
        oneOf: [{ type: "array", items: { type: "string" }, minItems: 1 }, { type: "string" }]
      }
    };
  }
  description(context) {
    const { attr, patterns } = this;
    const { value } = context;
    const lead = patterns.length === 1 ? `The \`${attr}\` attribute value \`"${value}"\` does not match the configured pattern.` : `The \`${attr}\` attribute value \`"${value}"\` does not match either of the configured patterns.`;
    return [
      lead,
      "For consistency within the codebase the `${attr}` is required to match one or more of the following patterns:",
      "",
      ...patterns.map((it) => `- \`${it.description}\``)
    ].join("\n");
  }
  validateValue(node, value, location) {
    const { attr, patterns } = this;
    const matches = patterns.some((it) => it.regexp.test(value));
    if (matches) {
      return;
    }
    const allowed = utils_naturalJoin.naturalJoin(patterns.map((it) => `"${it.description}"`));
    const message = patterns.length === 1 ? `${attr} "${value}" does not match the configured pattern ${allowed}` : `${attr} "${value}" does not match either of the configured patterns: ${allowed}`;
    this.report({
      node,
      message,
      location,
      context: {
        value
      }
    });
  }
}

const defaults$p = {
  pattern: "kebabcase"
};
class ClassPattern extends BasePatternRule {
  constructor(options) {
    super("class", { ...defaults$p, ...options });
  }
  static schema() {
    return BasePatternRule.schema();
  }
  documentation(context) {
    return {
      description: this.description(context),
      url: "https://html-validate.org/rules/class-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const { target, key, value, valueLocation } = event;
      if (key.toLowerCase() !== "class") {
        return;
      }
      const classes = new DOMTokenList(value, valueLocation);
      for (const { item, location } of classes.iterator()) {
        this.validateValue(target, item, location);
      }
    });
  }
}

class CloseAttr extends Rule {
  documentation() {
    return {
      description: "HTML disallows end tags to have attributes.",
      url: "https://html-validate.org/rules/close-attr.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      if (!event.target) {
        return;
      }
      if (event.previous === event.target) {
        return;
      }
      const node = event.target;
      if (Object.keys(node.attributes).length > 0) {
        const first = node.attributes[0];
        this.report(null, "Close tags cannot have attributes", first.keyLocation);
      }
    });
  }
}

class CloseOrder extends Rule {
  documentation() {
    return {
      description: "HTML requires elements to be closed in the same order as they were opened.",
      url: "https://html-validate.org/rules/close-order.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const current = event.target;
      const active = event.previous;
      if (!current) {
        this.report(
          null,
          `Missing close-tag, expected '</${active.tagName}>' but document ended before it was found.`,
          event.location
        );
        return;
      }
      if (current.voidElement) {
        return;
      }
      if (active.closed === NodeClosed.ImplicitClosed) {
        return;
      }
      if (active.isRootElement()) {
        const location = {
          filename: current.location.filename,
          line: current.location.line,
          column: current.location.column,
          offset: current.location.offset,
          size: current.tagName.length + 1
        };
        this.report(null, "Unexpected close-tag, expected opening tag.", location);
        return;
      }
      if (current.tagName !== active.tagName) {
        this.report(
          null,
          `Mismatched close-tag, expected '</${active.tagName}>' but found '</${current.tagName}>'.`,
          current.location
        );
      }
    });
  }
}

const defaults$o = {
  include: null,
  exclude: null
};
class Deprecated extends Rule {
  constructor(options) {
    super({ ...defaults$o, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation(context) {
    const text = [];
    if (context.source) {
      const source = prettySource(context.source);
      const message = `The \`<$tagname>\` element is deprecated ${source} and should not be used in new code.`;
      text.push(message);
    } else {
      const message = `The \`<$tagname>\` element is deprecated and should not be used in new code.`;
      text.push(message);
    }
    if (context.documentation) {
      text.push(context.documentation);
    }
    const doc = {
      description: text.map((cur) => cur.replace(/\$tagname/g, context.tagName)).join("\n\n"),
      url: "https://html-validate.org/rules/deprecated.html"
    };
    return doc;
  }
  setup() {
    this.on("tag:start", (event) => {
      const node = event.target;
      if (node.meta === null) {
        return;
      }
      const deprecated = node.meta.deprecated;
      if (!deprecated) {
        return;
      }
      if (this.isKeywordIgnored(node.tagName)) {
        return;
      }
      const location = sliceLocation(event.location, 1);
      if (typeof deprecated === "string") {
        this.reportString(deprecated, node, location);
      } else if (typeof deprecated === "boolean") {
        this.reportBoolean(node, location);
      } else {
        this.reportObject(deprecated, node, location);
      }
    });
  }
  reportString(deprecated, node, location) {
    const context = { tagName: node.tagName };
    const message = `<${node.tagName}> is deprecated: ${deprecated}`;
    this.report(node, message, location, context);
  }
  reportBoolean(node, location) {
    const context = { tagName: node.tagName };
    const message = `<${node.tagName}> is deprecated`;
    this.report(node, message, location, context);
  }
  reportObject(deprecated, node, location) {
    const context = { ...deprecated, tagName: node.tagName };
    const notice = deprecated.message ? `: ${deprecated.message}` : "";
    const message = `<${node.tagName}> is deprecated${notice}`;
    this.report(node, message, location, context);
  }
}
function prettySource(source) {
  const match = source.match(/html(\d)(\d)?/);
  if (match) {
    const [, ...parts] = match;
    const version = parts.filter(Boolean).join(".");
    return `in HTML ${version}`;
  }
  switch (source) {
    case "whatwg":
      return "in HTML Living Standard";
    case "non-standard":
      return "and non-standard";
    default:
      return `by ${source}`;
  }
}

class DeprecatedRule extends Rule {
  documentation(context) {
    const preamble = context ? `The rule "${context}"` : "This rule";
    return {
      description: `${preamble} is deprecated and should not be used any longer, consult documentation for further information.`,
      url: "https://html-validate.org/rules/deprecated-rule.html"
    };
  }
  setup() {
    this.on("config:ready", (event) => {
      for (const rule of this.getDeprecatedRules(event)) {
        if (rule.getSeverity() > Severity.DISABLED) {
          this.report(null, `Usage of deprecated rule "${rule.name}"`, null, rule.name);
        }
      }
    });
  }
  getDeprecatedRules(event) {
    const rules = Object.values(event.rules);
    return rules.filter((rule) => rule.deprecated);
  }
}

let NoStyleTag$1 = class NoStyleTag extends Rule {
  documentation() {
    return {
      description: [
        'HTML5 documents should use the "html" doctype (short `form`, not legacy string):',
        "",
        "```html",
        "<!DOCTYPE html>",
        "```"
      ].join("\n"),
      url: "https://html-validate.org/rules/doctype-html.html"
    };
  }
  setup() {
    this.on("doctype", (event) => {
      const doctype = event.value.toLowerCase();
      if (doctype !== "html") {
        this.report(null, 'doctype should be "html"', event.valueLocation);
      }
    });
  }
};

const defaults$n = {
  style: "uppercase"
};
class DoctypeStyle extends Rule {
  constructor(options) {
    super({ ...defaults$n, ...options });
  }
  static schema() {
    return {
      style: {
        enum: ["lowercase", "uppercase"],
        type: "string"
      }
    };
  }
  documentation(context) {
    return {
      description: `While DOCTYPE is case-insensitive in the standard the current configuration requires it to be ${context.style}`,
      url: "https://html-validate.org/rules/doctype-style.html"
    };
  }
  setup() {
    this.on("doctype", (event) => {
      if (this.options.style === "uppercase" && event.tag !== "DOCTYPE") {
        this.report(null, "DOCTYPE should be uppercase", event.location, this.options);
      }
      if (this.options.style === "lowercase" && event.tag !== "doctype") {
        this.report(null, "DOCTYPE should be lowercase", event.location, this.options);
      }
    });
  }
}

const defaults$m = {
  style: "lowercase"
};
class ElementCase extends Rule {
  constructor(options) {
    super({ ...defaults$m, ...options });
    this.style = new CaseStyle(this.options.style, "element-case");
  }
  static schema() {
    const styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
    return {
      style: {
        anyOf: [
          {
            enum: styleEnum,
            type: "string"
          },
          {
            items: {
              enum: styleEnum,
              type: "string"
            },
            type: "array"
          }
        ]
      }
    };
  }
  documentation() {
    const { style } = this.options;
    return {
      description: Array.isArray(style) ? [`Element tagname must be in one of:`, "", ...style.map((it) => `- ${it}`)].join("\n") : `Element tagname must be in ${style}.`,
      url: "https://html-validate.org/rules/element-case.html"
    };
  }
  setup() {
    this.on("tag:start", (event) => {
      const { target, location } = event;
      this.validateCase(target, location);
    });
    this.on("tag:end", (event) => {
      const { target, previous } = event;
      this.validateMatchingCase(previous, target);
    });
  }
  validateCase(target, targetLocation) {
    const letters = target.tagName.replace(/[^a-z]+/gi, "");
    if (!this.style.match(letters)) {
      const location = sliceLocation(targetLocation, 1);
      this.report(target, `Element "${target.tagName}" should be ${this.style.name}`, location);
    }
  }
  validateMatchingCase(start, end) {
    if (!start || !end || !start.tagName || !end.tagName) {
      return;
    }
    if (start.tagName.toLowerCase() !== end.tagName.toLowerCase()) {
      return;
    }
    if (start.tagName !== end.tagName) {
      this.report(start, "Start and end tag must not differ in casing", end.location);
    }
  }
}

const defaults$l = {
  pattern: "^[a-z][a-z0-9\\-._]*-[a-z0-9\\-._]*$",
  whitelist: [],
  blacklist: []
};
class ElementName extends Rule {
  constructor(options) {
    super({ ...defaults$l, ...options });
    this.pattern = new RegExp(this.options.pattern);
  }
  static schema() {
    return {
      blacklist: {
        items: {
          type: "string"
        },
        type: "array"
      },
      pattern: {
        type: "string"
      },
      whitelist: {
        items: {
          type: "string"
        },
        type: "array"
      }
    };
  }
  documentation(context) {
    return {
      description: this.documentationMessages(context).join("\n"),
      url: "https://html-validate.org/rules/element-name.html"
    };
  }
  documentationMessages(context) {
    if (context.blacklist.includes(context.tagName)) {
      return [
        `<${context.tagName}> is blacklisted by the project configuration.`,
        "",
        "The following names are blacklisted:",
        ...context.blacklist.map((cur) => `- ${cur}`)
      ];
    }
    if (context.pattern !== defaults$l.pattern) {
      return [
        `<${context.tagName}> is not a valid element name. This project is configured to only allow names matching the following regular expression:`,
        "",
        `- \`${context.pattern}\``
      ];
    }
    return [
      `<${context.tagName}> is not a valid element name. If this is a custom element HTML requires the name to follow these rules:`,
      "",
      "- The name must begin with `a-z`",
      "- The name must include a hyphen `-`",
      "- It may include alphanumerical characters `a-z0-9` or hyphens `-`, dots `.` or underscores `_`."
    ];
  }
  setup() {
    const xmlns = /^(.+):.+$/;
    this.on("tag:start", (event) => {
      const target = event.target;
      const tagName = target.tagName;
      const location = sliceLocation(event.location, 1);
      const context = {
        tagName,
        pattern: this.options.pattern,
        blacklist: this.options.blacklist
      };
      if (this.options.blacklist.includes(tagName)) {
        this.report(target, `<${tagName}> element is blacklisted`, location, context);
      }
      if (target.meta) {
        return;
      }
      if (tagName.match(xmlns)) {
        return;
      }
      if (this.options.whitelist.includes(tagName)) {
        return;
      }
      if (!tagName.match(this.pattern)) {
        this.report(target, `<${tagName}> is not a valid element name`, location, context);
      }
    });
  }
}

function getTransparentChildren(node, transparent) {
  if (typeof transparent === "boolean") {
    return node.childElements;
  } else {
    return node.childElements.filter((it) => {
      return transparent.some((category) => {
        return Validator.validatePermittedCategory(it, category, false);
      });
    });
  }
}
function getRuleDescription$2(context) {
  switch (context.kind) {
    case "content" /* CONTENT */:
      return [
        `The \`${context.child}\` element is not permitted as content under the parent \`${context.parent}\` element.`
      ];
    case "descendant" /* DESCENDANT */:
      return [
        `The \`${context.child}\` element is not permitted as a descendant of the \`${context.ancestor}\` element.`
      ];
  }
}
class ElementPermittedContent extends Rule {
  documentation(context) {
    return {
      description: getRuleDescription$2(context).join("\n"),
      url: "https://html-validate.org/rules/element-permitted-content.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        const parent = node.parent;
        if (!parent) {
          return;
        }
        [
          () => this.validatePermittedContent(node, parent),
          () => this.validatePermittedDescendant(node, parent)
        ].some((fn) => fn());
      });
    });
  }
  validatePermittedContent(cur, parent) {
    if (!parent.meta) {
      return false;
    }
    const rules = parent.meta.permittedContent ?? null;
    return this.validatePermittedContentImpl(cur, parent, rules);
  }
  validatePermittedContentImpl(cur, parent, rules) {
    if (!Validator.validatePermitted(cur, rules)) {
      const child = `<${cur.tagName}>`;
      const message = `${child} element is not permitted as content under ${parent.annotatedName}`;
      const context = {
        kind: "content" /* CONTENT */,
        parent: parent.annotatedName,
        child
      };
      this.report(cur, message, null, context);
      return true;
    }
    if (cur.meta && cur.meta.transparent) {
      const children = getTransparentChildren(cur, cur.meta.transparent);
      return children.map((child) => {
        return this.validatePermittedContentImpl(child, parent, rules);
      }).some(Boolean);
    }
    return false;
  }
  validatePermittedDescendant(node, parent) {
    for (let cur = parent; cur && !cur.isRootElement(); cur = /* istanbul ignore next */
    (cur == null ? void 0 : cur.parent) ?? null) {
      const meta = cur.meta;
      if (!meta) {
        continue;
      }
      const rules = meta.permittedDescendants;
      if (!rules) {
        continue;
      }
      if (Validator.validatePermitted(node, rules)) {
        continue;
      }
      const child = `<${node.tagName}>`;
      const ancestor = cur.annotatedName;
      const message = `${child} element is not permitted as a descendant of ${ancestor}`;
      const context = {
        kind: "descendant" /* DESCENDANT */,
        ancestor,
        child
      };
      this.report(node, message, null, context);
      return true;
    }
    return false;
  }
}

class ElementPermittedOccurrences extends Rule {
  documentation() {
    return {
      description: "Some elements may only be used a fixed amount of times in given context.",
      url: "https://html-validate.org/rules/element-permitted-occurrences.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        if (!node.meta) {
          return;
        }
        const rules = node.meta.permittedContent;
        if (!rules) {
          return;
        }
        Validator.validateOccurrences(
          node.childElements,
          rules,
          (child, category) => {
            this.report(
              child,
              `Element <${category}> can only appear once under ${node.annotatedName}`
            );
          }
        );
      });
    });
  }
}

class ElementPermittedOrder extends Rule {
  documentation() {
    return {
      description: "Some elements has a specific order the children must use.",
      url: "https://html-validate.org/rules/element-permitted-order.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        if (!node.meta) {
          return;
        }
        const rules = node.meta.permittedOrder;
        if (!rules) {
          return;
        }
        Validator.validateOrder(
          node.childElements,
          rules,
          (child, prev) => {
            this.report(
              child,
              `Element <${child.tagName}> must be used before <${prev.tagName}> in this context`
            );
          }
        );
      });
    });
  }
}

function isCategoryOrTag(value) {
  return typeof value === "string";
}
function isCategory$1(value) {
  return value.startsWith("@");
}
function formatCategoryOrTag(value) {
  return isCategory$1(value) ? value.slice(1) : `<${value}>`;
}
function isFormattable(rules) {
  return rules.length > 0 && rules.every(isCategoryOrTag);
}
function getRuleDescription$1(context) {
  const { child, parent, rules } = context;
  const preamble = `The \`${child}\` element cannot have a \`${parent}\` element as parent.`;
  if (isFormattable(rules)) {
    const allowed = rules.filter(isCategoryOrTag).map((it) => {
      if (isCategory$1(it)) {
        return `- any ${it.slice(1)} element`;
      } else {
        return `- \`<${it}>\``;
      }
    });
    return [preamble, "", "Allowed parents one of:", "", ...allowed];
  } else {
    return [preamble];
  }
}
function formatMessage$1(node, parent, rules) {
  const nodeName = node.annotatedName;
  const parentName = parent.annotatedName;
  if (!isFormattable(rules)) {
    return `${nodeName} element cannot have ${parentName} element as parent`;
  }
  const allowed = utils_naturalJoin.naturalJoin(rules.filter(isCategoryOrTag).map(formatCategoryOrTag));
  return `${nodeName} element requires a ${allowed} element as parent`;
}
class ElementPermittedParent extends Rule {
  documentation(context) {
    return {
      description: getRuleDescription$1(context).join("\n"),
      url: "https://html-validate.org/rules/element-permitted-parent.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        var _a;
        const parent = node.parent;
        if (!parent) {
          return;
        }
        if (parent.isRootElement()) {
          return;
        }
        if (parent.tagName === node.tagName) {
          return;
        }
        const rules = (_a = node.meta) == null ? void 0 : _a.permittedParent;
        if (!rules) {
          return false;
        }
        if (Validator.validatePermitted(parent, rules)) {
          return;
        }
        const message = formatMessage$1(node, parent, rules);
        const context = {
          parent: parent.annotatedName,
          child: node.annotatedName,
          rules
        };
        this.report(node, message, null, context);
      });
    });
  }
}

function isTagnameOnly(value) {
  return Boolean(value.match(/^[a-zA-Z0-9-]+$/));
}
function getRuleDescription(context) {
  const escaped = context.ancestor.map((it) => `\`${it}\``);
  return [`The \`${context.child}\` element requires a ${utils_naturalJoin.naturalJoin(escaped)} ancestor.`];
}
class ElementRequiredAncestor extends Rule {
  documentation(context) {
    return {
      description: getRuleDescription(context).join("\n"),
      url: "https://html-validate.org/rules/element-required-ancestor.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        const parent = node.parent;
        if (!parent) {
          return;
        }
        this.validateRequiredAncestors(node);
      });
    });
  }
  validateRequiredAncestors(node) {
    if (!node.meta) {
      return;
    }
    const rules = node.meta.requiredAncestors;
    if (!rules) {
      return;
    }
    if (Validator.validateAncestors(node, rules)) {
      return;
    }
    const ancestor = rules.map((it) => isTagnameOnly(it) ? `<${it}>` : `"${it}"`);
    const child = `<${node.tagName}>`;
    const message = `<${node.tagName}> element requires a ${utils_naturalJoin.naturalJoin(ancestor)} ancestor`;
    const context = {
      ancestor,
      child
    };
    this.report(node, message, null, context);
  }
}

class ElementRequiredAttributes extends Rule {
  documentation(context) {
    const docs = {
      description: "Element is missing a required attribute",
      url: "https://html-validate.org/rules/element-required-attributes.html"
    };
    if (context) {
      docs.description = `The <${context.element}> element is required to have a "${context.attribute}" attribute.`;
    }
    return docs;
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      const meta = node.meta;
      if (!(meta == null ? void 0 : meta.attributes)) {
        return;
      }
      for (const [key, attr] of Object.entries(meta.attributes)) {
        if (!attr.required) {
          continue;
        }
        if (node.hasAttribute(key))
          continue;
        const context = {
          element: node.tagName,
          attribute: key
        };
        this.report(
          node,
          `${node.annotatedName} is missing required "${key}" attribute`,
          node.location,
          context
        );
      }
    });
  }
}

function isCategory(value) {
  return value.startsWith("@");
}
class ElementRequiredContent extends Rule {
  documentation(context) {
    const { element, missing } = context;
    return {
      description: `The \`${element}\` element requires a \`${missing}\` to be present as content.`,
      url: "https://html-validate.org/rules/element-required-content.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      doc.visitDepthFirst((node) => {
        if (!node.meta) {
          return;
        }
        const rules = node.meta.requiredContent;
        if (!rules) {
          return;
        }
        for (const missing of Validator.validateRequiredContent(node, rules)) {
          const context = {
            element: node.annotatedName,
            missing: `<${missing}>`
          };
          const tag = isCategory(missing) ? `${missing.slice(1)} element` : `<${missing}>`;
          const message = `${node.annotatedName} element must have ${tag} as content`;
          this.report(node, message, null, context);
        }
      });
    });
  }
}

const selector = ["h1", "h2", "h3", "h4", "h5", "h6"].join(",");
function hasImgAltText$1(node) {
  if (node.is("img")) {
    return hasAltText(node);
  } else if (node.is("svg")) {
    return node.textContent.trim() !== "";
  }
  return false;
}
class EmptyHeading extends Rule {
  documentation() {
    return {
      description: `Assistive technology such as screen readers require textual content in headings. Whitespace only is considered empty.`,
      url: "https://html-validate.org/rules/empty-heading.html"
    };
  }
  setup() {
    this.on("dom:ready", ({ document }) => {
      const headings = document.querySelectorAll(selector);
      for (const heading of headings) {
        this.validateHeading(heading);
      }
    });
  }
  validateHeading(heading) {
    const images = heading.querySelectorAll("img, svg");
    for (const child of images) {
      if (hasImgAltText$1(child)) {
        return;
      }
    }
    switch (classifyNodeText(heading, { ignoreHiddenRoot: true })) {
      case TextClassification.DYNAMIC_TEXT:
      case TextClassification.STATIC_TEXT:
        break;
      case TextClassification.EMPTY_TEXT:
        this.report(heading, `<${heading.tagName}> cannot be empty, must have text content`);
        break;
    }
  }
}

class EmptyTitle extends Rule {
  documentation() {
    return {
      description: [
        "The `<title>` element cannot be empty, it must have textual content.",
        "",
        "It is used to describe the document and is shown in the browser tab and titlebar.",
        "WCAG and SEO requires a descriptive title and preferably unique within the site.",
        "",
        "Whitespace is ignored."
      ].join("\n"),
      url: "https://html-validate.org/rules/empty-title.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "title")
        return;
      switch (classifyNodeText(node)) {
        case TextClassification.DYNAMIC_TEXT:
        case TextClassification.STATIC_TEXT:
          break;
        case TextClassification.EMPTY_TEXT:
          {
            const message = `<${node.tagName}> cannot be empty, must have text content`;
            this.report(node, message, node.location);
          }
          break;
      }
    });
  }
}

const defaults$k = {
  allowArrayBrackets: true,
  shared: ["radio", "button", "reset", "submit"]
};
const UNIQUE_CACHE_KEY = Symbol("form-elements-unique");
const SHARED_CACHE_KEY = Symbol("form-elements-shared");
function haveName(name) {
  return typeof name === "string" && name !== "";
}
function allowSharedName(node, shared) {
  const type = node.getAttribute("type");
  return Boolean(type && type.valueMatches(shared, false));
}
function getDocumentation(context) {
  const trailer = "Each form control must have a unique name.";
  const { name } = context;
  switch (context.kind) {
    case "duplicate":
      return [`Duplicate form control name "${name}"`, trailer].join("\n");
    case "mix":
      return [
        `Form control name cannot mix regular name "{{ name }}" with array brackets "{{ name }}[]"`,
        trailer
      ].join("\n");
  }
}
class FormDupName extends Rule {
  constructor(options) {
    super({ ...defaults$k, ...options });
  }
  static schema() {
    return {
      allowArrayBrackets: {
        type: "boolean"
      },
      shared: {
        type: "array",
        items: {
          enum: ["radio", "checkbox", "submit", "button", "reset"]
        }
      }
    };
  }
  documentation(context) {
    return {
      description: getDocumentation(context),
      url: "https://html-validate.org/rules/form-dup-name.html"
    };
  }
  setup() {
    const selector = this.getSelector();
    const { shared } = this.options;
    this.on("dom:ready", (event) => {
      const { document } = event;
      const controls = document.querySelectorAll(selector);
      const [sharedControls, uniqueControls] = partition(controls, (it) => {
        return allowSharedName(it, shared);
      });
      for (const control of uniqueControls) {
        const attr = control.getAttribute("name");
        const name = attr == null ? void 0 : attr.value;
        if (!attr || !haveName(name)) {
          continue;
        }
        const form = control.closest("form") ?? document.root;
        this.validateUniqueName(control, form, attr, name);
      }
      for (const control of sharedControls) {
        const attr = control.getAttribute("name");
        const name = attr == null ? void 0 : attr.value;
        if (!attr || !haveName(name)) {
          continue;
        }
        const form = control.closest("form") ?? document.root;
        this.validateSharedName(control, form, attr, name);
      }
    });
  }
  validateUniqueName(control, form, attr, name) {
    const elements = this.getUniqueElements(form);
    const { allowArrayBrackets } = this.options;
    if (allowArrayBrackets) {
      const isarray = name.endsWith("[]");
      const basename = isarray ? name.slice(0, -2) : name;
      const details = elements.get(basename);
      if (details && details.array !== isarray) {
        const context = {
          name: basename,
          kind: "mix"
        };
        this.report({
          node: control,
          location: attr.valueLocation,
          message: 'Cannot mix "{{ name }}[]" and "{{ name }}"',
          context
        });
        return;
      }
      if (!details && isarray) {
        elements.set(basename, {
          array: true
        });
      }
      if (isarray) {
        return;
      }
    }
    if (elements.has(name)) {
      const context = {
        name,
        kind: "duplicate"
      };
      this.report({
        node: control,
        location: attr.valueLocation,
        message: 'Duplicate form control name "{{ name }}"',
        context
      });
    } else {
      elements.set(name, {
        array: false
      });
    }
  }
  validateSharedName(control, form, attr, name) {
    const uniqueElements = this.getUniqueElements(form);
    const sharedElements = this.getSharedElements(form);
    const type = control.getAttributeValue("type") ?? "";
    if (uniqueElements.has(name) || sharedElements.has(name) && sharedElements.get(name) !== type) {
      const context = {
        name,
        kind: "duplicate"
      };
      this.report({
        node: control,
        location: attr.valueLocation,
        message: 'Duplicate form control name "{{ name }}"',
        context
      });
    }
    sharedElements.set(name, type);
  }
  getSelector() {
    const tags = this.getTagsWithProperty("formAssociated").filter((it) => {
      return this.isListedElement(it);
    });
    return tags.join(", ");
  }
  isListedElement(tagName) {
    const meta = this.getMetaFor(tagName);
    if (!(meta == null ? void 0 : meta.formAssociated)) {
      return false;
    }
    return meta.formAssociated.listed;
  }
  getUniqueElements(form) {
    const existing = form.cacheGet(UNIQUE_CACHE_KEY);
    if (existing) {
      return existing;
    } else {
      const elements = /* @__PURE__ */ new Map();
      form.cacheSet(UNIQUE_CACHE_KEY, elements);
      return elements;
    }
  }
  getSharedElements(form) {
    const existing = form.cacheGet(SHARED_CACHE_KEY);
    if (existing) {
      return existing;
    } else {
      const elements = /* @__PURE__ */ new Map();
      form.cacheSet(SHARED_CACHE_KEY, elements);
      return elements;
    }
  }
}

const defaults$j = {
  allowMultipleH1: false,
  minInitialRank: "h1",
  sectioningRoots: ["dialog", '[role="dialog"]', '[role="alertdialog"]']
};
function isRelevant$6(event) {
  const node = event.target;
  return Boolean(node.meta && node.meta.heading);
}
function extractLevel(node) {
  const match = node.tagName.match(/^[hH](\d)$/);
  if (match) {
    return parseInt(match[1], 10);
  } else {
    return null;
  }
}
function parseMaxInitial(value) {
  if (value === false || value === "any") {
    return 6;
  }
  const match = value.match(/^h(\d)$/);
  if (!match) {
    return 1;
  }
  return parseInt(match[1], 10);
}
class HeadingLevel extends Rule {
  constructor(options) {
    super({ ...defaults$j, ...options });
    this.stack = [];
    this.minInitialRank = parseMaxInitial(this.options.minInitialRank);
    this.sectionRoots = this.options.sectioningRoots.map((it) => new Pattern(it));
    this.stack.push({
      node: null,
      current: 0,
      h1Count: 0
    });
  }
  static schema() {
    return {
      allowMultipleH1: {
        type: "boolean"
      },
      minInitialRank: {
        enum: ["h1", "h2", "h3", "h4", "h5", "h6", "any", false]
      },
      sectioningRoots: {
        items: {
          type: "string"
        },
        type: "array"
      }
    };
  }
  documentation() {
    const text = [];
    const modality = this.minInitialRank > 1 ? "should" : "must";
    text.push(`Headings ${modality} start at <h1> and can only increase one level at a time.`);
    text.push("The headings should form a table of contents and make sense on its own.");
    if (!this.options.allowMultipleH1) {
      text.push("");
      text.push(
        "Under the current configuration only a single <h1> can be present at a time in the document."
      );
    }
    return {
      description: text.join("\n"),
      url: "https://html-validate.org/rules/heading-level.html"
    };
  }
  setup() {
    this.on("tag:start", isRelevant$6, (event) => {
      this.onTagStart(event);
    });
    this.on("tag:ready", (event) => {
      this.onTagReady(event);
    });
    this.on("tag:close", (event) => {
      this.onTagClose(event);
    });
  }
  onTagStart(event) {
    const level = extractLevel(event.target);
    if (!level)
      return;
    const root = this.getCurrentRoot();
    if (!this.options.allowMultipleH1 && level === 1) {
      if (root.h1Count >= 1) {
        const location = sliceLocation(event.location, 1);
        this.report(event.target, `Multiple <h1> are not allowed`, location);
        return;
      }
      root.h1Count++;
    }
    if (level <= root.current) {
      root.current = level;
      return;
    }
    this.checkLevelIncrementation(root, event, level);
    root.current = level;
  }
  /**
   * Validate heading level was only incremented by one.
   */
  checkLevelIncrementation(root, event, level) {
    const expected = root.current + 1;
    if (level === expected) {
      return;
    }
    const isInitial = this.stack.length === 1 && expected === 1;
    if (isInitial && level <= this.minInitialRank) {
      return;
    }
    const location = sliceLocation(event.location, 1);
    if (root.current > 0) {
      const expectedTag = `<h${String(expected)}>`;
      const actualTag = `<h${String(level)}>`;
      const msg = `Heading level can only increase by one, expected ${expectedTag} but got ${actualTag}`;
      this.report(event.target, msg, location);
    } else {
      this.checkInitialLevel(event, location, level, expected);
    }
  }
  checkInitialLevel(event, location, level, expected) {
    const expectedTag = `<h${String(expected)}>`;
    const actualTag = `<h${String(level)}>`;
    if (this.stack.length === 1) {
      const msg = this.minInitialRank > 1 ? `Initial heading level must be <h${String(this.minInitialRank)}> or higher rank but got ${actualTag}` : `Initial heading level must be ${expectedTag} but got ${actualTag}`;
      this.report(event.target, msg, location);
    } else {
      const prevRoot = this.getPrevRoot();
      const prevRootExpected = prevRoot.current + 1;
      if (level > prevRootExpected) {
        if (expected === prevRootExpected) {
          const msg = `Initial heading level for sectioning root must be ${expectedTag} but got ${actualTag}`;
          this.report(event.target, msg, location);
        } else {
          const msg = `Initial heading level for sectioning root must be between ${expectedTag} and <h${String(prevRootExpected)}> but got ${actualTag}`;
          this.report(event.target, msg, location);
        }
      }
    }
  }
  /**
   * Check if the current element is a sectioning root and push a new root entry
   * on the stack if it is.
   */
  onTagReady(event) {
    const { target } = event;
    if (this.isSectioningRoot(target)) {
      this.stack.push({
        node: target.unique,
        current: 0,
        h1Count: 0
      });
    }
  }
  /**
   * Check if the current element being closed is the element which opened the
   * current sectioning root, in which case the entry is popped from the stack.
   */
  onTagClose(event) {
    const { previous: target } = event;
    const root = this.getCurrentRoot();
    if (target.unique !== root.node) {
      return;
    }
    this.stack.pop();
  }
  getPrevRoot() {
    return this.stack[this.stack.length - 2];
  }
  getCurrentRoot() {
    return this.stack[this.stack.length - 1];
  }
  isSectioningRoot(node) {
    const context = {
      scope: node
    };
    return this.sectionRoots.some((it) => it.match(node, context));
  }
}

const FOCUSABLE_CACHE = Symbol(isFocusable.name);
function isDisabled(element, meta) {
  var _a;
  if (!((_a = meta.formAssociated) == null ? void 0 : _a.disablable)) {
    return false;
  }
  const disabled = element.matches("[disabled]");
  if (disabled) {
    return true;
  }
  const fieldset = element.closest("fieldset[disabled]");
  if (fieldset) {
    return true;
  }
  return false;
}
function isFocusableImpl(element) {
  if (isHTMLHidden(element) || isInert(element) || isStyleHidden(element)) {
    return false;
  }
  const { tabIndex, meta } = element;
  if (tabIndex !== null) {
    return tabIndex >= 0;
  }
  if (!meta) {
    return false;
  }
  if (isDisabled(element, meta)) {
    return false;
  }
  return Boolean(meta == null ? void 0 : meta.focusable);
}
function isFocusable(element) {
  const cached = element.cacheGet(FOCUSABLE_CACHE);
  if (cached) {
    return cached;
  }
  return element.cacheSet(FOCUSABLE_CACHE, isFocusableImpl(element));
}

class HiddenFocusable extends Rule {
  documentation(context) {
    const byParent = context === "parent" ? " In this case it is being hidden by an ancestor with `aria-hidden.`" : "";
    return {
      description: [
        `\`aria-hidden\` cannot be used on focusable elements.${byParent}`,
        "",
        "When focusable elements are hidden with `aria-hidden` they are still reachable using conventional means such as a mouse or keyboard but won't be exposed to assistive technology (AT).",
        "This is often confusing for users of AT such as screenreaders.",
        "",
        "To fix this either:",
        "  - Remove `aria-hidden`.",
        "  - Remove the element from the DOM instead.",
        '  - Use `tabindex="-1"` to remove the element from tab order.',
        "  - Use `hidden`, `inert` or similar means to hide or disable the element."
      ].join("\n"),
      url: "https://html-validate.org/rules/hidden-focusable.html"
    };
  }
  setup() {
    const focusable = this.getTagsWithProperty("focusable");
    const selector = ["[tabindex]", ...focusable].join(",");
    this.on("dom:ready", (event) => {
      const { document } = event;
      for (const element of document.querySelectorAll(selector)) {
        if (isFocusable(element) && isAriaHidden(element)) {
          this.reportElement(element);
        }
      }
    });
  }
  reportElement(element) {
    const attribute = element.getAttribute("aria-hidden");
    const message = attribute ? `aria-hidden cannot be used on focusable elements` : `aria-hidden cannot be used on focusable elements (hidden by ancestor element)`;
    const location = attribute ? attribute.keyLocation : element.location;
    const context = attribute ? "self" : "parent";
    this.report({
      node: element,
      message,
      location,
      context
    });
  }
}

const defaults$i = {
  pattern: "kebabcase"
};
class IdPattern extends BasePatternRule {
  constructor(options) {
    super("id", { ...defaults$i, ...options });
  }
  static schema() {
    return BasePatternRule.schema();
  }
  documentation(context) {
    return {
      description: this.description(context),
      url: "https://html-validate.org/rules/id-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const { target, key, value, valueLocation } = event;
      if (key.toLowerCase() !== "id") {
        return;
      }
      if (value instanceof DynamicValue) {
        return;
      }
      if (value === null) {
        return;
      }
      this.validateValue(target, value, valueLocation);
    });
  }
}

const restricted = /* @__PURE__ */ new Map([
  ["accept", ["file"]],
  ["alt", ["image"]],
  ["capture", ["file"]],
  ["checked", ["checkbox", "radio"]],
  ["dirname", ["text", "search"]],
  ["height", ["image"]],
  [
    "list",
    [
      "text",
      "search",
      "url",
      "tel",
      "email",
      "date",
      "month",
      "week",
      "time",
      "datetime-local",
      "number",
      "range",
      "color"
    ]
  ],
  ["max", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
  ["maxlength", ["text", "search", "url", "tel", "email", "password"]],
  ["min", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
  ["minlength", ["text", "search", "url", "tel", "email", "password"]],
  ["multiple", ["email", "file"]],
  ["pattern", ["text", "search", "url", "tel", "email", "password"]],
  ["placeholder", ["text", "search", "url", "tel", "email", "password", "number"]],
  [
    "readonly",
    [
      "text",
      "search",
      "url",
      "tel",
      "email",
      "password",
      "date",
      "month",
      "week",
      "time",
      "datetime-local",
      "number"
    ]
  ],
  [
    "required",
    [
      "text",
      "search",
      "url",
      "tel",
      "email",
      "password",
      "date",
      "month",
      "week",
      "time",
      "datetime-local",
      "number",
      "checkbox",
      "radio",
      "file"
    ]
  ],
  ["size", ["text", "search", "url", "tel", "email", "password"]],
  ["src", ["image"]],
  ["step", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
  ["width", ["image"]]
]);
function isInput(event) {
  const { target } = event;
  return target.is("input");
}
class InputAttributes extends Rule {
  documentation(context) {
    var _a;
    const { attribute, type } = context;
    const summary = `Attribute \`${attribute}\` is not allowed on \`<input type="${type}">\`
`;
    const details = `\`${attribute}\` can only be used when \`type\` is:`;
    const list = ((_a = restricted.get(attribute)) == null ? void 0 : _a.map((it) => `- \`${it}\``)) ?? [];
    return {
      description: [summary, details, ...list].join("\n"),
      url: "https://html-validate.org/rules/input-attributes.html"
    };
  }
  setup() {
    this.on("tag:ready", isInput, (event) => {
      const { target } = event;
      const type = target.getAttribute("type");
      if (!type || type.isDynamic || !type.value) {
        return;
      }
      const typeValue = type.value.toString();
      for (const attr of target.attributes) {
        const validTypes = restricted.get(attr.key);
        if (!validTypes) {
          continue;
        }
        if (validTypes.includes(typeValue)) {
          continue;
        }
        const context = {
          attribute: attr.key,
          type: typeValue
        };
        const message = `Attribute "${attr.key}" is not allowed on <input type="${typeValue}">`;
        this.report(target, message, attr.keyLocation, context);
      }
    });
  }
}

const HAS_ACCESSIBLE_TEXT_CACHE = Symbol(hasAccessibleName.name);
function isHidden(node, context) {
  const { reference } = context;
  if (reference && reference.isSameNode(node)) {
    return false;
  } else {
    return !inAccessibilityTree(node);
  }
}
function hasImgAltText(node, context) {
  if (node.is("img")) {
    return hasAltText(node);
  } else if (node.is("svg")) {
    return node.textContent.trim() !== "";
  } else {
    for (const img of node.querySelectorAll("img, svg")) {
      const hasName = hasAccessibleNameImpl(img, context);
      if (hasName) {
        return true;
      }
    }
    return false;
  }
}
function hasLabel(node) {
  const value = node.getAttributeValue("aria-label") ?? "";
  return Boolean(value.trim());
}
function isLabelledby(node, context) {
  const { document, reference } = context;
  if (reference) {
    return false;
  }
  const ariaLabelledby = node.ariaLabelledby;
  if (ariaLabelledby instanceof DynamicValue) {
    return true;
  }
  if (ariaLabelledby === null) {
    return false;
  }
  return ariaLabelledby.some((id) => {
    const selector = generateIdSelector(id);
    return document.querySelectorAll(selector).some((child) => {
      return hasAccessibleNameImpl(child, {
        document,
        reference: child
      });
    });
  });
}
function hasAccessibleNameImpl(current, context) {
  const { reference } = context;
  if (isHidden(current, context)) {
    return false;
  }
  const ignoreHiddenRoot = Boolean(reference && reference.isSameNode(current));
  const text = classifyNodeText(current, { accessible: true, ignoreHiddenRoot });
  if (text !== TextClassification.EMPTY_TEXT) {
    return true;
  }
  if (hasImgAltText(current, context)) {
    return true;
  }
  if (hasLabel(current)) {
    return true;
  }
  if (isLabelledby(current, context)) {
    return true;
  }
  return false;
}
function hasAccessibleName(document, current) {
  if (current.cacheExists(HAS_ACCESSIBLE_TEXT_CACHE)) {
    return Boolean(current.cacheGet(HAS_ACCESSIBLE_TEXT_CACHE));
  }
  const result = hasAccessibleNameImpl(current, {
    document,
    reference: null
  });
  return current.cacheSet(HAS_ACCESSIBLE_TEXT_CACHE, result);
}

function isIgnored(node) {
  var _a;
  if (node.is("input")) {
    const type = (_a = node.getAttributeValue("type")) == null ? void 0 : _a.toLowerCase();
    const ignored = ["hidden", "submit", "reset", "button"];
    return Boolean(type && ignored.includes(type));
  }
  return false;
}
class InputMissingLabel extends Rule {
  documentation() {
    return {
      description: [
        "Each form element must have an a label or accessible name.",
        'Typically this is implemented using a `<label for="..">` element describing the purpose of the form element.',
        "",
        "This can be resolved in one of the following ways:",
        "",
        '  - Use an associated `<label for="..">` element.',
        "  - Use a nested `<label>` as parent element.",
        "  - Use `aria-label` or `aria-labelledby` attributes."
      ].join("\n"),
      url: "https://html-validate.org/rules/input-missing-label.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const root = event.document;
      for (const elem of root.querySelectorAll("input, textarea, select")) {
        this.validateInput(root, elem);
      }
    });
  }
  validateInput(root, elem) {
    if (!inAccessibilityTree(elem)) {
      return;
    }
    if (isIgnored(elem)) {
      return;
    }
    if (hasAccessibleName(root, elem)) {
      return;
    }
    let label = [];
    if ((label = findLabelById(root, elem.id)).length > 0) {
      this.validateLabel(root, elem, label);
      return;
    }
    if ((label = findLabelByParent(elem)).length > 0) {
      this.validateLabel(root, elem, label);
      return;
    }
    if (elem.hasAttribute("aria-label")) {
      this.report(elem, `<${elem.tagName}> element has aria-label but label has no text`);
    } else if (elem.hasAttribute("aria-labelledby")) {
      this.report(
        elem,
        `<${elem.tagName}> element has aria-labelledby but referenced element has no text`
      );
    } else {
      this.report(elem, `<${elem.tagName}> element does not have a <label>`);
    }
  }
  /**
   * Reports error if none of the labels are accessible.
   */
  validateLabel(root, elem, labels) {
    const visible = labels.filter(inAccessibilityTree);
    if (visible.length === 0) {
      this.report(elem, `<${elem.tagName}> element has <label> but <label> element is hidden`);
      return;
    }
    if (!labels.some((label) => hasAccessibleName(root, label))) {
      this.report(elem, `<${elem.tagName}> element has <label> but <label> has no text`);
    }
  }
}
function findLabelById(root, id) {
  if (!id)
    return [];
  return root.querySelectorAll(`label[for="${id}"]`);
}
function findLabelByParent(el) {
  let cur = el.parent;
  while (cur) {
    if (cur.is("label")) {
      return [cur];
    }
    cur = cur.parent;
  }
  return [];
}

const defaults$h = {
  maxlength: 70
};
class LongTitle extends Rule {
  constructor(options) {
    super({ ...defaults$h, ...options });
    this.maxlength = this.options.maxlength;
  }
  static schema() {
    return {
      maxlength: {
        type: "number"
      }
    };
  }
  documentation() {
    return {
      description: `Search engines truncates titles with long text, possibly down-ranking the page in the process.`,
      url: "https://html-validate.org/rules/long-title.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "title")
        return;
      const text = node.textContent;
      if (text.length > this.maxlength) {
        this.report(node, `title text cannot be longer than ${String(this.maxlength)} characters`);
      }
    });
  }
}

const defaults$g = {
  allowLongDelay: false
};
class MetaRefresh extends Rule {
  constructor(options) {
    super({ ...defaults$g, ...options });
  }
  documentation() {
    return {
      description: `Meta refresh directive must use the \`0;url=...\` format. Non-zero values for time interval is disallowed as people with assistive technology might be unable to read and understand the page content before automatically reloading. For the same reason skipping the url is disallowed as it would put the browser in an infinite loop reloading the same page over and over again.`,
      url: "https://html-validate.org/rules/meta-refresh.html"
    };
  }
  setup() {
    this.on("element:ready", ({ target }) => {
      if (!target.is("meta")) {
        return;
      }
      const httpEquiv = target.getAttributeValue("http-equiv");
      if (httpEquiv !== "refresh") {
        return;
      }
      const content = target.getAttribute("content");
      if (!(content == null ? void 0 : content.value) || content.isDynamic) {
        return;
      }
      const location = content.valueLocation;
      const value = parseContent(content.value.toString());
      if (!value) {
        this.report(target, "Malformed meta refresh directive", location);
        return;
      }
      const { delay, url } = value;
      this.validateDelay(target, location, delay, url);
    });
  }
  validateDelay(target, location, delay, url) {
    const { allowLongDelay } = this.options;
    if (allowLongDelay && delay > 72e3) {
      return;
    }
    if (!url && delay === 0) {
      this.report(target, "Don't use instant meta refresh to reload the page", location);
      return;
    }
    if (delay !== 0) {
      const message = allowLongDelay ? "Meta refresh must be instant (0 second delay) or greater than 20 hours (72000 second delay)" : "Meta refresh must be instant (0 second delay)";
      this.report(target, message, location);
    }
  }
}
function parseContent(text) {
  const match = text.match(/^(\d+)(?:\s*;\s*url=(.*))?/i);
  if (match) {
    return {
      delay: parseInt(match[1], 10),
      url: match[2]
    };
  } else {
    return null;
  }
}

function getName(attr) {
  const name = attr.value;
  if (!name || name instanceof DynamicValue) {
    return null;
  }
  return name;
}
class MapDupName extends Rule {
  documentation() {
    return {
      description: "`<map>` must have a unique name, it cannot be the same name as another `<map>` element",
      url: "https://html-validate.org/rules/map-dup-name.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const maps = document.querySelectorAll("map[name]");
      const names = /* @__PURE__ */ new Set();
      for (const map of maps) {
        const attr = map.getAttribute("name");
        if (!attr) {
          continue;
        }
        const name = getName(attr);
        if (!name) {
          continue;
        }
        if (names.has(name)) {
          this.report({
            node: map,
            message: `<map> name must be unique`,
            location: attr.keyLocation
          });
        }
        names.add(name);
      }
    });
  }
}

function isRelevant$5(event) {
  return event.target.is("map");
}
function hasStaticValue(attr) {
  return Boolean(attr && !(attr.value instanceof DynamicValue));
}
class MapIdName extends Rule {
  documentation() {
    return {
      description: "When the `id` attribute is present on a `<map>` element it must be equal to the `name` attribute.",
      url: "https://html-validate.org/rules/map-id-name.html"
    };
  }
  setup() {
    this.on("tag:ready", isRelevant$5, (event) => {
      const { target } = event;
      const id = target.getAttribute("id");
      const name = target.getAttribute("name");
      if (!hasStaticValue(id) || !hasStaticValue(name)) {
        return;
      }
      if (id.value === name.value) {
        return;
      }
      this.report({
        node: event.target,
        message: `"id" and "name" attribute must be the same on <map> elements`,
        location: id.valueLocation ?? name.valueLocation
      });
    });
  }
}

class MissingDoctype extends Rule {
  documentation() {
    return {
      description: "Requires that the document contains a doctype.",
      url: "https://html-validate.org/rules/missing-doctype.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const dom = event.document;
      if (!dom.doctype) {
        this.report(dom.root, "Document is missing doctype");
      }
    });
  }
}

class MultipleLabeledControls extends Rule {
  constructor() {
    super(...arguments);
    this.labelable = "";
  }
  documentation() {
    return {
      description: `A \`<label>\` element can only be associated with one control at a time.`,
      url: "https://html-validate.org/rules/multiple-labeled-controls.html"
    };
  }
  setup() {
    this.labelable = this.getTagsWithProperty("labelable").join(",");
    this.on("element:ready", (event) => {
      const { target } = event;
      if (target.tagName !== "label") {
        return;
      }
      const numControls = this.getNumLabledControls(target);
      if (numControls <= 1) {
        return;
      }
      this.report(target, "<label> is associated with multiple controls", target.location);
    });
  }
  getNumLabledControls(src) {
    const controls = src.querySelectorAll(this.labelable).map((node) => node.id);
    const attr = src.getAttribute("for");
    if (!attr || attr.isDynamic || !attr.value) {
      return controls.length;
    }
    const redundant = controls.includes(attr.value.toString());
    if (redundant) {
      return controls.length;
    }
    return controls.length + 1;
  }
}

const defaults$f = {
  pattern: "camelcase"
};
class NamePattern extends BasePatternRule {
  constructor(options) {
    super("name", { ...defaults$f, ...options });
  }
  static schema() {
    return BasePatternRule.schema();
  }
  documentation(context) {
    return {
      description: this.description(context),
      url: "https://html-validate.org/rules/name-pattern.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      var _a;
      const { target, key, value, valueLocation } = event;
      const { meta } = target;
      if (!((_a = meta == null ? void 0 : meta.formAssociated) == null ? void 0 : _a.listed)) {
        return;
      }
      if (key.toLowerCase() !== "name") {
        return;
      }
      if (value instanceof DynamicValue) {
        return;
      }
      if (value === null) {
        return;
      }
      const name = value.endsWith("[]") ? value.slice(0, -2) : value;
      this.validateValue(target, name, valueLocation);
    });
  }
}

const abstractRoles = [
  "command",
  "composite",
  "input",
  "landmark",
  "range",
  "roletype",
  "section",
  "sectionhead",
  "select",
  "structure",
  "widget",
  "window"
];
function isRelevant$4(event) {
  return event.key === "role";
}
class NoAbstractRole extends Rule {
  documentation(context) {
    return {
      description: [
        `Role \`"${context.role}"\` is abstract and must not be used.`,
        "",
        "WAI-ARIA defines a list of [abstract roles](https://www.w3.org/TR/wai-aria-1.2/#abstract_roles) which cannot be used by authors:",
        "",
        ...abstractRoles.map((it) => `- \`"${it}"\``),
        "",
        `Use one of the defined subclass roles for \`"${context.role}"\` instead.`
      ].join("\n"),
      url: "https://html-validate.org/rules/no-abstract-role.html"
    };
  }
  setup() {
    this.on("attr", isRelevant$4, (event) => {
      const roles = event.value;
      if (!roles || roles instanceof DynamicValue) {
        return;
      }
      const tokens = new DOMTokenList(roles, event.valueLocation);
      for (const { item: role, location } of tokens.iterator()) {
        if (!abstractRoles.includes(role)) {
          continue;
        }
        this.report({
          node: event.target,
          message: `Role "{{ role }}" is abstract and must not be used`,
          location,
          context: {
            role
          }
        });
      }
    });
  }
}

const defaults$e = {
  include: null,
  exclude: null
};
class NoAutoplay extends Rule {
  constructor(options) {
    super({ ...defaults$e, ...options });
  }
  documentation(context) {
    return {
      description: [
        `The autoplay attribute is not allowed on <${context.tagName}>.`,
        "Autoplaying content can be disruptive for users and has accessibilty concerns.",
        "Prefer to let the user control playback."
      ].join("\n"),
      url: "https://html-validate.org/rules/no-autoplay.html"
    };
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (event.key.toLowerCase() !== "autoplay") {
        return;
      }
      if (event.value && event.value instanceof DynamicValue) {
        return;
      }
      const tagName = event.target.tagName;
      if (this.isKeywordIgnored(tagName)) {
        return;
      }
      const context = { tagName };
      const location = event.location;
      this.report(
        event.target,
        `The autoplay attribute is not allowed on <${tagName}>`,
        location,
        context
      );
    });
  }
}

class NoConditionalComment extends Rule {
  documentation() {
    return {
      description: "Microsoft Internet Explorer previously supported using special HTML comments (conditional comments) for targeting specific versions of IE but since IE 10 it is deprecated and not supported in standards mode.",
      url: "https://html-validate.org/rules/no-conditional-comment.html"
    };
  }
  setup() {
    this.on("conditional", (event) => {
      this.report(event.parent, "Use of conditional comments are deprecated", event.location);
    });
  }
}

class NoDeprecatedAttr extends Rule {
  documentation() {
    return {
      description: "HTML5 deprecated many old attributes.",
      url: "https://html-validate.org/rules/no-deprecated-attr.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const node = event.target;
      const meta = node.meta;
      const attr = event.key.toLowerCase();
      if (meta === null) {
        return;
      }
      const metaAttribute = meta.attributes[attr];
      if (!metaAttribute) {
        return;
      }
      const deprecated = metaAttribute.deprecated;
      if (deprecated) {
        this.report(
          node,
          `Attribute "${event.key}" is deprecated on <${node.tagName}> element`,
          event.keyLocation
        );
      }
    });
  }
}

class NoDupAttr extends Rule {
  documentation() {
    return {
      description: "HTML disallows two or more attributes with the same (case-insensitive) name.",
      url: "https://html-validate.org/rules/no-dup-attr.html"
    };
  }
  setup() {
    let attr = {};
    this.on("tag:start", () => {
      attr = {};
    });
    this.on("attr", (event) => {
      if (event.originalAttribute) {
        return;
      }
      const name = event.key.toLowerCase();
      if (name in attr) {
        this.report(event.target, `Attribute "${name}" duplicated`, event.keyLocation);
      }
      attr[event.key] = true;
    });
  }
}

class NoDupClass extends Rule {
  documentation() {
    return {
      description: "Prevents unnecessary duplication of class names.",
      url: "https://html-validate.org/rules/no-dup-class.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      if (event.key.toLowerCase() !== "class") {
        return;
      }
      const classes = new DOMTokenList(event.value, event.valueLocation);
      const unique = /* @__PURE__ */ new Set();
      classes.forEach((cur, index) => {
        if (unique.has(cur)) {
          const location = classes.location(index);
          this.report(event.target, `Class "${cur}" duplicated`, location);
        }
        unique.add(cur);
      });
    });
  }
}

class NoDupID extends Rule {
  documentation() {
    return {
      description: "The ID of an element must be unique.",
      url: "https://html-validate.org/rules/no-dup-id.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const existing = /* @__PURE__ */ new Set();
      const elements = document.querySelectorAll("[id]");
      const relevant = elements.filter(isRelevant$3);
      for (const el of relevant) {
        const attr = el.getAttribute("id");
        if (!(attr == null ? void 0 : attr.value)) {
          continue;
        }
        const id = attr.value.toString();
        if (existing.has(id)) {
          this.report(el, `Duplicate ID "${id}"`, attr.valueLocation);
        }
        existing.add(id);
      }
    });
  }
}
function isRelevant$3(element) {
  const attr = element.getAttribute("id");
  if (!attr) {
    return false;
  }
  if (!attr.value) {
    return false;
  }
  if (attr.isDynamic) {
    return false;
  }
  return true;
}

function isRelevant$2(event) {
  return event.target.is("button");
}
class NoImplicitButtonType extends Rule {
  documentation() {
    return {
      description: [
        "`<button>` is missing recommended `type` attribute",
        "",
        "When the `type` attribute is omitted it defaults to `submit`.",
        "Submit buttons are triggered when a keyboard user presses <kbd>Enter</kbd>.",
        "",
        "As this may or may not be inteded this rule enforces that the `type` attribute be explicitly set to one of the valid types:",
        "",
        "- `button` - a generic button.",
        "- `submit` - a submit button.",
        "- `reset`- a button to reset form fields."
      ].join("\n"),
      url: "https://html-validate.org/rules/no-implicit-button-type.html"
    };
  }
  setup() {
    this.on("element:ready", isRelevant$2, (event) => {
      const { target } = event;
      const attr = target.getAttribute("type");
      if (!attr) {
        this.report({
          node: event.target,
          message: `<button> is missing recommended "type" attribute`
        });
      }
    });
  }
}

function isRelevant$1(event) {
  return event.target.is("input");
}
class NoImplicitInputType extends Rule {
  documentation() {
    return {
      description: ["`<input>` is missing recommended `type` attribute"].join("\n"),
      url: "https://html-validate.org/rules/no-implicit-input-type.html"
    };
  }
  setup() {
    this.on("element:ready", isRelevant$1, (event) => {
      const { target } = event;
      const attr = target.getAttribute("type");
      if (!attr) {
        this.report({
          node: event.target,
          message: `<input> is missing recommended "type" attribute`
        });
      }
    });
  }
}

class NoImplicitClose extends Rule {
  documentation() {
    return {
      description: `Some elements in HTML has optional end tags. When an optional tag is omitted a browser must handle it as if the end tag was present.

Omitted end tags can be ambigious for humans to read and many editors have trouble formatting the markup.`,
      url: "https://html-validate.org/rules/no-implicit-close.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const closed = event.previous;
      const by = event.target;
      if (!by) {
        return;
      }
      if (closed.closed !== NodeClosed.ImplicitClosed) {
        return;
      }
      const closedByParent = closed.parent && closed.parent.tagName === by.tagName;
      const sameTag = closed.tagName === by.tagName;
      if (closedByParent) {
        this.report(
          closed,
          `Element <${closed.tagName}> is implicitly closed by parent </${by.tagName}>`,
          closed.location
        );
      } else if (sameTag) {
        this.report(
          closed,
          `Element <${closed.tagName}> is implicitly closed by sibling`,
          closed.location
        );
      } else {
        this.report(
          closed,
          `Element <${closed.tagName}> is implicitly closed by adjacent <${by.tagName}>`,
          closed.location
        );
      }
    });
  }
}

const defaults$d = {
  include: null,
  exclude: null,
  allowedProperties: ["display"]
};
class NoInlineStyle extends Rule {
  constructor(options) {
    super({ ...defaults$d, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      allowedProperties: {
        items: {
          type: "string"
        },
        type: "array"
      }
    };
  }
  documentation() {
    const text = [
      "Inline style is not allowed.\n",
      "Inline style is a sign of unstructured CSS. Use class or ID with a separate stylesheet.\n"
    ];
    if (this.options.allowedProperties.length > 0) {
      text.push("Under the current configuration the following CSS properties are allowed:\n");
      text.push(this.options.allowedProperties.map((it) => `- \`${it}\``).join("\n"));
    }
    return {
      description: text.join("\n"),
      url: "https://html-validate.org/rules/no-inline-style.html"
    };
  }
  setup() {
    this.on(
      "attr",
      (event) => this.isRelevant(event),
      (event) => {
        const { value } = event;
        if (this.allPropertiesAllowed(value)) {
          return;
        }
        this.report(event.target, "Inline style is not allowed");
      }
    );
  }
  isRelevant(event) {
    if (event.key !== "style") {
      return false;
    }
    const { include, exclude } = this.options;
    const key = event.originalAttribute ?? event.key;
    if (include && !include.includes(key)) {
      return false;
    }
    if (exclude && exclude.includes(key)) {
      return false;
    }
    return true;
  }
  allPropertiesAllowed(value) {
    const allowProperties = this.options.allowedProperties;
    if (allowProperties.length === 0) {
      return false;
    }
    const declarations = Object.keys(parseCssDeclaration(value));
    return declarations.length > 0 && declarations.every((it) => {
      return allowProperties.includes(it);
    });
  }
}

const ARIA = [
  { property: "aria-activedescendant", isList: false },
  { property: "aria-controls", isList: true },
  { property: "aria-describedby", isList: true },
  { property: "aria-details", isList: false },
  { property: "aria-errormessage", isList: false },
  { property: "aria-flowto", isList: true },
  { property: "aria-labelledby", isList: true },
  { property: "aria-owns", isList: true }
];
function idMissing(document, id) {
  const nodes = document.querySelectorAll(`[id="${id}"]`);
  return nodes.length === 0;
}
class NoMissingReferences extends Rule {
  documentation(context) {
    return {
      description: `The element ID "${context.value}" referenced by the ${context.key} attribute must point to an existing element.`,
      url: "https://html-validate.org/rules/no-missing-references.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const document = event.document;
      for (const node of document.querySelectorAll("label[for]")) {
        const attr = node.getAttribute("for");
        this.validateReference(document, node, attr, false);
      }
      for (const node of document.querySelectorAll("input[list]")) {
        const attr = node.getAttribute("list");
        this.validateReference(document, node, attr, false);
      }
      for (const { property, isList } of ARIA) {
        for (const node of document.querySelectorAll(`[${property}]`)) {
          const attr = node.getAttribute(property);
          this.validateReference(document, node, attr, isList);
        }
      }
    });
  }
  validateReference(document, node, attr, isList) {
    if (!attr) {
      return;
    }
    const value = attr.value;
    if (value instanceof DynamicValue || value === null || value === "") {
      return;
    }
    if (isList) {
      this.validateList(document, node, attr, value);
    } else {
      this.validateSingle(document, node, attr, value);
    }
  }
  validateSingle(document, node, attr, id) {
    if (idMissing(document, id)) {
      const context = { key: attr.key, value: id };
      this.report(node, `Element references missing id "${id}"`, attr.valueLocation, context);
    }
  }
  validateList(document, node, attr, values) {
    const parsed = new DOMTokenList(values, attr.valueLocation);
    for (const entry of parsed.iterator()) {
      const id = entry.item;
      if (idMissing(document, id)) {
        const context = { key: attr.key, value: id };
        this.report(node, `Element references missing id "${id}"`, entry.location, context);
      }
    }
  }
}

class NoMultipleMain extends Rule {
  documentation() {
    return {
      description: [
        "Only a single visible `<main>` element can be present at in a document at a time.",
        "",
        "Multiple `<main>` can be present in the DOM as long the others are hidden using the HTML5 `hidden` attribute."
      ].join("\n"),
      url: "https://html-validate.org/rules/no-multiple-main.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const main = document.querySelectorAll("main").filter((cur) => !cur.hasAttribute("hidden"));
      main.shift();
      for (const elem of main) {
        this.report(elem, "Multiple <main> elements present in document");
      }
    });
  }
}

const defaults$c = {
  relaxed: false
};
const textRegexp = /([<>]|&(?![a-zA-Z0-9#]+;))/g;
const unquotedAttrRegexp = /([<>"'=`]|&(?![a-zA-Z0-9#]+;))/g;
const matchTemplate = /^(<%.*?%>|<\?.*?\?>|<\$.*?\$>)$/s;
const replacementTable = {
  '"': "&quot;",
  "&": "&amp;",
  "'": "&apos;",
  "<": "&lt;",
  "=": "&equals;",
  ">": "&gt;",
  "`": "&grave;"
};
class NoRawCharacters extends Rule {
  constructor(options) {
    super({ ...defaults$c, ...options });
    this.relaxed = this.options.relaxed;
  }
  static schema() {
    return {
      relaxed: {
        type: "boolean"
      }
    };
  }
  documentation() {
    return {
      description: `Some characters such as \`<\`, \`>\` and \`&\` hold special meaning in HTML and must be escaped using a character reference (html entity).`,
      url: "https://html-validate.org/rules/no-raw-characters.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const node = event.target;
      for (const child of node.childNodes) {
        if (child.nodeType !== NodeType.TEXT_NODE) {
          continue;
        }
        if (child.textContent.match(matchTemplate)) {
          continue;
        }
        this.findRawChars(node, child.textContent, child.location, textRegexp);
      }
    });
    this.on("attr", (event) => {
      if (!event.value) {
        return;
      }
      if (event.quote) {
        return;
      }
      this.findRawChars(
        event.target,
        event.value.toString(),
        event.valueLocation,
        // eslint-disable-line @typescript-eslint/no-non-null-assertion -- technical debt, valueLocation is always set if a value is provided
        unquotedAttrRegexp
      );
    });
  }
  /**
   * Find raw special characters and report as errors.
   *
   * @param text - The full text to find unescaped raw characters in.
   * @param location - Location of text.
   * @param regexp - Regexp pattern to match using.
   */
  findRawChars(node, text, location, regexp) {
    let match;
    do {
      match = regexp.exec(text);
      if (match) {
        const char = match[0];
        if (this.relaxed && char === "&") {
          continue;
        }
        const replacement = replacementTable[char];
        const charLocation = sliceLocation(location, match.index, match.index + 1);
        this.report(node, `Raw "${char}" must be encoded as "${replacement}"`, charLocation);
      }
    } while (match);
  }
}

const selectors$1 = ["input[aria-label]", "textarea[aria-label]", "select[aria-label]"];
class NoRedundantAriaLabel extends Rule {
  documentation() {
    return {
      description: "`aria-label` is redundant when an associated `<label>` element containing the same text exists.",
      url: "https://html-validate.org/rules/no-redundant-aria-label.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const elements = document.querySelectorAll(selectors$1.join(","));
      for (const element of elements) {
        const ariaLabel = element.getAttribute("aria-label");
        const id = element.id;
        if (!id) {
          continue;
        }
        const label = document.querySelector(`label[for="${id}"]`);
        if (!ariaLabel || !label || label.textContent.trim() !== ariaLabel.value) {
          continue;
        }
        const message = "aria-label is redundant when label containing same text exists";
        this.report({
          message,
          node: element,
          location: ariaLabel.keyLocation
        });
      }
    });
  }
}

class NoRedundantFor extends Rule {
  documentation() {
    return {
      description: `When the \`<label>\` element wraps the labelable control the \`for\` attribute is redundant and better left out.`,
      url: "https://html-validate.org/rules/no-redundant-for.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const { target } = event;
      if (target.tagName !== "label") {
        return;
      }
      const attr = target.getAttribute("for");
      if (!attr || attr.isDynamic) {
        return;
      }
      const id = attr.value;
      if (!id) {
        return;
      }
      const escaped = escapeSelectorComponent(id);
      const control = target.querySelector(`[id="${escaped}"]`);
      if (!control) {
        return;
      }
      this.report(target, 'Redundant "for" attribute', attr.keyLocation);
    });
  }
}

class NoRedundantRole extends Rule {
  documentation(context) {
    const { role, tagName } = context;
    return {
      description: `Using the \`${role}\` role is redundant as it is already implied by the \`<${tagName}>\` element.`,
      url: "https://html-validate.org/rules/no-redundant-role.html"
    };
  }
  setup() {
    this.on("tag:ready", (event) => {
      const { target } = event;
      const role = target.getAttribute("role");
      if (!(role == null ? void 0 : role.value) || role.value instanceof DynamicValue) {
        return;
      }
      const { meta } = target;
      if (!meta) {
        return;
      }
      const implicitRole = meta.aria.implicitRole(target._adapter);
      if (!implicitRole) {
        return;
      }
      if (role.value !== implicitRole) {
        return;
      }
      const context = {
        tagName: target.tagName,
        role: role.value
      };
      this.report(
        event.target,
        `Redundant role "${role.value}" on <${target.tagName}>`,
        role.valueLocation,
        context
      );
    });
  }
}

const xmlns = /^(.+):.+$/;
const defaults$b = {
  ignoreForeign: true,
  ignoreXML: true
};
class NoSelfClosing extends Rule {
  constructor(options) {
    super({ ...defaults$b, ...options });
  }
  static schema() {
    return {
      ignoreForeign: {
        type: "boolean"
      },
      ignoreXML: {
        type: "boolean"
      }
    };
  }
  documentation(tagName) {
    tagName = tagName || "element";
    return {
      description: `Self-closing elements are disallowed. Use regular end tag <${tagName}></${tagName}> instead of self-closing <${tagName}/>.`,
      url: "https://html-validate.org/rules/no-self-closing.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const active = event.previous;
      if (!isRelevant(active, this.options)) {
        return;
      }
      this.validateElement(active);
    });
  }
  validateElement(node) {
    if (node.closed !== NodeClosed.VoidSelfClosed) {
      return;
    }
    this.report(node, `<${node.tagName}> must not be self-closed`, null, node.tagName);
  }
}
function isRelevant(node, options) {
  if (node.tagName.match(xmlns)) {
    return !options.ignoreXML;
  }
  if (!node.meta) {
    return true;
  }
  if (node.meta.void) {
    return false;
  }
  if (node.meta.foreign) {
    return !options.ignoreForeign;
  }
  return true;
}

class NoStyleTag extends Rule {
  documentation() {
    return {
      description: "Prefer to use external stylesheets with the `<link>` tag instead of inlining the styling.",
      url: "https://html-validate.org/rules/no-style-tag.html"
    };
  }
  setup() {
    this.on("tag:start", (event) => {
      const node = event.target;
      if (node.tagName === "style") {
        this.report(node, "Use external stylesheet with <link> instead of <style> tag");
      }
    });
  }
}

class NoTrailingWhitespace extends Rule {
  documentation() {
    return {
      description: "Lines with trailing whitespace cause unnessecary diff when using version control and usually serve no special purpose in HTML.",
      url: "https://html-validate.org/rules/no-trailing-whitespace.html"
    };
  }
  setup() {
    this.on("whitespace", (event) => {
      if (event.text.match(/^[ \t]+\r?\n$/)) {
        this.report(null, "Trailing whitespace", event.location);
      }
    });
  }
}

const defaults$a = {
  include: null,
  exclude: null
};
class NoUnknownElements extends Rule {
  constructor(options) {
    super({ ...defaults$a, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation(context) {
    const element = context ? ` <${context}>` : "";
    return {
      description: `An unknown element${element} was used. If this is a Custom Element you need to supply element metadata for it.`,
      url: "https://html-validate.org/rules/no-unknown-elements.html"
    };
  }
  setup() {
    this.on("tag:start", (event) => {
      const node = event.target;
      if (node.meta) {
        return;
      }
      if (this.isKeywordIgnored(node.tagName, keywordPatternMatcher)) {
        return;
      }
      this.report(node, `Unknown element <${node.tagName}>`, null, node.tagName);
    });
  }
}

class NoUnusedDisable extends Rule {
  documentation(context) {
    return {
      description: `\`${context.ruleId}\` rule is disabled but no error was reported.`,
      url: "https://html-validate.org/rules/no-unused-disable.html"
    };
  }
  setup() {
  }
  reportUnused(unused, options, location) {
    const tokens = new DOMTokenList(options.replace(/,/g, " "), location);
    for (const ruleId of unused) {
      const index = tokens.indexOf(ruleId);
      const tokenLocation = index >= 0 ? tokens.location(index) : location;
      this.report({
        node: null,
        message: '"{{ ruleId }}" rule is disabled but no error was reported',
        location: tokenLocation,
        context: {
          ruleId
        }
      });
    }
  }
}

class NoUtf8Bom extends Rule {
  documentation() {
    return {
      description: `This file is saved with the UTF-8 byte order mark (BOM) present. It is neither required or recommended to use.

Instead the document should be served with the \`Content-Type: application/javascript; charset=utf-8\` header.`,
      url: "https://html-validate.org/rules/no-utf8-bom.html"
    };
  }
  setup() {
    const unregister = this.on("token", (event) => {
      if (event.type === TokenType.UNICODE_BOM) {
        this.report(null, "File should be saved without UTF-8 BOM", event.location);
      }
      this.setEnabled(false);
      unregister();
    });
  }
}

const types = ["button", "submit", "reset", "image"];
const replacement = {
  button: '<button type="button">',
  submit: '<button type="submit">',
  reset: '<button type="reset">',
  image: '<button type="button">'
};
const defaults$9 = {
  include: null,
  exclude: null
};
class PreferButton extends Rule {
  constructor(options) {
    super({ ...defaults$9, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation(context) {
    const src = `<input type="${context.type}">`;
    const dst = replacement[context.type] || `<button>`;
    return {
      description: `Prefer to use \`${dst}\` instead of \`"${src}\`.`,
      url: "https://html-validate.org/rules/prefer-button.html"
    };
  }
  setup() {
    this.on("attr", (event) => {
      const node = event.target;
      if (node.tagName.toLowerCase() !== "input") {
        return;
      }
      if (event.key.toLowerCase() !== "type") {
        return;
      }
      if (!event.value || event.value instanceof DynamicValue) {
        return;
      }
      const type = event.value.toLowerCase();
      if (this.isKeywordIgnored(type)) {
        return;
      }
      if (!types.includes(type)) {
        return;
      }
      const context = { type };
      const message = `Prefer to use <button> instead of <input type="${type}"> when adding buttons`;
      this.report(node, message, event.valueLocation, context);
    });
  }
}

const defaults$8 = {
  mapping: {
    article: "article",
    banner: "header",
    button: "button",
    cell: "td",
    checkbox: "input",
    complementary: "aside",
    contentinfo: "footer",
    figure: "figure",
    form: "form",
    heading: "hN",
    input: "input",
    link: "a",
    list: "ul",
    listbox: "select",
    listitem: "li",
    main: "main",
    navigation: "nav",
    progressbar: "progress",
    radio: "input",
    region: "section",
    table: "table",
    textbox: "textarea"
  },
  include: null,
  exclude: null
};
class PreferNativeElement extends Rule {
  constructor(options) {
    super({ ...defaults$8, ...options });
  }
  static schema() {
    return {
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      mapping: {
        type: "object"
      }
    };
  }
  documentation(context) {
    return {
      description: `Instead of using the WAI-ARIA role "${context.role}" prefer to use the native <${context.replacement}> element.`,
      url: "https://html-validate.org/rules/prefer-native-element.html"
    };
  }
  setup() {
    const { mapping } = this.options;
    this.on("attr", (event) => {
      if (event.key.toLowerCase() !== "role") {
        return;
      }
      if (!event.value || event.value instanceof DynamicValue) {
        return;
      }
      const role = event.value.toLowerCase();
      if (this.isIgnored(role)) {
        return;
      }
      const replacement = mapping[role];
      if (event.target.is(replacement)) {
        return;
      }
      const context = { role, replacement };
      const location = this.getLocation(event);
      this.report(
        event.target,
        `Prefer to use the native <${replacement}> element`,
        location,
        context
      );
    });
  }
  isIgnored(role) {
    const { mapping } = this.options;
    const replacement = mapping[role];
    if (!replacement) {
      return true;
    }
    return this.isKeywordIgnored(role);
  }
  getLocation(event) {
    const begin = event.location;
    const end = event.valueLocation;
    const quote = event.quote ? 1 : 0;
    const size = end.offset + end.size - begin.offset + quote;
    return {
      filename: begin.filename,
      line: begin.line,
      column: begin.column,
      offset: begin.offset,
      size
    };
  }
}

class PreferTbody extends Rule {
  documentation() {
    return {
      description: `While \`<tbody>\` is optional is relays semantic information about its contents. Where applicable it should also be combined with \`<thead>\` and \`<tfoot>\`.`,
      url: "https://html-validate.org/rules/prefer-tbody.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const doc = event.document;
      for (const table of doc.querySelectorAll("table")) {
        if (table.querySelector("> tbody")) {
          continue;
        }
        const tr = table.querySelectorAll("> tr");
        if (tr.length >= 1) {
          this.report(tr[0], "Prefer to wrap <tr> elements in <tbody>");
        }
      }
    });
  }
}

const defaults$7 = {
  tags: ["script", "style"]
};
class RequireCSPNonce extends Rule {
  constructor(options) {
    super({ ...defaults$7, ...options });
  }
  static schema() {
    return {
      tags: {
        type: "array",
        items: {
          enum: ["script", "style"],
          type: "string"
        }
      }
    };
  }
  documentation() {
    return {
      description: [
        "Required Content-Security-Policy (CSP) nonce is missing or empty.",
        "",
        "This is set by the `nonce` attribute and must match the `Content-Security-Policy` header.",
        "For instance, if the header contains `script-src 'nonce-r4nd0m'` the `nonce` attribute must be set to `nonce=\"r4nd0m\">`",
        "",
        "The nonce should be unique per each request and set to a cryptography secure random token.",
        "It is used to prevent cross site scripting (XSS) by preventing malicious actors from injecting scripts onto the page."
      ].join("\n"),
      url: "https://html-validate.org/rules/require-csp-nonce.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      var _a;
      const { tags } = this.options;
      const node = event.previous;
      if (!tags.includes(node.tagName)) {
        return;
      }
      const nonce = (_a = node.getAttribute("nonce")) == null ? void 0 : _a.value;
      if (nonce && nonce !== "") {
        return;
      }
      if (node.is("script") && node.hasAttribute("src")) {
        return;
      }
      const message = `required CSP nonce is missing`;
      this.report(node, message, node.location);
    });
  }
}

const defaults$6 = {
  target: "all",
  include: null,
  exclude: null
};
const crossorigin = new RegExp("^(\\w+://|//)");
const supportSri = {
  link: "href",
  script: "src"
};
class RequireSri extends Rule {
  constructor(options) {
    super({ ...defaults$6, ...options });
    this.target = this.options.target;
  }
  static schema() {
    return {
      target: {
        enum: ["all", "crossorigin"],
        type: "string"
      },
      include: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      },
      exclude: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "null"
          }
        ]
      }
    };
  }
  documentation() {
    return {
      description: `Subresource Integrity (SRI) \`integrity\` attribute is required to prevent tampering or manipulation from Content Delivery Networks (CDN), rouge proxies,  malicious entities, etc.`,
      url: "https://html-validate.org/rules/require-sri.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (!(this.supportSri(node) && this.needSri(node))) {
        return;
      }
      if (node.hasAttribute("integrity")) {
        return;
      }
      this.report(
        node,
        `SRI "integrity" attribute is required on <${node.tagName}> element`,
        node.location
      );
    });
  }
  supportSri(node) {
    return Object.keys(supportSri).includes(node.tagName);
  }
  needSri(node) {
    const attr = this.elementSourceAttr(node);
    if (!attr) {
      return false;
    }
    if (attr.value === null || attr.value === "" || attr.isDynamic) {
      return false;
    }
    const url = attr.value.toString();
    if (this.target === "all" || crossorigin.test(url)) {
      return !this.isIgnored(url);
    }
    return false;
  }
  elementSourceAttr(node) {
    const key = supportSri[node.tagName];
    return node.getAttribute(key);
  }
  isIgnored(url) {
    return this.isKeywordIgnored(url, (list, it) => {
      return list.some((pattern) => it.includes(pattern));
    });
  }
}

class ScriptElement extends Rule {
  documentation() {
    return {
      description: "The end tag for `<script>` is a hard requirement and must never be omitted even when using the `src` attribute.",
      url: "https://html-validate.org/rules/script-element.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.target;
      if (!node || node.tagName !== "script") {
        return;
      }
      if (node.closed !== NodeClosed.EndTag) {
        this.report(node, `End tag for <${node.tagName}> must not be omitted`);
      }
    });
  }
}

const javascript = [
  "",
  "application/ecmascript",
  "application/javascript",
  "text/ecmascript",
  "text/javascript"
];
class ScriptType extends Rule {
  documentation() {
    return {
      description: "While valid the HTML5 standard encourages authors to omit the type element for JavaScript resources.",
      url: "https://html-validate.org/rules/script-type.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "script") {
        return;
      }
      const attr = node.getAttribute("type");
      if (!attr || attr.isDynamic) {
        return;
      }
      const value = attr.value ? attr.value.toString() : "";
      if (!this.isJavascript(value)) {
        return;
      }
      this.report(
        node,
        '"type" attribute is unnecessary for javascript resources',
        attr.keyLocation
      );
    });
  }
  isJavascript(mime) {
    const type = mime.replace(/;.*/, "");
    return javascript.includes(type);
  }
}

class SvgFocusable extends Rule {
  documentation() {
    return {
      description: `Inline SVG elements in IE are focusable by default which may cause issues with tab-ordering. The \`focusable\` attribute should explicitly be set to avoid unintended behaviour.`,
      url: "https://html-validate.org/rules/svg-focusable.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      if (event.target.is("svg")) {
        this.validate(event.target);
      }
    });
  }
  validate(svg) {
    if (svg.hasAttribute("focusable")) {
      return;
    }
    this.report(svg, `<${svg.tagName}> is missing required "focusable" attribute`);
  }
}

const defaults$5 = {
  characters: [
    { pattern: " ", replacement: "&nbsp;", description: "non-breaking space" },
    { pattern: "-", replacement: "&#8209;", description: "non-breaking hyphen" }
  ],
  ignoreClasses: [],
  ignoreStyle: true
};
function constructRegex(characters) {
  const disallowed = characters.map((it) => {
    return it.pattern;
  }).join("|");
  const pattern = `(${disallowed})`;
  return new RegExp(pattern, "g");
}
function getText(node) {
  const match = node.textContent.match(/^(\s*)(.*)$/);
  const [, leading, text] = match;
  return [leading.length, text.trimEnd()];
}
function matchAll(text, regexp) {
  const copy = new RegExp(regexp);
  const matches = [];
  let match;
  while (match = copy.exec(text)) {
    matches.push(match);
  }
  return matches;
}
class TelNonBreaking extends Rule {
  constructor(options) {
    super({ ...defaults$5, ...options });
    this.regex = constructRegex(this.options.characters);
  }
  static schema() {
    return {
      characters: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          properties: {
            pattern: {
              type: "string"
            },
            replacement: {
              type: "string"
            },
            description: {
              type: "string"
            }
          }
        }
      },
      ignoreClasses: {
        type: "array",
        items: {
          type: "string"
        }
      },
      ignoreStyle: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    const { characters } = this.options;
    const replacements = characters.map((it) => {
      return `  - \`${it.pattern}\` - replace with \`${it.replacement}\` (${it.description}).`;
    });
    return {
      description: [
        `The \`${context.pattern}\` character should be replaced with \`${context.replacement}\` character (${context.description}) when used in a telephone number.`,
        "",
        "Unless non-breaking characters is used there could be a line break inserted at that character.",
        "Line breaks make is harder to read and understand the telephone number.",
        "",
        "The following characters should be avoided:",
        "",
        ...replacements
      ].join("\n"),
      url: "https://html-validate.org/rules/tel-non-breaking.html"
    };
  }
  setup() {
    this.on("element:ready", this.isRelevant, (event) => {
      const { target } = event;
      if (this.isIgnored(target)) {
        return;
      }
      this.walk(target, target);
    });
  }
  isRelevant(event) {
    const { target } = event;
    if (!target.is("a")) {
      return false;
    }
    const attr = target.getAttribute("href");
    if (!attr || !attr.valueMatches(/^tel:/, false)) {
      return false;
    }
    return true;
  }
  isIgnoredClass(node) {
    const { ignoreClasses } = this.options;
    const { classList } = node;
    return ignoreClasses.some((it) => classList.contains(it));
  }
  isIgnoredStyle(node) {
    const { ignoreStyle } = this.options;
    const { style } = node;
    if (!ignoreStyle) {
      return false;
    }
    if (style["white-space"] === "nowrap" || style["white-space"] === "pre") {
      return true;
    }
    return false;
  }
  isIgnored(node) {
    return this.isIgnoredClass(node) || this.isIgnoredStyle(node);
  }
  walk(anchor, node) {
    for (const child of node.childNodes) {
      if (isTextNode(child)) {
        this.detectDisallowed(anchor, child);
      } else if (isElementNode(child)) {
        this.walk(anchor, child);
      }
    }
  }
  detectDisallowed(anchor, node) {
    const [offset, text] = getText(node);
    const matches = matchAll(text, this.regex);
    for (const match of matches) {
      const detected = match[0];
      const entry = this.options.characters.find((it) => it.pattern === detected);
      if (!entry) {
        throw new Error(`Failed to find entry for "${detected}" when searching text "${text}"`);
      }
      const message = `"${detected}" should be replaced with "${entry.replacement}" (${entry.description}) in telephone number`;
      const begin = offset + match.index;
      const end = begin + detected.length;
      const location = sliceLocation(node.location, begin, end);
      const context = entry;
      this.report(anchor, message, location, context);
    }
  }
}

function hasNonEmptyAttribute(node, key) {
  const attr = node.getAttribute(key);
  return Boolean(attr && attr.valueMatches(/.+/, true));
}
function hasDefaultText(node) {
  if (!node.is("input")) {
    return false;
  }
  if (node.hasAttribute("value")) {
    return false;
  }
  const type = node.getAttribute("type");
  return Boolean(type && type.valueMatches(/submit|reset/, false));
}
function isNonEmptyText(node) {
  if (isTextNode(node)) {
    return node.isDynamic || node.textContent.trim() !== "";
  } else {
    return false;
  }
}
function haveAccessibleText(node) {
  if (!inAccessibilityTree(node)) {
    return false;
  }
  const haveText = node.childNodes.some((child) => isNonEmptyText(child));
  if (haveText) {
    return true;
  }
  if (hasNonEmptyAttribute(node, "aria-label")) {
    return true;
  }
  if (hasNonEmptyAttribute(node, "aria-labelledby")) {
    return true;
  }
  if (node.is("img") && hasNonEmptyAttribute(node, "alt")) {
    return true;
  }
  if (hasDefaultText(node)) {
    return true;
  }
  return node.childElements.some((child) => {
    return haveAccessibleText(child);
  });
}
class TextContent extends Rule {
  documentation(context) {
    const doc = {
      description: `The textual content for this element is not valid.`,
      url: "https://html-validate.org/rules/text-content.html"
    };
    switch (context.textContent) {
      case TextContent$1.NONE:
        doc.description = `The \`<${context.tagName}>\` element must not have textual content.`;
        break;
      case TextContent$1.REQUIRED:
        doc.description = `The \`<${context.tagName}>\` element must have textual content.`;
        break;
      case TextContent$1.ACCESSIBLE:
        doc.description = `The \`<${context.tagName}>\` element must have accessible text.`;
        break;
    }
    return doc;
  }
  static filter(event) {
    const { target } = event;
    if (!target.meta) {
      return false;
    }
    const { textContent } = target.meta;
    if (!textContent || textContent === TextContent$1.DEFAULT) {
      return false;
    }
    return true;
  }
  setup() {
    this.on("element:ready", TextContent.filter, (event) => {
      const target = event.target;
      const { textContent } = target.meta;
      switch (textContent) {
        case TextContent$1.NONE:
          this.validateNone(target);
          break;
        case TextContent$1.REQUIRED:
          this.validateRequired(target);
          break;
        case TextContent$1.ACCESSIBLE:
          this.validateAccessible(target);
          break;
      }
    });
  }
  /**
   * Validate element has empty text (inter-element whitespace is not considered text)
   */
  validateNone(node) {
    if (classifyNodeText(node) === TextClassification.EMPTY_TEXT) {
      return;
    }
    this.reportError(node, node.meta, `${node.annotatedName} must not have text content`);
  }
  /**
   * Validate element has any text (inter-element whitespace is not considered text)
   */
  validateRequired(node) {
    if (classifyNodeText(node) !== TextClassification.EMPTY_TEXT) {
      return;
    }
    this.reportError(node, node.meta, `${node.annotatedName} must have text content`);
  }
  /**
   * Validate element has accessible text (either regular text or text only
   * exposed in accessibility tree via aria-label or similar)
   */
  validateAccessible(node) {
    if (!inAccessibilityTree(node)) {
      return;
    }
    if (haveAccessibleText(node)) {
      return;
    }
    this.reportError(node, node.meta, `${node.annotatedName} must have accessible text`);
  }
  reportError(node, meta, message) {
    this.report(node, message, null, {
      tagName: node.tagName,
      textContent: meta.textContent
    });
  }
}

const roles = ["complementary", "contentinfo", "form", "banner", "main", "navigation", "region"];
const selectors = [
  "aside",
  "footer",
  "form",
  "header",
  "main",
  "nav",
  "section",
  ...roles.map((it) => `[role="${it}"]`)
  /* <search> does not (yet?) require a unique name */
];
function getTextFromReference(document, id) {
  if (!id || id instanceof DynamicValue) {
    return id;
  }
  const selector = `#${id}`;
  const ref = document.querySelector(selector);
  if (ref) {
    return ref.textContent;
  } else {
    return selector;
  }
}
function groupBy(values, callback) {
  const result = {};
  for (const value of values) {
    const key = callback(value);
    if (key in result) {
      result[key].push(value);
    } else {
      result[key] = [value];
    }
  }
  return result;
}
function getTextEntryFromElement(document, node) {
  const ariaLabel = node.getAttribute("aria-label");
  if (ariaLabel) {
    return {
      node,
      text: ariaLabel.value,
      location: ariaLabel.keyLocation
    };
  }
  const ariaLabelledby = node.getAttribute("aria-labelledby");
  if (ariaLabelledby) {
    const text = getTextFromReference(document, ariaLabelledby.value);
    return {
      node,
      text,
      location: ariaLabelledby.keyLocation
    };
  }
  return {
    node,
    text: null,
    location: node.location
  };
}
function isExcluded(entry) {
  const { node, text } = entry;
  if (text === null) {
    return !(node.is("form") || node.is("section"));
  }
  return true;
}
class UniqueLandmark extends Rule {
  documentation() {
    return {
      description: [
        "When the same type of landmark is present more than once in the same document each must be uniquely identifiable with a non-empty and unique name.",
        "For instance, if the document has two `<nav>` elements each of them need an accessible name to be distinguished from each other.",
        "",
        "The following elements / roles are considered landmarks:",
        "",
        '  - `aside` or `[role="complementary"]`',
        '  - `footer` or `[role="contentinfo"]`',
        '  - `form` or `[role="form"]`',
        '  - `header` or `[role="banner"]`',
        '  - `main` or `[role="main"]`',
        '  - `nav` or `[role="navigation"]`',
        '  - `section` or `[role="region"]`',
        "",
        "To fix this either:",
        "",
        "  - Add `aria-label`.",
        "  - Add `aria-labelledby`.",
        "  - Remove one of the landmarks."
      ].join("\n"),
      url: "https://html-validate.org/rules/unique-landmark.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const elements = document.querySelectorAll(selectors.join(",")).filter((it) => typeof it.role === "string" && roles.includes(it.role));
      const grouped = groupBy(elements, (it) => it.role);
      for (const nodes of Object.values(grouped)) {
        if (nodes.length <= 1) {
          continue;
        }
        const entries = nodes.map((it) => getTextEntryFromElement(document, it));
        const filteredEntries = entries.filter(isExcluded);
        for (const entry of filteredEntries) {
          if (entry.text instanceof DynamicValue) {
            continue;
          }
          const dup = entries.filter((it) => it.text === entry.text).length > 1;
          if (!entry.text || dup) {
            const message = `Landmarks must have a non-empty and unique accessible name (aria-label or aria-labelledby)`;
            const location = entry.location;
            this.report({
              node: entry.node,
              message,
              location
            });
          }
        }
      }
    });
  }
}

const defaults$4 = {
  ignoreCase: false,
  requireSemicolon: true
};
const regexp$1 = /&(?:[a-z0-9]+|#x?[0-9a-f]+)(;|[^a-z0-9]|$)/gi;
const lowercaseEntities = elements.entities.map((it) => it.toLowerCase());
function isNumerical(entity) {
  return entity.startsWith("&#");
}
function getLocation(location, entity, match) {
  const index = match.index ?? 0;
  return sliceLocation(location, index, index + entity.length);
}
function getDescription(context, options) {
  const url = "https://html.spec.whatwg.org/multipage/named-characters.html";
  let message;
  if (context.terminated) {
    message = `Unrecognized character reference \`${context.entity}\`.`;
  } else {
    message = `Character reference \`${context.entity}\` must be terminated by a semicolon.`;
  }
  return [
    message,
    `HTML5 defines a set of [valid character references](${url}) but this is not a valid one.`,
    "",
    "Ensure that:",
    "",
    "1. The character is one of the listed names.",
    ...options.ignoreCase ? [] : ["1. The case is correct (names are case sensitive)."],
    ...options.requireSemicolon ? ["1. The name is terminated with a `;`."] : []
  ].join("\n");
}
class UnknownCharReference extends Rule {
  constructor(options) {
    super({ ...defaults$4, ...options });
  }
  static schema() {
    return {
      ignoreCase: {
        type: "boolean"
      },
      requireSemicolon: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    return {
      description: getDescription(context, this.options),
      url: "https://html-validate.org/rules/unrecognized-char-ref.html"
    };
  }
  setup() {
    this.on("element:ready", (event) => {
      const node = event.target;
      for (const child of node.childNodes) {
        if (child.nodeType !== NodeType.TEXT_NODE) {
          continue;
        }
        this.findCharacterReferences(node, child.textContent, child.location, {
          isAttribute: false
        });
      }
    });
    this.on("attr", (event) => {
      if (!event.value) {
        return;
      }
      this.findCharacterReferences(event.target, event.value.toString(), event.valueLocation, {
        isAttribute: true
      });
    });
  }
  get entities() {
    if (this.options.ignoreCase) {
      return lowercaseEntities;
    } else {
      return elements.entities;
    }
  }
  findCharacterReferences(node, text, location, { isAttribute }) {
    const isQuerystring = isAttribute && text.includes("?");
    for (const match of this.getMatches(text)) {
      this.validateCharacterReference(node, location, match, { isQuerystring });
    }
  }
  validateCharacterReference(node, location, foobar, { isQuerystring }) {
    const { requireSemicolon } = this.options;
    const { match, entity, raw, terminated } = foobar;
    if (isNumerical(entity)) {
      return;
    }
    if (isQuerystring && !terminated) {
      return;
    }
    const found = this.entities.includes(entity);
    if (found && (terminated || !requireSemicolon)) {
      return;
    }
    if (found && !terminated) {
      const entityLocation2 = getLocation(location, entity, match);
      const message2 = `Character reference "{{ entity }}" must be terminated by a semicolon`;
      const context2 = {
        entity: raw,
        terminated: false
      };
      this.report(node, message2, entityLocation2, context2);
      return;
    }
    const entityLocation = getLocation(location, entity, match);
    const message = `Unrecognized character reference "{{ entity }}"`;
    const context = {
      entity: raw,
      terminated: true
    };
    this.report(node, message, entityLocation, context);
  }
  *getMatches(text) {
    let match;
    do {
      match = regexp$1.exec(text);
      if (match) {
        const terminator = match[1];
        const terminated = terminator === ";";
        const needSlice = terminator !== ";" && terminator.length > 0;
        const entity = needSlice ? match[0].slice(0, -1) : match[0];
        if (this.options.ignoreCase) {
          yield { match, entity: entity.toLowerCase(), raw: entity, terminated };
        } else {
          yield { match, entity, raw: entity, terminated };
        }
      }
    } while (match);
  }
}

const expectedOrder = ["section", "hint", "contact", "field1", "field2", "webauthn"];
const fieldNames1 = [
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
];
const fieldNames2 = [
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
];
const fieldNameGroup = {
  name: "text",
  "honorific-prefix": "text",
  "given-name": "text",
  "additional-name": "text",
  "family-name": "text",
  "honorific-suffix": "text",
  nickname: "text",
  username: "username",
  "new-password": "password",
  "current-password": "password",
  "one-time-code": "password",
  "organization-title": "text",
  organization: "text",
  "street-address": "multiline",
  "address-line1": "text",
  "address-line2": "text",
  "address-line3": "text",
  "address-level4": "text",
  "address-level3": "text",
  "address-level2": "text",
  "address-level1": "text",
  country: "text",
  "country-name": "text",
  "postal-code": "text",
  "cc-name": "text",
  "cc-given-name": "text",
  "cc-additional-name": "text",
  "cc-family-name": "text",
  "cc-number": "text",
  "cc-exp": "month",
  "cc-exp-month": "numeric",
  "cc-exp-year": "numeric",
  "cc-csc": "text",
  "cc-type": "text",
  "transaction-currency": "text",
  "transaction-amount": "numeric",
  language: "text",
  bday: "date",
  "bday-day": "numeric",
  "bday-month": "numeric",
  "bday-year": "numeric",
  sex: "text",
  url: "url",
  photo: "url",
  tel: "tel",
  "tel-country-code": "text",
  "tel-national": "text",
  "tel-area-code": "text",
  "tel-local": "text",
  "tel-local-prefix": "text",
  "tel-local-suffix": "text",
  "tel-extension": "text",
  email: "username",
  impp: "url"
};
const disallowedInputTypes = ["checkbox", "radio", "file", "submit", "image", "reset", "button"];
function matchSection(token) {
  return token.startsWith("section-");
}
function matchHint(token) {
  return token === "shipping" || token === "billing";
}
function matchFieldNames1(token) {
  return fieldNames1.includes(token);
}
function matchContact(token) {
  const haystack = ["home", "work", "mobile", "fax", "pager"];
  return haystack.includes(token);
}
function matchFieldNames2(token) {
  return fieldNames2.includes(token);
}
function matchWebauthn(token) {
  return token === "webauthn";
}
function matchToken(token) {
  if (matchSection(token)) {
    return "section";
  }
  if (matchHint(token)) {
    return "hint";
  }
  if (matchFieldNames1(token)) {
    return "field1";
  }
  if (matchFieldNames2(token)) {
    return "field2";
  }
  if (matchContact(token)) {
    return "contact";
  }
  if (matchWebauthn(token)) {
    return "webauthn";
  }
  return null;
}
function getControlGroups(type) {
  const allGroups = [
    "text",
    "multiline",
    "password",
    "url",
    "username",
    "tel",
    "numeric",
    "month",
    "date"
  ];
  const mapping = {
    hidden: allGroups,
    text: allGroups.filter((it) => it !== "multiline"),
    search: allGroups.filter((it) => it !== "multiline"),
    password: ["password"],
    url: ["url"],
    email: ["username"],
    tel: ["tel"],
    number: ["numeric"],
    month: ["month"],
    date: ["date"]
  };
  const groups = mapping[type];
  if (groups) {
    return groups;
  }
  return [];
}
function isDisallowedType(node, type) {
  if (!node.is("input")) {
    return false;
  }
  return disallowedInputTypes.includes(type);
}
function getTerminalMessage(context) {
  switch (context.msg) {
    case 0 /* InvalidAttribute */:
      return "autocomplete attribute cannot be used on {{ what }}";
    case 1 /* InvalidValue */:
      return '"{{ value }}" cannot be used on {{ what }}';
    case 2 /* InvalidOrder */:
      return '"{{ second }}" must appear before "{{ first }}"';
    case 3 /* InvalidToken */:
      return '"{{ token }}" is not a valid autocomplete token or field name';
    case 4 /* InvalidCombination */:
      return '"{{ second }}" cannot be combined with "{{ first }}"';
    case 5 /* MissingField */:
      return "autocomplete attribute is missing field name";
  }
}
function getMarkdownMessage(context) {
  switch (context.msg) {
    case 0 /* InvalidAttribute */:
      return [
        `\`autocomplete\` attribute cannot be used on \`${context.what}\``,
        "",
        "The following input types cannot use the `autocomplete` attribute:",
        "",
        ...disallowedInputTypes.map((it) => `- \`${it}\``)
      ].join("\n");
    case 1 /* InvalidValue */: {
      const message = `\`"${context.value}"\` cannot be used on \`${context.what}\``;
      if (context.type === "form") {
        return [
          message,
          "",
          'The `<form>` element can only use the values `"on"` and `"off"`.'
        ].join("\n");
      }
      if (context.type === "hidden") {
        return [
          message,
          "",
          '`<input type="hidden">` cannot use the values `"on"` and `"off"`.'
        ].join("\n");
      }
      const controlGroups = getControlGroups(context.type);
      const currentGroup = fieldNameGroup[context.value];
      return [
        message,
        "",
        `\`${context.what}\` allows autocomplete fields from the following group${controlGroups.length > 1 ? "s" : ""}:`,
        "",
        ...controlGroups.map((it) => `- ${it}`),
        "",
        `The field \`"${context.value}"\` belongs to the group /${currentGroup}/ which cannot be used with this input type.`
      ].join("\n");
    }
    case 2 /* InvalidOrder */:
      return [
        `\`"${context.second}"\` must appear before \`"${context.first}"\``,
        "",
        "The autocomplete tokens must appear in the following order:",
        "",
        "- Optional section name (`section-` prefix).",
        "- Optional `shipping` or `billing` token.",
        "- Optional `home`, `work`, `mobile`, `fax` or `pager` token (for fields supporting it).",
        "- Field name",
        "- Optional `webauthn` token."
      ].join("\n");
    case 3 /* InvalidToken */:
      return `\`"${context.token}"\` is not a valid autocomplete token or field name`;
    case 4 /* InvalidCombination */:
      return `\`"${context.second}"\` cannot be combined with \`"${context.first}"\``;
    case 5 /* MissingField */:
      return "Autocomplete attribute is missing field name";
  }
}
class ValidAutocomplete extends Rule {
  documentation(context) {
    return {
      description: getMarkdownMessage(context),
      url: "https://html-validate.org/rules/valid-autocomplete.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const elements = document.querySelectorAll("[autocomplete]");
      for (const element of elements) {
        const autocomplete = element.getAttribute("autocomplete");
        if (autocomplete.value === null || autocomplete.value instanceof DynamicValue) {
          continue;
        }
        const location = autocomplete.valueLocation;
        const value = autocomplete.value.toLowerCase();
        const tokens = new DOMTokenList(value, location);
        if (tokens.length === 0) {
          continue;
        }
        this.validate(element, value, tokens, autocomplete.keyLocation, location);
      }
    });
  }
  validate(node, value, tokens, keyLocation, valueLocation) {
    switch (node.tagName) {
      case "form":
        this.validateFormAutocomplete(node, value, valueLocation);
        break;
      case "input":
      case "textarea":
      case "select":
        this.validateControlAutocomplete(node, tokens, keyLocation);
        break;
    }
  }
  validateControlAutocomplete(node, tokens, keyLocation) {
    const type = node.getAttributeValue("type") ?? "text";
    const mantle = type !== "hidden" ? "expectation" : "anchor";
    if (isDisallowedType(node, type)) {
      const context = {
        msg: 0 /* InvalidAttribute */,
        what: `<input type="${type}">`
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: keyLocation,
        context
      });
      return;
    }
    if (tokens.includes("on") || tokens.includes("off")) {
      this.validateOnOff(node, mantle, tokens);
      return;
    }
    this.validateTokens(node, tokens, keyLocation);
  }
  validateFormAutocomplete(node, value, location) {
    const trimmed = value.trim();
    if (["on", "off"].includes(trimmed)) {
      return;
    }
    const context = {
      msg: 1 /* InvalidValue */,
      type: "form",
      value: trimmed,
      what: "<form>"
    };
    this.report({
      node,
      message: getTerminalMessage(context),
      location,
      context
    });
  }
  validateOnOff(node, mantle, tokens) {
    const index = tokens.findIndex((it) => it === "on" || it === "off");
    const value = tokens.item(index);
    const location = tokens.location(index);
    if (tokens.length > 1) {
      const context = {
        msg: 4 /* InvalidCombination */,
        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
        first: tokens.item(index > 0 ? 0 : 1),
        second: value
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location,
        context
      });
    }
    switch (mantle) {
      case "expectation":
        return;
      case "anchor": {
        const context = {
          msg: 1 /* InvalidValue */,
          type: "hidden",
          value,
          what: `<input type="hidden">`
        };
        this.report({
          node,
          message: getTerminalMessage(context),
          location: tokens.location(0),
          context
        });
      }
    }
  }
  validateTokens(node, tokens, keyLocation) {
    const order = [];
    for (const { item, location } of tokens.iterator()) {
      const tokenType = matchToken(item);
      if (tokenType) {
        order.push(tokenType);
      } else {
        const context = {
          msg: 3 /* InvalidToken */,
          token: item
        };
        this.report({
          node,
          message: getTerminalMessage(context),
          location,
          context
        });
        return;
      }
    }
    const fieldTokens = order.map((it) => it === "field1" || it === "field2");
    this.validateFieldPresence(node, tokens, fieldTokens, keyLocation);
    this.validateContact(node, tokens, order);
    this.validateOrder(node, tokens, order);
    this.validateControlGroup(node, tokens, fieldTokens);
  }
  /**
   * Ensure that exactly one field name is present from the two field lists.
   */
  validateFieldPresence(node, tokens, fieldTokens, keyLocation) {
    const numFields = fieldTokens.filter(Boolean).length;
    if (numFields === 0) {
      const context = {
        msg: 5 /* MissingField */
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: keyLocation,
        context
      });
    } else if (numFields > 1) {
      const a = fieldTokens.indexOf(true);
      const b = fieldTokens.lastIndexOf(true);
      const context = {
        msg: 4 /* InvalidCombination */,
        /* eslint-disable @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
        first: tokens.item(a),
        second: tokens.item(b)
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: tokens.location(b),
        context
      });
    }
  }
  /**
   * Ensure contact token is only used with field names from the second list.
   */
  validateContact(node, tokens, order) {
    if (order.includes("contact") && order.includes("field1")) {
      const a = order.indexOf("field1");
      const b = order.indexOf("contact");
      const context = {
        msg: 4 /* InvalidCombination */,
        /* eslint-disable @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
        first: tokens.item(a),
        second: tokens.item(b)
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: tokens.location(b),
        context
      });
    }
  }
  validateOrder(node, tokens, order) {
    const indicies = order.map((it) => expectedOrder.indexOf(it));
    for (let i = 0; i < indicies.length - 1; i++) {
      if (indicies[0] > indicies[i + 1]) {
        const context = {
          msg: 2 /* InvalidOrder */,
          /* eslint-disable @typescript-eslint/no-non-null-assertion -- it must be present of it wouldn't be found */
          first: tokens.item(i),
          second: tokens.item(i + 1)
          /* eslint-enable @typescript-eslint/no-non-null-assertion */
        };
        this.report({
          node,
          message: getTerminalMessage(context),
          location: tokens.location(i + 1),
          context
        });
      }
    }
  }
  validateControlGroup(node, tokens, fieldTokens) {
    const numFields = fieldTokens.filter(Boolean).length;
    if (numFields === 0) {
      return;
    }
    if (!node.is("input")) {
      return;
    }
    const attr = node.getAttribute("type");
    const type = (attr == null ? void 0 : attr.value) ?? "text";
    if (type instanceof DynamicValue) {
      return;
    }
    const controlGroups = getControlGroups(type);
    const fieldIndex = fieldTokens.indexOf(true);
    const fieldToken = tokens.item(fieldIndex);
    const fieldGroup = fieldNameGroup[fieldToken];
    if (!controlGroups.includes(fieldGroup)) {
      const context = {
        msg: 1 /* InvalidValue */,
        type,
        value: fieldToken,
        what: `<input type="${type}">`
      };
      this.report({
        node,
        message: getTerminalMessage(context),
        location: tokens.location(fieldIndex),
        context
      });
    }
  }
}

const defaults$3 = {
  relaxed: false
};
class ValidID extends Rule {
  constructor(options) {
    super({ ...defaults$3, ...options });
  }
  static schema() {
    return {
      relaxed: {
        type: "boolean"
      }
    };
  }
  documentation(context) {
    const { relaxed } = this.options;
    const message = this.messages[context].replace("id", "ID").replace(/^(.)/, (m) => m.toUpperCase());
    const relaxedDescription = relaxed ? [] : [
      "  - ID must begin with a letter",
      "  - ID must only contain alphanumerical characters, `-` and `_`"
    ];
    return {
      description: [
        `${message}.`,
        "",
        "Under the current configuration the following rules are applied:",
        "",
        "  - ID must not be empty",
        "  - ID must not contain any whitespace characters",
        ...relaxedDescription
      ].join("\n"),
      url: "https://html-validate.org/rules/valid-id.html"
    };
  }
  setup() {
    this.on("attr", this.isRelevant, (event) => {
      const { value } = event;
      if (value === null || value instanceof DynamicValue) {
        return;
      }
      if (value === "") {
        const context = 1 /* EMPTY */;
        this.report(event.target, this.messages[context], event.location, context);
        return;
      }
      if (value.match(/\s/)) {
        const context = 2 /* WHITESPACE */;
        this.report(event.target, this.messages[context], event.valueLocation, context);
        return;
      }
      const { relaxed } = this.options;
      if (relaxed) {
        return;
      }
      if (value.match(/^[^a-zA-Z]/)) {
        const context = 3 /* LEADING_CHARACTER */;
        this.report(event.target, this.messages[context], event.valueLocation, context);
        return;
      }
      if (value.match(/[^a-zA-Z0-9-_]/)) {
        const context = 4 /* DISALLOWED_CHARACTER */;
        this.report(event.target, this.messages[context], event.valueLocation, context);
      }
    });
  }
  get messages() {
    return {
      [1 /* EMPTY */]: "element id must not be empty",
      [2 /* WHITESPACE */]: "element id must not contain whitespace",
      [3 /* LEADING_CHARACTER */]: "element id must begin with a letter",
      [4 /* DISALLOWED_CHARACTER */]: "element id must only contain alphanumerical, dash and underscore characters"
    };
  }
  isRelevant(event) {
    return event.key === "id";
  }
}

class VoidContent extends Rule {
  documentation(tagName) {
    const doc = {
      description: "HTML void elements cannot have any content and must not have content or end tag.",
      url: "https://html-validate.org/rules/void-content.html"
    };
    if (tagName) {
      doc.description = `<${tagName}> is a void element and must not have content or end tag.`;
    }
    return doc;
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.target;
      if (!node) {
        return;
      }
      if (!node.voidElement) {
        return;
      }
      if (node.closed === NodeClosed.EndTag) {
        this.report(
          null,
          `End tag for <${node.tagName}> must be omitted`,
          node.location,
          node.tagName
        );
      }
    });
  }
}

const defaults$2 = {
  style: "omit"
};
class VoidStyle extends Rule {
  constructor(options) {
    super({ ...defaults$2, ...options });
    this.style = parseStyle(this.options.style);
  }
  static schema() {
    return {
      style: {
        enum: ["omit", "selfclose", "selfclosing"],
        type: "string"
      }
    };
  }
  documentation(context) {
    const [desc, end] = styleDescription(context.style);
    return {
      description: `The current configuration requires void elements to ${desc}, use <${context.tagName}${end}> instead.`,
      url: "https://html-validate.org/rules/void-style.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const active = event.previous;
      if (active.meta) {
        this.validateActive(active);
      }
    });
  }
  validateActive(node) {
    if (!node.voidElement) {
      return;
    }
    if (this.shouldBeOmitted(node)) {
      this.reportError(
        node,
        `Expected omitted end tag <${node.tagName}> instead of self-closing element <${node.tagName}/>`
      );
    }
    if (this.shouldBeSelfClosed(node)) {
      this.reportError(
        node,
        `Expected self-closing element <${node.tagName}/> instead of omitted end-tag <${node.tagName}>`
      );
    }
  }
  reportError(node, message) {
    const context = {
      style: this.style,
      tagName: node.tagName
    };
    super.report(node, message, null, context);
  }
  shouldBeOmitted(node) {
    return this.style === 1 /* AlwaysOmit */ && node.closed === NodeClosed.VoidSelfClosed;
  }
  shouldBeSelfClosed(node) {
    return this.style === 2 /* AlwaysSelfclose */ && node.closed === NodeClosed.VoidOmitted;
  }
}
function parseStyle(name) {
  switch (name) {
    case "omit":
      return 1 /* AlwaysOmit */;
    case "selfclose":
    case "selfclosing":
      return 2 /* AlwaysSelfclose */;
    default:
      throw new Error(`Invalid style "${name}" for "void-style" rule`);
  }
}
function styleDescription(style) {
  switch (style) {
    case 1 /* AlwaysOmit */:
      return ["omit end tag", ""];
    case 2 /* AlwaysSelfclose */:
      return ["be self-closed", "/"];
    default:
      throw new Error(`Unknown style`);
  }
}

class H30 extends Rule {
  documentation() {
    return {
      description: "WCAG 2.1 requires each `<a>` anchor link to have a text describing the purpose of the link using either plain text or an `<img>` with the `alt` attribute set.",
      url: "https://html-validate.org/rules/wcag/h30.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const links = event.document.getElementsByTagName("a");
      for (const link of links) {
        if (!inAccessibilityTree(link)) {
          continue;
        }
        const textClassification = classifyNodeText(link, { ignoreHiddenRoot: true });
        if (textClassification !== TextClassification.EMPTY_TEXT) {
          continue;
        }
        const images = link.querySelectorAll("img");
        if (images.some((image) => hasAltText(image))) {
          continue;
        }
        const labels = link.querySelectorAll("[aria-label]");
        if (hasAriaLabel(link) || labels.some((cur) => hasAriaLabel(cur))) {
          continue;
        }
        this.report(link, "Anchor link must have a text describing its purpose");
      }
    });
  }
}

class H32 extends Rule {
  documentation() {
    return {
      description: "WCAG 2.1 requires each `<form>` element to have at least one submit button.",
      url: "https://html-validate.org/rules/wcag/h32.html"
    };
  }
  setup() {
    const formTags = this.getTagsWithProperty("form");
    const formSelector = formTags.join(",");
    this.on("dom:ready", (event) => {
      const { document } = event;
      const forms = document.querySelectorAll(formSelector);
      for (const form of forms) {
        if (hasNestedSubmit(form)) {
          continue;
        }
        if (hasAssociatedSubmit(document, form)) {
          continue;
        }
        this.report(form, `<${form.tagName}> element must have a submit button`);
      }
    });
  }
}
function isSubmit(node) {
  const type = node.getAttribute("type");
  return Boolean(!type || type.valueMatches(/submit|image/));
}
function isAssociated(id, node) {
  const form = node.getAttribute("form");
  return Boolean(form && form.valueMatches(id, true));
}
function hasNestedSubmit(form) {
  const matches = form.querySelectorAll("button,input").filter(isSubmit).filter((node) => !node.hasAttribute("form"));
  return matches.length > 0;
}
function hasAssociatedSubmit(document, form) {
  const { id } = form;
  if (!id) {
    return false;
  }
  const matches = document.querySelectorAll("button[form],input[form]").filter(isSubmit).filter((node) => isAssociated(id, node));
  return matches.length > 0;
}

class H36 extends Rule {
  documentation() {
    return {
      description: 'WCAG 2.1 requires all images used as submit buttons to have a textual description using the alt attribute. The alt text cannot be empty (`alt=""`).',
      url: "https://html-validate.org/rules/wcag/h36.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.previous;
      if (node.tagName !== "input")
        return;
      if (node.getAttributeValue("type") !== "image") {
        return;
      }
      if (!hasAltText(node)) {
        this.report(node, "image used as submit button must have alt text");
      }
    });
  }
}

const defaults$1 = {
  allowEmpty: true,
  alias: []
};
function needsAlt(node) {
  if (node.is("img")) {
    return true;
  }
  if (node.is("input") && node.getAttributeValue("type") === "image") {
    return true;
  }
  return false;
}
function getTag(node) {
  return node.is("input") ? `<input type="${/* istanbul ignore next */
  node.getAttributeValue("type") ?? ""}">` : `<${node.tagName}>`;
}
class H37 extends Rule {
  constructor(options) {
    super({ ...defaults$1, ...options });
    if (!Array.isArray(this.options.alias)) {
      this.options.alias = [this.options.alias];
    }
  }
  static schema() {
    return {
      alias: {
        anyOf: [
          {
            items: {
              type: "string"
            },
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      allowEmpty: {
        type: "boolean"
      }
    };
  }
  documentation() {
    return {
      description: "Both HTML5 and WCAG 2.0 requires images to have a alternative text for each image.",
      url: "https://html-validate.org/rules/wcag/h37.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const nodes = document.querySelectorAll("img, input");
      for (const node of nodes) {
        this.validateNode(node);
      }
    });
  }
  validateNode(node) {
    if (!needsAlt(node)) {
      return;
    }
    if (!inAccessibilityTree(node)) {
      return;
    }
    if (Boolean(node.getAttributeValue("alt")) || Boolean(node.hasAttribute("alt") && this.options.allowEmpty)) {
      return;
    }
    for (const attr of this.options.alias) {
      if (node.getAttribute(attr)) {
        return;
      }
    }
    if (node.hasAttribute("alt")) {
      const attr = node.getAttribute("alt");
      this.report(node, `${getTag(node)} cannot have empty "alt" attribute`, attr == null ? void 0 : attr.keyLocation);
    } else {
      this.report(node, `${getTag(node)} is missing required "alt" attribute`, node.location);
    }
  }
}

var _a;
const { enum: validScopes } = (_a = elements.html5.th.attributes) == null ? void 0 : _a.scope;
const joinedScopes = utils_naturalJoin.naturalJoin(validScopes);
class H63 extends Rule {
  documentation() {
    return {
      description: "H63: Using the scope attribute to associate header cells and data cells in data tables",
      url: "https://html-validate.org/rules/wcag/h63.html"
    };
  }
  setup() {
    this.on("tag:ready", (event) => {
      const node = event.target;
      if (node.tagName !== "th") {
        return;
      }
      const scope = node.getAttribute("scope");
      const value = scope == null ? void 0 : scope.value;
      if (value instanceof DynamicValue) {
        return;
      }
      if (value && validScopes.includes(value)) {
        return;
      }
      const message = `<th> element must have a valid scope attribute: ${joinedScopes}`;
      const location = (scope == null ? void 0 : scope.valueLocation) ?? (scope == null ? void 0 : scope.keyLocation) ?? node.location;
      this.report(node, message, location);
    });
  }
}

class H67 extends Rule {
  documentation() {
    return {
      description: "A decorative image cannot have a title attribute. Either remove `title` or add a descriptive `alt` text.",
      url: "https://html-validate.org/rules/wcag/h67.html"
    };
  }
  setup() {
    this.on("tag:end", (event) => {
      const node = event.target;
      if (!node || node.tagName !== "img") {
        return;
      }
      const title = node.getAttribute("title");
      if (!title || title.value === "") {
        return;
      }
      const alt = node.getAttributeValue("alt");
      if (alt && alt !== "") {
        return;
      }
      this.report(node, "<img> with empty alt text cannot have title attribute", title.keyLocation);
    });
  }
}

class H71 extends Rule {
  documentation() {
    return {
      description: "H71: Providing a description for groups of form controls using fieldset and legend elements",
      url: "https://html-validate.org/rules/wcag/h71.html"
    };
  }
  setup() {
    this.on("dom:ready", (event) => {
      const { document } = event;
      const fieldsets = document.querySelectorAll(this.selector);
      for (const fieldset of fieldsets) {
        this.validate(fieldset);
      }
    });
  }
  validate(fieldset) {
    const legend = fieldset.querySelectorAll("> legend");
    if (legend.length === 0) {
      this.reportNode(fieldset);
    }
  }
  reportNode(node) {
    super.report(node, `${node.annotatedName} must have a <legend> as the first child`);
  }
  get selector() {
    return this.getTagsDerivedFrom("fieldset").join(",");
  }
}

const bundledRules$1 = {
  "wcag/h30": H30,
  "wcag/h32": H32,
  "wcag/h36": H36,
  "wcag/h37": H37,
  "wcag/h63": H63,
  "wcag/h67": H67,
  "wcag/h71": H71
};
var WCAG = bundledRules$1;

const bundledRules = {
  "allowed-links": AllowedLinks,
  "area-alt": AreaAlt,
  "aria-hidden-body": AriaHiddenBody,
  "aria-label-misuse": AriaLabelMisuse,
  "attr-case": AttrCase,
  "attr-delimiter": AttrDelimiter,
  "attr-pattern": AttrPattern,
  "attr-quotes": AttrQuotes,
  "attr-spacing": AttrSpacing,
  "attribute-allowed-values": AttributeAllowedValues,
  "attribute-boolean-style": AttributeBooleanStyle,
  "attribute-empty-style": AttributeEmptyStyle,
  "attribute-misuse": AttributeMisuse,
  "class-pattern": ClassPattern,
  "close-attr": CloseAttr,
  "close-order": CloseOrder,
  deprecated: Deprecated,
  "deprecated-rule": DeprecatedRule,
  "doctype-html": NoStyleTag$1,
  "doctype-style": DoctypeStyle,
  "element-case": ElementCase,
  "element-name": ElementName,
  "element-permitted-content": ElementPermittedContent,
  "element-permitted-occurrences": ElementPermittedOccurrences,
  "element-permitted-order": ElementPermittedOrder,
  "element-permitted-parent": ElementPermittedParent,
  "element-required-ancestor": ElementRequiredAncestor,
  "element-required-attributes": ElementRequiredAttributes,
  "element-required-content": ElementRequiredContent,
  "empty-heading": EmptyHeading,
  "empty-title": EmptyTitle,
  "form-dup-name": FormDupName,
  "heading-level": HeadingLevel,
  "hidden-focusable": HiddenFocusable,
  "id-pattern": IdPattern,
  "input-attributes": InputAttributes,
  "input-missing-label": InputMissingLabel,
  "long-title": LongTitle,
  "map-dup-name": MapDupName,
  "map-id-name": MapIdName,
  "meta-refresh": MetaRefresh,
  "missing-doctype": MissingDoctype,
  "multiple-labeled-controls": MultipleLabeledControls,
  "name-pattern": NamePattern,
  "no-abstract-role": NoAbstractRole,
  "no-autoplay": NoAutoplay,
  "no-conditional-comment": NoConditionalComment,
  "no-deprecated-attr": NoDeprecatedAttr,
  "no-dup-attr": NoDupAttr,
  "no-dup-class": NoDupClass,
  "no-dup-id": NoDupID,
  "no-implicit-button-type": NoImplicitButtonType,
  "no-implicit-input-type": NoImplicitInputType,
  "no-implicit-close": NoImplicitClose,
  "no-inline-style": NoInlineStyle,
  "no-missing-references": NoMissingReferences,
  "no-multiple-main": NoMultipleMain,
  "no-raw-characters": NoRawCharacters,
  "no-redundant-aria-label": NoRedundantAriaLabel,
  "no-redundant-for": NoRedundantFor,
  "no-redundant-role": NoRedundantRole,
  "no-self-closing": NoSelfClosing,
  "no-style-tag": NoStyleTag,
  "no-trailing-whitespace": NoTrailingWhitespace,
  "no-unknown-elements": NoUnknownElements,
  "no-unused-disable": NoUnusedDisable,
  "no-utf8-bom": NoUtf8Bom,
  "prefer-button": PreferButton,
  "prefer-native-element": PreferNativeElement,
  "prefer-tbody": PreferTbody,
  "require-csp-nonce": RequireCSPNonce,
  "require-sri": RequireSri,
  "script-element": ScriptElement,
  "script-type": ScriptType,
  "svg-focusable": SvgFocusable,
  "tel-non-breaking": TelNonBreaking,
  "text-content": TextContent,
  "unique-landmark": UniqueLandmark,
  "unrecognized-char-ref": UnknownCharReference,
  "valid-autocomplete": ValidAutocomplete,
  "valid-id": ValidID,
  "void-content": VoidContent,
  "void-style": VoidStyle,
  ...WCAG
};

var defaultConfig = {};

const config$4 = {
  rules: {
    "area-alt": ["error", { accessible: true }],
    "aria-hidden-body": "error",
    "aria-label-misuse": ["error", { allowAnyNamable: false }],
    "deprecated-rule": "warn",
    "empty-heading": "error",
    "empty-title": "error",
    "hidden-focusable": "error",
    "meta-refresh": "error",
    "multiple-labeled-controls": "error",
    "no-abstract-role": "error",
    "no-autoplay": ["error", { include: ["audio", "video"] }],
    "no-dup-id": "error",
    "no-implicit-button-type": "error",
    "no-redundant-aria-label": "error",
    "no-redundant-for": "error",
    "no-redundant-role": "error",
    "prefer-native-element": "error",
    "svg-focusable": "off",
    "text-content": "error",
    "unique-landmark": "error",
    "valid-autocomplete": "error",
    "wcag/h30": "error",
    "wcag/h32": "error",
    "wcag/h36": "error",
    "wcag/h37": "error",
    "wcag/h63": "error",
    "wcag/h67": "error",
    "wcag/h71": "error"
  }
};
var a11y = config$4;

const config$3 = {
  rules: {
    "input-missing-label": "error",
    "heading-level": "error",
    "missing-doctype": "error",
    "no-missing-references": "error",
    "require-sri": "error"
  }
};
var document = config$3;

const config$2 = {
  rules: {
    "attr-quotes": "off",
    "doctype-style": "off",
    "void-style": "off"
  }
};
var prettier = config$2;

const config$1 = {
  rules: {
    "area-alt": ["error", { accessible: true }],
    "aria-hidden-body": "error",
    "aria-label-misuse": ["error", { allowAnyNamable: false }],
    "attr-case": "error",
    "attr-delimiter": "error",
    "attr-quotes": "error",
    "attr-spacing": "error",
    "attribute-allowed-values": "error",
    "attribute-boolean-style": "error",
    "attribute-empty-style": "error",
    "attribute-misuse": "error",
    "close-attr": "error",
    "close-order": "error",
    deprecated: "error",
    "deprecated-rule": "warn",
    "doctype-html": "error",
    "doctype-style": "error",
    "element-case": "error",
    "element-name": "error",
    "element-permitted-content": "error",
    "element-permitted-occurrences": "error",
    "element-permitted-order": "error",
    "element-permitted-parent": "error",
    "element-required-ancestor": "error",
    "element-required-attributes": "error",
    "element-required-content": "error",
    "empty-heading": "error",
    "empty-title": "error",
    "form-dup-name": "error",
    "hidden-focusable": "error",
    "input-attributes": "error",
    "long-title": "error",
    "map-dup-name": "error",
    "map-id-name": "error",
    "meta-refresh": "error",
    "multiple-labeled-controls": "error",
    "no-abstract-role": "error",
    "no-autoplay": ["error", { include: ["audio", "video"] }],
    "no-conditional-comment": "error",
    "no-deprecated-attr": "error",
    "no-dup-attr": "error",
    "no-dup-class": "error",
    "no-dup-id": "error",
    "no-implicit-button-type": "error",
    "no-implicit-input-type": "error",
    "no-implicit-close": "error",
    "no-inline-style": "error",
    "no-multiple-main": "error",
    "no-raw-characters": "error",
    "no-redundant-aria-label": "error",
    "no-redundant-for": "error",
    "no-redundant-role": "error",
    "no-self-closing": "error",
    "no-trailing-whitespace": "error",
    "no-utf8-bom": "error",
    "no-unused-disable": "error",
    "prefer-button": "error",
    "prefer-native-element": "error",
    "prefer-tbody": "error",
    "script-element": "error",
    "script-type": "error",
    "svg-focusable": "off",
    "tel-non-breaking": "error",
    "text-content": "error",
    "unique-landmark": "error",
    "unrecognized-char-ref": "error",
    "valid-autocomplete": "error",
    "valid-id": ["error", { relaxed: false }],
    void: "off",
    "void-content": "error",
    "void-style": "error",
    "wcag/h30": "error",
    "wcag/h32": "error",
    "wcag/h36": "error",
    "wcag/h37": "error",
    "wcag/h63": "error",
    "wcag/h67": "error",
    "wcag/h71": "error"
  }
};
var recommended = config$1;

const config = {
  rules: {
    "area-alt": ["error", { accessible: false }],
    "aria-label-misuse": ["error", { allowAnyNamable: true }],
    "attr-spacing": "error",
    "attribute-allowed-values": "error",
    "attribute-misuse": "error",
    "close-attr": "error",
    "close-order": "error",
    deprecated: "error",
    "deprecated-rule": "warn",
    "doctype-html": "error",
    "element-name": "error",
    "element-permitted-content": "error",
    "element-permitted-occurrences": "error",
    "element-permitted-order": "error",
    "element-permitted-parent": "error",
    "element-required-ancestor": "error",
    "element-required-attributes": "error",
    "element-required-content": "error",
    "map-dup-name": "error",
    "map-id-name": "error",
    "multiple-labeled-controls": "error",
    "no-abstract-role": "error",
    "no-deprecated-attr": "error",
    "no-dup-attr": "error",
    "no-dup-id": "error",
    "no-multiple-main": "error",
    "no-raw-characters": ["error", { relaxed: true }],
    "no-unused-disable": "error",
    "script-element": "error",
    "unrecognized-char-ref": "error",
    "valid-autocomplete": "error",
    "valid-id": ["error", { relaxed: true }],
    "void-content": "error"
  }
};
var standard = config;

const presets = {
  "html-validate:a11y": a11y,
  "html-validate:document": document,
  "html-validate:prettier": prettier,
  "html-validate:recommended": recommended,
  "html-validate:standard": standard,
  /* @deprecated aliases */
  "htmlvalidate:recommended": recommended,
  "htmlvalidate:document": document,
  "html-validate:a17y": a11y
};
var Presets = presets;

class ResolvedConfig {
  /**
   * @internal
   */
  constructor({ metaTable, plugins, rules, transformers }, original) {
    this.metaTable = metaTable;
    this.plugins = plugins;
    this.rules = rules;
    this.transformers = transformers;
    this.original = original;
  }
  /**
   * Returns the (merged) configuration data used to create this resolved
   * configuration.
   */
  getConfigData() {
    return this.original;
  }
  getMetaTable() {
    return this.metaTable;
  }
  getPlugins() {
    return this.plugins;
  }
  getRules() {
    return this.rules;
  }
  /**
   * Transform a source.
   *
   * When transforming zero or more new sources will be generated.
   *
   * @param source - Current source to transform.
   * @param filename - If set it is the filename used to match
   * transformer. Default is to use filename from source.
   * @returns A list of transformed sources ready for validation.
   */
  transformSource(source, filename) {
    const transformer = this.findTransformer(filename ?? source.filename);
    const context = {
      hasChain: (filename2) => {
        return !!this.findTransformer(filename2);
      },
      chain: (source2, filename2) => {
        return this.transformSource(source2, filename2);
      }
    };
    if (transformer) {
      try {
        return Array.from(transformer.fn.call(context, source), (cur) => {
          cur.transformedBy ??= [];
          cur.transformedBy.push(transformer.name);
          return cur;
        });
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        throw new NestedError(
          `When transforming "${source.filename}": ${message}`,
          ensureError(err)
        );
      }
    } else {
      return [source];
    }
  }
  /**
   * Wrapper around [[transformSource]] which reads a file before passing it
   * as-is to transformSource.
   *
   * @param filename - Filename to transform (according to configured
   * transformations)
   * @returns A list of transformed sources ready for validation.
   */
  transformFilename(filename) {
    const stdin = 0;
    const src = filename !== "/dev/stdin" ? filename : stdin;
    const data = fs__default.default.readFileSync(src, { encoding: "utf8" });
    const source = {
      data,
      filename,
      line: 1,
      column: 1,
      offset: 0,
      originalData: data
    };
    return this.transformSource(source);
  }
  /**
   * Returns true if a transformer matches given filename.
   */
  canTransform(filename) {
    const entry = this.findTransformer(filename);
    return !!entry;
  }
  findTransformer(filename) {
    const match = this.transformers.find((entry) => entry.pattern.test(filename));
    return match ?? null;
  }
}

function haveResolver(key, value) {
  return key in value;
}
function haveConfigResolver(value) {
  return haveResolver("resolveConfig", value);
}
function haveElementsResolver(value) {
  return haveResolver("resolveElements", value);
}
function havePluginResolver(value) {
  return haveResolver("resolvePlugin", value);
}
function haveTransformerResolver(value) {
  return haveResolver("resolveTransformer", value);
}
function resolveConfig(resolvers, id, options) {
  for (const resolver of resolvers.filter(haveConfigResolver)) {
    const config = resolver.resolveConfig(id, options);
    if (config) {
      return config;
    }
  }
  throw new UserError(`Failed to load configuration from "${id}"`);
}
function resolveElements(resolvers, id, options) {
  for (const resolver of resolvers.filter(haveElementsResolver)) {
    const elements = resolver.resolveElements(id, options);
    if (elements) {
      return elements;
    }
  }
  throw new UserError(`Failed to load elements from "${id}"`);
}
function resolvePlugin(resolvers, id, options) {
  for (const resolver of resolvers.filter(havePluginResolver)) {
    const plugin = resolver.resolvePlugin(id, options);
    if (plugin) {
      return plugin;
    }
  }
  throw new UserError(`Failed to load plugin from "${id}"`);
}
function resolveTransformer(resolvers, id, options) {
  for (const resolver of resolvers.filter(haveTransformerResolver)) {
    const transformer = resolver.resolveTransformer(id, options);
    if (transformer) {
      return transformer;
    }
  }
  throw new UserError(`Failed to load transformer from "${id}"`);
}

function staticResolver(map = {}) {
  const { elements = {}, configs = {}, plugins = {}, transformers = {} } = map;
  return {
    name: "static-qresolver",
    addElements(id, value) {
      elements[id] = value;
    },
    addConfig(id, value) {
      configs[id] = value;
    },
    addPlugin(id, value) {
      plugins[id] = value;
    },
    addTransformer(id, value) {
      transformers[id] = value;
    },
    resolveElements(id) {
      return elements[id] ?? null;
    },
    resolveConfig(id) {
      return configs[id] ?? null;
    },
    resolvePlugin(id) {
      return plugins[id] ?? null;
    },
    resolveTransformer(id) {
      return transformers[id] ?? null;
    }
  };
}

const ajv = new Ajv__default.default({ strict: true, strictTuples: true, strictTypes: true });
ajv.addMetaSchema(ajvSchemaDraft);
const validator = ajv.compile(configurationSchema);
function overwriteMerge(a, b) {
  return b;
}
function mergeInternal(base, rhs) {
  const dst = deepmerge$1(base, { ...rhs, rules: {} });
  if (rhs.rules) {
    dst.rules = deepmerge$1(dst.rules, rhs.rules, { arrayMerge: overwriteMerge });
  }
  const root = Boolean(base.root) || Boolean(rhs.root);
  if (root) {
    dst.root = root;
  }
  return dst;
}
function toArray(value) {
  if (Array.isArray(value)) {
    return value;
  } else {
    return [value];
  }
}
class Config {
  /**
   * @internal
   */
  constructor(resolvers, options) {
    this.transformers = [];
    const initial = {
      extends: [],
      plugins: [],
      rules: {},
      transform: {}
    };
    this.config = mergeInternal(initial, options);
    this.configurations = /* @__PURE__ */ new Map();
    this.initialized = false;
    this.resolvers = toArray(resolvers);
    this.metaTable = null;
    this.plugins = [];
  }
  /**
   * Create a new blank configuration. See also `Config.defaultConfig()`.
   */
  static empty() {
    return Config.create([], {
      extends: [],
      rules: {},
      plugins: [],
      transform: {}
    });
  }
  /**
   * Create configuration from object.
   */
  static fromObject(resolvers, options, filename = null) {
    Config.validate(options, filename);
    return Config.create(resolvers, options);
  }
  /**
   * Read configuration from filename.
   *
   * Note: this reads configuration data from a file. If you intent to load
   * configuration for a file to validate use `ConfigLoader.fromTarget()`.
   *
   * @internal
   * @param filename - The file to read from
   */
  static fromFile(resolvers, filename) {
    const configData = resolveConfig(toArray(resolvers), filename, { cache: false });
    return Config.fromObject(resolvers, configData, filename);
  }
  /**
   * Validate configuration data.
   *
   * Throws SchemaValidationError if invalid.
   *
   * @internal
   */
  static validate(configData, filename = null) {
    const valid = validator(configData);
    if (!valid) {
      throw new SchemaValidationError(
        filename,
        `Invalid configuration`,
        configData,
        configurationSchema,
        /* istanbul ignore next: will be set when a validation error has occurred */
        validator.errors ?? []
      );
    }
    if (configData.rules) {
      const normalizedRules = Config.getRulesObject(configData.rules);
      for (const [ruleId, [, ruleOptions]] of normalizedRules.entries()) {
        const cls = bundledRules[ruleId];
        const path = `/rules/${ruleId}/1`;
        Rule.validateOptions(cls, ruleId, path, ruleOptions, filename, configData);
      }
    }
  }
  /**
   * Load a default configuration object.
   */
  static defaultConfig() {
    return Config.create([], defaultConfig);
  }
  /**
   * @internal
   */
  static create(resolvers, options) {
    const instance = new Config(resolvers, options);
    instance.plugins = instance.loadPlugins(instance.config.plugins ?? []);
    instance.configurations = instance.loadConfigurations(instance.plugins);
    instance.extendMeta(instance.plugins);
    instance.config = instance.extendConfig(instance.config.extends ?? []);
    instance.config.extends = [];
    if (options.rules) {
      instance.config = mergeInternal(instance.config, { rules: options.rules });
    }
    return instance;
  }
  /**
   * Initialize plugins, transforms etc.
   *
   * Must be called before trying to use config. Can safely be called multiple
   * times.
   *
   * @public
   */
  init() {
    if (this.initialized) {
      return;
    }
    this.transformers = this.precompileTransformers(this.config.transform ?? {});
    this.initialized = true;
  }
  /**
   * Returns true if this configuration is marked as "root".
   */
  isRootFound() {
    return Boolean(this.config.root);
  }
  /**
   * Returns a new configuration as a merge of the two. Entries from the passed
   * object takes priority over this object.
   *
   * @public
   * @param rhs - Configuration to merge with this one.
   */
  merge(resolvers, rhs) {
    return Config.create(resolvers, mergeInternal(this.config, rhs.config));
  }
  extendConfig(entries) {
    if (entries.length === 0) {
      return this.config;
    }
    let base = {};
    for (const entry of entries) {
      let extended;
      if (this.configurations.has(entry)) {
        extended = this.configurations.get(entry);
      } else {
        extended = Config.fromFile(this.resolvers, entry).config;
      }
      base = mergeInternal(base, extended);
    }
    return mergeInternal(base, this.config);
  }
  /**
   * Get element metadata.
   *
   * @internal
   */
  getMetaTable() {
    if (this.metaTable) {
      return this.metaTable;
    }
    const metaTable = new MetaTable();
    const source = this.config.elements ?? ["html5"];
    for (const plugin of this.getPlugins()) {
      if (plugin.elementSchema) {
        metaTable.extendValidationSchema(plugin.elementSchema);
      }
    }
    for (const entry of source) {
      if (typeof entry !== "string") {
        metaTable.loadFromObject(entry);
        continue;
      }
      const bundled = elements.bundledElements[entry];
      if (bundled) {
        metaTable.loadFromObject(bundled);
        continue;
      }
      try {
        const data = resolveElements(this.resolvers, entry, { cache: false });
        metaTable.loadFromObject(data, entry);
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        throw new ConfigError(
          `Failed to load elements from "${entry}": ${message}`,
          ensureError(err)
        );
      }
    }
    metaTable.init();
    return this.metaTable = metaTable;
  }
  /**
   * Get a copy of internal configuration data.
   *
   * @internal primary purpose is unittests
   */
  /* istanbul ignore next: used for testing only */
  get() {
    return { ...this.config };
  }
  /**
   * Get all configured rules, their severity and options.
   *
   * @internal
   */
  getRules() {
    return Config.getRulesObject(this.config.rules ?? {});
  }
  static getRulesObject(src) {
    const rules = /* @__PURE__ */ new Map();
    for (const [ruleId, data] of Object.entries(src)) {
      let options = data;
      if (!Array.isArray(options)) {
        options = [options, {}];
      } else if (options.length === 1) {
        options = [options[0], {}];
      }
      const severity = parseSeverity(options[0]);
      rules.set(ruleId, [severity, options[1]]);
    }
    return rules;
  }
  /**
   * Get all configured plugins.
   *
   * @internal
   */
  getPlugins() {
    return this.plugins;
  }
  loadPlugins(plugins) {
    return plugins.map((moduleName, index) => {
      if (typeof moduleName !== "string") {
        const plugin = moduleName;
        plugin.name = plugin.name || `:unnamedPlugin@${String(index + 1)}`;
        plugin.originalName = `:unnamedPlugin@${String(index + 1)}`;
        return plugin;
      }
      try {
        const plugin = resolvePlugin(this.resolvers, moduleName, { cache: true });
        plugin.name = plugin.name || moduleName;
        plugin.originalName = moduleName;
        return plugin;
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        throw new ConfigError(
          `Failed to load plugin "${moduleName}": ${message}`,
          ensureError(err)
        );
      }
    });
  }
  loadConfigurations(plugins) {
    const configs = /* @__PURE__ */ new Map();
    for (const [name, config] of Object.entries(Presets)) {
      Config.validate(config, name);
      configs.set(name, config);
    }
    for (const plugin of plugins) {
      for (const [name, config] of Object.entries(plugin.configs ?? {})) {
        if (!config)
          continue;
        Config.validate(config, name);
        configs.set(`${plugin.name}:${name}`, config);
        if (plugin.name !== plugin.originalName) {
          configs.set(`${plugin.originalName}:${name}`, config);
        }
      }
    }
    return configs;
  }
  extendMeta(plugins) {
    for (const plugin of plugins) {
      if (!plugin.elementSchema) {
        continue;
      }
      const { properties } = plugin.elementSchema;
      if (!properties) {
        continue;
      }
      for (const [raw, schema2] of Object.entries(properties)) {
        const key = raw;
        if (schema2.copyable && !MetaCopyableProperty.includes(key)) {
          MetaCopyableProperty.push(key);
        }
      }
    }
  }
  /**
   * Resolve all configuration and return a [[ResolvedConfig]] instance.
   *
   * A resolved configuration will merge all extended configs and load all
   * plugins and transformers, and normalize the rest of the configuration.
   *
   * @public
   */
  resolve() {
    return new ResolvedConfig(this.resolveData(), this.get());
  }
  /**
   * Same as [[resolve]] but returns the raw configuration data instead of
   * [[ResolvedConfig]] instance. Mainly used for testing.
   *
   * @internal
   */
  resolveData() {
    return {
      metaTable: this.getMetaTable(),
      plugins: this.getPlugins(),
      rules: this.getRules(),
      transformers: this.transformers
    };
  }
  precompileTransformers(transform) {
    return Object.entries(transform).map(([pattern, name]) => {
      try {
        const fn = this.getTransformFunction(name);
        const version = fn.api ?? 0;
        if (version !== TRANSFORMER_API.VERSION) {
          throw new ConfigError(
            `Transformer uses API version ${String(version)} but only version ${String(TRANSFORMER_API.VERSION)} is supported`
          );
        }
        return {
          // eslint-disable-next-line security/detect-non-literal-regexp -- expected to be a regexp
          pattern: new RegExp(pattern),
          name,
          fn
        };
      } catch (err) {
        if (err instanceof ConfigError) {
          throw new ConfigError(`Failed to load transformer "${name}": ${err.message}`, err);
        } else {
          throw new ConfigError(`Failed to load transformer "${name}"`, ensureError(err));
        }
      }
    });
  }
  /**
   * Get transformation function requested by configuration.
   *
   * Searches:
   *
   * - Named transformers from plugins.
   * - Unnamed transformer from plugin.
   * - Standalone modules (local or node_modules)
   *
   * @param name - Key from configuration
   */
  getTransformFunction(name) {
    const match = name.match(/(.*):(.*)/);
    if (match) {
      const [, pluginName, key] = match;
      return this.getNamedTransformerFromPlugin(name, pluginName, key);
    }
    const plugin = this.plugins.find((cur) => cur.name === name);
    if (plugin) {
      return this.getUnnamedTransformerFromPlugin(name, plugin);
    }
    return this.getTransformerFromModule(name);
  }
  /**
   * @param name - Original name from configuration
   * @param pluginName - Name of plugin
   * @param key - Name of transform (from plugin)
   */
  getNamedTransformerFromPlugin(name, pluginName, key) {
    const plugin = this.plugins.find((cur) => cur.name === pluginName);
    if (!plugin) {
      throw new ConfigError(`No plugin named "${pluginName}" has been loaded`);
    }
    if (!plugin.transformer) {
      throw new ConfigError(`Plugin does not expose any transformer`);
    }
    if (typeof plugin.transformer === "function") {
      throw new ConfigError(
        `Transformer "${name}" refers to named transformer but plugin exposes only unnamed, use "${pluginName}" instead.`
      );
    }
    const transformer = plugin.transformer[key];
    if (!transformer) {
      throw new ConfigError(`Plugin "${pluginName}" does not expose a transformer named "${key}".`);
    }
    return transformer;
  }
  /**
   * @param name - Original name from configuration
   * @param plugin - Plugin instance
   */
  getUnnamedTransformerFromPlugin(name, plugin) {
    if (!plugin.transformer) {
      throw new ConfigError(`Plugin does not expose any transformer`);
    }
    if (typeof plugin.transformer !== "function") {
      if (plugin.transformer.default) {
        return plugin.transformer.default;
      }
      throw new ConfigError(
        `Transformer "${name}" refers to unnamed transformer but plugin exposes only named.`
      );
    }
    return plugin.transformer;
  }
  getTransformerFromModule(name) {
    return resolveTransformer(this.resolvers, name, { cache: true });
  }
}

class ConfigLoader {
  constructor(resolvers, config) {
    const defaults = Config.empty();
    this.resolvers = resolvers;
    this.globalConfig = defaults.merge(
      this.resolvers,
      config ? this.loadFromObject(config) : this.defaultConfig()
    );
  }
  /**
   * @internal For testing only
   */
  _getGlobalConfig() {
    return this.globalConfig.get();
  }
  empty() {
    return Config.empty();
  }
  loadFromObject(options, filename) {
    return Config.fromObject(this.resolvers, options, filename);
  }
  loadFromFile(filename) {
    return Config.fromFile(this.resolvers, filename);
  }
}

function defineConfig(config) {
  return config;
}

class EventHandler {
  constructor() {
    this.listeners = {};
  }
  /**
   * Add an event listener.
   *
   * @param event - Event names (comma separated) or '*' for any event.
   * @param callback - Called any time even triggers.
   * @returns Unregistration function.
   */
  on(event, callback) {
    const { listeners } = this;
    const names = event.split(",").map((it) => it.trim());
    for (const name of names) {
      const list = listeners[name] ?? [];
      listeners[name] = list;
      list.push(callback);
    }
    return () => {
      for (const name of names) {
        const list = listeners[name];
        this.listeners[name] = list.filter((fn) => fn !== callback);
      }
    };
  }
  /**
   * Add a onetime event listener. The listener will automatically be removed
   * after being triggered once.
   *
   * @param event - Event names (comma separated) or '*' for any event.
   * @param callback - Called any time even triggers.
   * @returns Unregistration function.
   */
  once(event, callback) {
    const deregister = this.on(event, (event2, data) => {
      callback(event2, data);
      deregister();
    });
    return deregister;
  }
  /**
   * Trigger event causing all listeners to be called.
   *
   * @param event - Event name.
   * @param data - Event data.
   */
  trigger(event, data) {
    for (const listener of this.getCallbacks(event)) {
      listener.call(null, event, data);
    }
  }
  getCallbacks(event) {
    const { listeners } = this;
    const callbacks = listeners[event] ?? [];
    const global = listeners["*"] ?? [];
    return [...callbacks, ...global];
  }
}

const regexp = /<!(?:--)?\[(.*?)\](?:--)?>/g;
function* parseConditionalComment(comment, commentLocation) {
  let match;
  while ((match = regexp.exec(comment)) !== null) {
    const expression = match[1];
    const begin = match.index;
    const end = begin + match[0].length;
    const location = sliceLocation(commentLocation, begin, end, comment);
    yield {
      expression,
      location
    };
  }
}

class ParserError extends Error {
  constructor(location, message) {
    super(message);
    this.location = location;
  }
}

function isAttrValueToken(token) {
  return Boolean(token && token.type === TokenType.ATTR_VALUE);
}
function svgShouldRetainTag(foreignTagName, tagName) {
  return foreignTagName === "svg" && ["title", "desc"].includes(tagName);
}
function isValidDirective(action) {
  const validActions = ["enable", "disable", "disable-block", "disable-next"];
  return validActions.includes(action);
}
class Parser {
  /**
   * Create a new parser instance.
   *
   * @public
   * @param config - Configuration
   */
  constructor(config) {
    this.currentNamespace = "";
    this.event = new EventHandler();
    this.dom = null;
    this.metaTable = config.getMetaTable();
  }
  /**
   * Parse HTML markup.
   *
   * @public
   * @param source - HTML markup.
   * @returns DOM tree representing the HTML markup.
   */
  parseHtml(source) {
    if (typeof source === "string") {
      source = {
        data: source,
        filename: "inline",
        line: 1,
        column: 1,
        offset: 0
      };
    }
    this.trigger("parse:begin", {
      location: null
    });
    this.dom = new DOMTree({
      filename: source.filename,
      offset: source.offset,
      line: source.line,
      column: source.column,
      size: 0
    });
    this.trigger("dom:load", {
      source,
      location: null
    });
    const lexer = new Lexer();
    const tokenStream = lexer.tokenize(source);
    let it = this.next(tokenStream);
    while (!it.done) {
      const token = it.value;
      this.consume(source, token, tokenStream);
      it = this.next(tokenStream);
    }
    this.dom.resolveMeta(this.metaTable);
    this.dom.root.cacheEnable();
    this.trigger("dom:ready", {
      document: this.dom,
      source,
      /* disable location for this event so rules can use implicit node location
       * instead */
      location: null
    });
    this.trigger("parse:end", {
      location: null
    });
    return this.dom.root;
  }
  /**
   * Detect optional end tag.
   *
   * Some tags have optional end tags (e.g. <ul><li>foo<li>bar</ul> is
   * valid). The parser handles this by checking if the element on top of the
   * stack when is allowed to omit.
   */
  closeOptional(token) {
    var _a;
    const active = this.dom.getActive();
    if (!((_a = active.meta) == null ? void 0 : _a.implicitClosed)) {
      return false;
    }
    const tagName = token.data[2];
    const open = !token.data[1];
    const meta = active.meta.implicitClosed;
    if (open) {
      return meta.includes(tagName);
    } else {
      if (active.is(tagName)) {
        return false;
      }
      return Boolean(active.parent && active.parent.is(tagName) && meta.includes(active.tagName));
    }
  }
  /**
   * @internal
   */
  /* eslint-disable-next-line complexity -- there isn't really a good other way to structure this method (that is still readable) */
  consume(source, token, tokenStream) {
    switch (token.type) {
      case TokenType.UNICODE_BOM:
        break;
      case TokenType.TAG_OPEN:
        this.consumeTag(source, token, tokenStream);
        break;
      case TokenType.WHITESPACE:
        this.trigger("whitespace", {
          text: token.data[0],
          location: token.location
        });
        this.appendText(token.data[0], token.location);
        break;
      case TokenType.DIRECTIVE:
        this.consumeDirective(token);
        break;
      case TokenType.CONDITIONAL:
        this.consumeConditional(token);
        break;
      case TokenType.COMMENT:
        this.consumeComment(token);
        break;
      case TokenType.DOCTYPE_OPEN:
        this.consumeDoctype(token, tokenStream);
        break;
      case TokenType.TEXT:
      case TokenType.TEMPLATING:
        this.appendText(token.data[0], token.location);
        break;
      case TokenType.EOF:
        this.closeTree(source, token.location);
        break;
    }
  }
  /**
   * @internal
   */
  /* eslint-disable-next-line complexity, sonarjs/cognitive-complexity -- technical debt, chould be refactored a bit */
  consumeTag(source, startToken, tokenStream) {
    const tokens = Array.from(
      this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, startToken.location)
    );
    const endToken = tokens.slice(-1)[0];
    const closeOptional = this.closeOptional(startToken);
    const parent = closeOptional ? this.dom.getActive().parent : this.dom.getActive();
    const node = HtmlElement.fromTokens(
      startToken,
      endToken,
      parent,
      this.metaTable,
      this.currentNamespace
    );
    const isStartTag = !startToken.data[1];
    const isClosing = !isStartTag || node.closed !== NodeClosed.Open;
    const isForeign = node.meta && node.meta.foreign;
    if (closeOptional) {
      const active = this.dom.getActive();
      active.closed = NodeClosed.ImplicitClosed;
      this.closeElement(source, node, active, startToken.location);
      this.dom.popActive();
    }
    if (isStartTag) {
      this.dom.pushActive(node);
      this.trigger("tag:start", {
        target: node,
        location: startToken.location
      });
    }
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      switch (token.type) {
        case TokenType.WHITESPACE:
          break;
        case TokenType.ATTR_NAME:
          this.consumeAttribute(source, node, token, tokens[i + 1]);
          break;
      }
    }
    if (isStartTag) {
      this.trigger("tag:ready", {
        target: node,
        location: endToken.location
      });
    }
    if (isClosing) {
      const active = this.dom.getActive();
      if (!isStartTag) {
        node.closed = NodeClosed.EndTag;
      }
      this.closeElement(source, node, active, endToken.location);
      const voidClosed = !isStartTag && node.voidElement;
      if (!voidClosed) {
        this.dom.popActive();
      }
    } else if (isForeign) {
      this.discardForeignBody(source, node.tagName, tokenStream, startToken.location);
    }
  }
  /**
   * @internal
   */
  closeElement(source, node, active, location) {
    this.processElement(active, source);
    const event = {
      target: node,
      previous: active,
      location
    };
    this.trigger("tag:end", event);
    if (active && !active.isRootElement()) {
      this.trigger("element:ready", {
        target: active,
        location: active.location
      });
    }
  }
  processElement(node, source) {
    var _a;
    node.cacheEnable();
    if ((_a = source.hooks) == null ? void 0 : _a.processElement) {
      const processElement = source.hooks.processElement;
      const metaTable = this.metaTable;
      const context = {
        getMetaFor(tagName) {
          return metaTable.getMetaFor(tagName);
        }
      };
      processElement.call(context, node);
    }
  }
  /**
   * Discard tokens until the end tag for the foreign element is found.
   *
   * @internal
   */
  discardForeignBody(source, foreignTagName, tokenStream, errorLocation) {
    let nested = 1;
    let startToken;
    let endToken;
    do {
      const tokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_OPEN, errorLocation));
      const [last] = tokens.slice(-1);
      const [, tagClosed, tagName] = last.data;
      if (!tagClosed && svgShouldRetainTag(foreignTagName, tagName)) {
        const oldNamespace = this.currentNamespace;
        this.currentNamespace = "svg";
        this.consumeTag(source, last, tokenStream);
        this.consumeUntilMatchingTag(source, tokenStream, tagName);
        this.currentNamespace = oldNamespace;
        continue;
      }
      if (tagName !== foreignTagName) {
        continue;
      }
      const endTokens = Array.from(
        this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, last.location)
      );
      endToken = endTokens.slice(-1)[0];
      const selfClosed = endToken.data[0] === "/>";
      if (tagClosed) {
        startToken = last;
        nested--;
      } else if (!selfClosed) {
        nested++;
      }
    } while (nested > 0);
    if (!startToken || !endToken) {
      return;
    }
    const active = this.dom.getActive();
    const node = HtmlElement.fromTokens(startToken, endToken, active, this.metaTable);
    this.closeElement(source, node, active, endToken.location);
    this.dom.popActive();
  }
  /**
   * @internal
   */
  consumeAttribute(source, node, token, next) {
    var _a;
    const { meta } = node;
    const keyLocation = this.getAttributeKeyLocation(token);
    const valueLocation = this.getAttributeValueLocation(next);
    const location = this.getAttributeLocation(token, next);
    const haveValue = isAttrValueToken(next);
    const attrData = {
      key: token.data[1],
      value: null,
      quote: null
    };
    if (haveValue) {
      const [, , value, quote] = next.data;
      attrData.value = value;
      attrData.quote = quote ?? null;
    }
    let processAttribute = (attr) => [attr];
    if ((_a = source.hooks) == null ? void 0 : _a.processAttribute) {
      processAttribute = source.hooks.processAttribute;
    }
    let iterator;
    const legacy = processAttribute.call({}, attrData);
    if (typeof legacy[Symbol.iterator] !== "function") {
      iterator = [attrData];
    } else {
      iterator = legacy;
    }
    for (const attr of iterator) {
      const event = {
        target: node,
        key: attr.key,
        value: attr.value,
        quote: attr.quote,
        originalAttribute: attr.originalAttribute,
        location,
        keyLocation,
        valueLocation,
        meta: (meta == null ? void 0 : meta.attributes[attr.key]) ?? null
      };
      this.trigger("attr", event);
      node.setAttribute(attr.key, attr.value, keyLocation, valueLocation, attr.originalAttribute);
    }
  }
  /**
   * Takes attribute key token an returns location.
   */
  getAttributeKeyLocation(token) {
    return token.location;
  }
  /**
   * Take attribute value token and return a new location referring to only the
   * value.
   *
   * foo="bar"    foo='bar'    foo=bar    foo      foo=""
   *      ^^^          ^^^         ^^^    (null)   (null)
   */
  getAttributeValueLocation(token) {
    if (!token || token.type !== TokenType.ATTR_VALUE || token.data[2] === "") {
      return null;
    }
    const quote = token.data[3];
    if (quote) {
      return sliceLocation(token.location, 2, -1);
    } else {
      return sliceLocation(token.location, 1);
    }
  }
  /**
   * Take attribute key and value token an returns a new location referring to
   * an aggregate location covering key, quotes if present and value.
   */
  getAttributeLocation(key, value) {
    const begin = key.location;
    const end = value && value.type === TokenType.ATTR_VALUE ? value.location : void 0;
    return {
      filename: begin.filename,
      line: begin.line,
      column: begin.column,
      size: begin.size + ((end == null ? void 0 : end.size) ?? 0),
      offset: begin.offset
    };
  }
  /**
   * @internal
   */
  consumeDirective(token) {
    const [text, preamble, action, separator1, directive, postamble] = token.data;
    if (!postamble.startsWith("]")) {
      throw new ParserError(token.location, `Missing end bracket "]" on directive "${text}"`);
    }
    const match = directive.match(/^(.*?)(?:(\s*(?:--|:)\s*)(.*))?$/);
    if (!match) {
      throw new Error(`Failed to parse directive "${text}"`);
    }
    if (!isValidDirective(action)) {
      throw new ParserError(token.location, `Unknown directive "${action}"`);
    }
    const [, data, separator2, comment] = match;
    const prefix = "html-validate-";
    const actionOffset = preamble.length;
    const optionsOffset = actionOffset + action.length + separator1.length;
    const commentOffset = optionsOffset + data.length + (separator2 || "").length;
    const location = sliceLocation(
      token.location,
      preamble.length - prefix.length - 1,
      -postamble.length + 1
    );
    const actionLocation = sliceLocation(
      token.location,
      actionOffset,
      actionOffset + action.length
    );
    const optionsLocation = data ? sliceLocation(token.location, optionsOffset, optionsOffset + data.length) : void 0;
    const commentLocation = comment ? sliceLocation(token.location, commentOffset, commentOffset + comment.length) : void 0;
    this.trigger("directive", {
      action,
      data,
      comment: comment || "",
      location,
      actionLocation,
      optionsLocation,
      commentLocation
    });
  }
  /**
   * Consumes conditional comment in tag form.
   *
   * See also the related [[consumeCommend]] method.
   *
   * @internal
   */
  consumeConditional(token) {
    const element = this.dom.getActive();
    this.trigger("conditional", {
      condition: token.data[1],
      location: token.location,
      parent: element
    });
  }
  /**
   * Consumes comment token.
   *
   * Tries to find IE conditional comments and emits conditional token if
   * found. See also the related [[consumeConditional]] method.
   *
   * @internal
   */
  consumeComment(token) {
    const comment = token.data[0];
    const element = this.dom.getActive();
    for (const conditional of parseConditionalComment(comment, token.location)) {
      this.trigger("conditional", {
        condition: conditional.expression,
        location: conditional.location,
        parent: element
      });
    }
  }
  /**
   * Consumes doctype tokens. Emits doctype event.
   *
   * @internal
   */
  consumeDoctype(startToken, tokenStream) {
    const tokens = Array.from(
      this.consumeUntil(tokenStream, TokenType.DOCTYPE_CLOSE, startToken.location)
    );
    const doctype = tokens[0];
    const value = doctype.data[0];
    this.dom.doctype = value;
    this.trigger("doctype", {
      tag: startToken.data[1],
      value,
      valueLocation: tokens[0].location,
      location: startToken.location
    });
  }
  /**
   * Return a list of tokens found until the expected token was found.
   *
   * @internal
   * @param errorLocation - What location to use if an error occurs
   */
  *consumeUntil(tokenStream, search, errorLocation) {
    let it = this.next(tokenStream);
    while (!it.done) {
      const token = it.value;
      yield token;
      if (token.type === search)
        return;
      it = this.next(tokenStream);
    }
    throw new ParserError(
      errorLocation,
      `stream ended before ${TokenType[search]} token was found`
    );
  }
  /**
   * Consumes tokens until a matching close-tag is found. Tags are appended to
   * the document.
   *
   * @internal
   */
  consumeUntilMatchingTag(source, tokenStream, searchTag) {
    let numOpen = 1;
    let it = this.next(tokenStream);
    while (!it.done) {
      const token = it.value;
      this.consume(source, token, tokenStream);
      if (token.type === TokenType.TAG_OPEN) {
        const [, close, tagName] = token.data;
        if (tagName === searchTag) {
          if (close) {
            numOpen--;
          } else {
            numOpen++;
          }
          if (numOpen === 0) {
            return;
          }
        }
      }
      it = this.next(tokenStream);
    }
  }
  next(tokenStream) {
    const it = tokenStream.next();
    if (!it.done) {
      const token = it.value;
      this.trigger("token", {
        location: token.location,
        type: token.type,
        data: Array.from(token.data),
        token
      });
    }
    return it;
  }
  on(event, listener) {
    return this.event.on(event, listener);
  }
  once(event, listener) {
    return this.event.once(event, listener);
  }
  /**
   * Defer execution. Will call function sometime later.
   *
   * @internal
   * @param cb - Callback to execute later.
   */
  defer(cb) {
    this.event.once("*", cb);
  }
  trigger(event, data) {
    if (typeof data.location === "undefined") {
      throw new Error("Triggered event must contain location");
    }
    this.event.trigger(event, data);
  }
  /**
   * @internal
   */
  getEventHandler() {
    return this.event;
  }
  /**
   * Appends a text node to the current element on the stack.
   */
  appendText(text, location) {
    this.dom.getActive().appendText(text, location);
  }
  /**
   * Trigger close events for any still open elements.
   */
  closeTree(source, location) {
    let active;
    while ((active = this.dom.getActive()) && !active.isRootElement()) {
      this.closeElement(source, null, active, location);
      this.dom.popActive();
    }
  }
}

function isThenable(value) {
  return value && typeof value === "object" && "then" in value && typeof value.then === "function";
}

const ruleIds = new Set(Object.keys(bundledRules));
function ruleExists(ruleId) {
  return ruleIds.has(ruleId);
}

function freeze(src) {
  return {
    ...src,
    selector: src.selector()
  };
}
function isThenableArray(value) {
  if (value.length === 0) {
    return false;
  }
  return isThenable(value[0]);
}
class Reporter {
  constructor() {
    this.result = {};
  }
  static merge(reports) {
    if (isThenable(reports)) {
      return reports.then((reports2) => this.merge(reports2));
    }
    if (isThenableArray(reports)) {
      return Promise.all(reports).then((reports2) => this.merge(reports2));
    }
    const valid = reports.every((report) => report.valid);
    const merged = {};
    reports.forEach((report) => {
      report.results.forEach((result) => {
        const key = result.filePath;
        if (key in merged) {
          merged[key].messages = [...merged[key].messages, ...result.messages];
        } else {
          merged[key] = { ...result };
        }
      });
    });
    const results = Object.values(merged).map((result) => {
      result.errorCount = countErrors(result.messages);
      result.warningCount = countWarnings(result.messages);
      return result;
    });
    return {
      valid,
      results,
      errorCount: sumErrors(results),
      warningCount: sumWarnings(results)
    };
  }
  add(rule, message, severity, node, location, context) {
    var _a;
    if (!(location.filename in this.result)) {
      this.result[location.filename] = [];
    }
    const ruleUrl = (_a = rule.documentation(context)) == null ? void 0 : _a.url;
    const entry = {
      ruleId: rule.name,
      severity,
      message,
      offset: location.offset,
      line: location.line,
      column: location.column,
      size: location.size || 0,
      selector() {
        return node ? node.generateSelector() : null;
      }
    };
    if (ruleUrl) {
      entry.ruleUrl = ruleUrl;
    }
    if (context) {
      entry.context = context;
    }
    this.result[location.filename].push(entry);
  }
  addManual(filename, message) {
    if (!(filename in this.result)) {
      this.result[filename] = [];
    }
    this.result[filename].push(message);
  }
  save(sources) {
    const report = {
      valid: this.isValid(),
      results: Object.keys(this.result).map((filePath) => {
        const messages = Array.from(this.result[filePath], freeze).sort(messageSort);
        const source = (sources ?? []).find((source2) => filePath === source2.filename);
        return {
          filePath,
          messages,
          errorCount: countErrors(messages),
          warningCount: countWarnings(messages),
          source: source ? source.originalData ?? source.data : null
        };
      }),
      errorCount: 0,
      warningCount: 0
    };
    report.errorCount = sumErrors(report.results);
    report.warningCount = sumWarnings(report.results);
    return report;
  }
  isValid() {
    const numErrors = Object.values(this.result).reduce((sum, messages) => {
      return sum + countErrors(messages);
    }, 0);
    return numErrors === 0;
  }
}
function countErrors(messages) {
  return messages.filter((m) => m.severity === Number(Severity.ERROR)).length;
}
function countWarnings(messages) {
  return messages.filter((m) => m.severity === Number(Severity.WARN)).length;
}
function sumErrors(results) {
  return results.reduce((sum, result) => {
    return sum + result.errorCount;
  }, 0);
}
function sumWarnings(results) {
  return results.reduce((sum, result) => {
    return sum + result.warningCount;
  }, 0);
}
function messageSort(a, b) {
  if (a.line < b.line) {
    return -1;
  }
  if (a.line > b.line) {
    return 1;
  }
  if (a.column < b.column) {
    return -1;
  }
  if (a.column > b.column) {
    return 1;
  }
  return 0;
}

let blockerCounter = 1;
function createBlocker() {
  const id = blockerCounter++;
  return id;
}

class Engine {
  constructor(config, ParserClass) {
    this.report = new Reporter();
    this.config = config;
    this.ParserClass = ParserClass;
    const result = this.initPlugins(this.config);
    this.availableRules = {
      ...bundledRules,
      ...result.availableRules
    };
  }
  /**
   * Lint sources and return report
   *
   * @param sources - Sources to lint.
   * @returns Report output.
   */
  lint(sources) {
    for (const source of sources) {
      const parser = this.instantiateParser();
      const { rules } = this.setupPlugins(source, this.config, parser);
      const noUnusedDisable = rules["no-unused-disable"];
      const directiveContext = {
        rules,
        reportUnused(rules2, unused, options, location2) {
          if (noUnusedDisable && !rules2.has(noUnusedDisable.name)) {
            noUnusedDisable.reportUnused(unused, options, location2);
          }
        }
      };
      const location = {
        filename: source.filename,
        line: 1,
        column: 1,
        offset: 0,
        size: 1
      };
      const configEvent = {
        location,
        config: this.config,
        rules
      };
      parser.trigger("config:ready", configEvent);
      const { hooks: _, ...sourceData } = source;
      const sourceEvent = {
        location,
        source: sourceData
      };
      parser.trigger("source:ready", sourceEvent);
      parser.on("directive", (_2, event) => {
        this.processDirective(event, parser, directiveContext);
      });
      try {
        parser.parseHtml(source);
      } catch (e) {
        if (e instanceof InvalidTokenError || e instanceof ParserError) {
          this.reportError("parser-error", e.message, e.location);
        } else {
          throw e;
        }
      }
    }
    return this.report.save(sources);
  }
  /**
   * Returns a list of all events generated while parsing the source.
   *
   * For verbosity, token events are ignored (use [[dumpTokens]] to inspect
   * token stream).
   */
  dumpEvents(source) {
    const parser = this.instantiateParser();
    const lines = [];
    parser.on("*", (event, data) => {
      if (event === "token") {
        return;
      }
      lines.push({ event, data });
    });
    source.forEach((src) => parser.parseHtml(src));
    return lines;
  }
  dumpTokens(source) {
    const lexer = new Lexer();
    const lines = [];
    for (const src of source) {
      for (const token of lexer.tokenize(src)) {
        const data = token.data[0] ?? "";
        const filename = token.location.filename;
        const line = String(token.location.line);
        const column = String(token.location.column);
        lines.push({
          token: TokenType[token.type],
          data,
          location: `${filename}:${line}:${column}`
        });
      }
    }
    return lines;
  }
  dumpTree(source) {
    const parser = this.instantiateParser();
    const document = parser.parseHtml(source[0]);
    const lines = [];
    function decoration(node) {
      let output = "";
      if (node.id) {
        output += `#${node.id}`;
      }
      if (node.hasAttribute("class")) {
        output += `.${node.classList.join(".")}`;
      }
      return output;
    }
    function writeNode(node, level, sibling) {
      if (node.parent) {
        const indent = "  ".repeat(level - 1);
        const l = node.childElements.length > 0 ? "\u252C" : "\u2500";
        const b = sibling < node.parent.childElements.length - 1 ? "\u251C" : "\u2514";
        lines.push(`${indent}${b}\u2500${l} ${node.tagName}${decoration(node)}`);
      } else {
        lines.push("(root)");
      }
      node.childElements.forEach((child, index) => {
        writeNode(child, level + 1, index);
      });
    }
    writeNode(document, 0, 0);
    return lines;
  }
  /**
   * Get rule documentation.
   */
  getRuleDocumentation({
    ruleId,
    context
  }) {
    const rules = this.config.getRules();
    const ruleData = rules.get(ruleId);
    if (ruleData) {
      const [, options] = ruleData;
      const rule = this.instantiateRule(ruleId, options);
      return rule.documentation(context);
    } else {
      return null;
    }
  }
  /**
   * Create a new parser instance with the current configuration.
   *
   * @internal
   */
  instantiateParser() {
    return new this.ParserClass(this.config);
  }
  processDirective(event, parser, context) {
    const rules = event.data.split(",").map((name) => name.trim()).map((name) => context.rules[name]).filter((rule) => rule);
    const location = event.optionsLocation ?? event.location;
    switch (event.action) {
      case "enable":
        this.processEnableDirective(rules, parser);
        break;
      case "disable":
        this.processDisableDirective(rules, parser);
        break;
      case "disable-block":
        this.processDisableBlockDirective(context, rules, parser, event.data, location);
        break;
      case "disable-next":
        this.processDisableNextDirective(context, rules, parser, event.data, location);
        break;
    }
  }
  processEnableDirective(rules, parser) {
    for (const rule of rules) {
      rule.setEnabled(true);
      if (rule.getSeverity() === Severity.DISABLED) {
        rule.setServerity(Severity.ERROR);
      }
    }
    parser.on("tag:start", (event, data) => {
      data.target.enableRules(rules.map((rule) => rule.name));
    });
  }
  processDisableDirective(rules, parser) {
    for (const rule of rules) {
      rule.setEnabled(false);
    }
    parser.on("tag:start", (event, data) => {
      data.target.disableRules(rules.map((rule) => rule.name));
    });
  }
  processDisableBlockDirective(context, rules, parser, options, location) {
    const ruleIds = new Set(rules.map((it) => it.name));
    const unused = new Set(ruleIds);
    const blocker = createBlocker();
    let directiveBlock = null;
    for (const rule of rules) {
      rule.block(blocker);
    }
    const unregisterOpen = parser.on("tag:start", (event, data) => {
      var _a;
      if (directiveBlock === null) {
        directiveBlock = ((_a = data.target.parent) == null ? void 0 : _a.unique) ?? null;
      }
      data.target.blockRules(ruleIds, blocker);
    });
    const unregisterClose = parser.on("tag:end", (event, data) => {
      const lastNode = directiveBlock === null;
      const parentClosed = directiveBlock === data.previous.unique;
      if (lastNode || parentClosed) {
        unregisterClose();
        unregisterOpen();
        for (const rule of rules) {
          rule.unblock(blocker);
        }
      }
    });
    parser.on("rule:error", (event, data) => {
      if (data.blockers.includes(blocker)) {
        unused.delete(data.ruleId);
      }
    });
    parser.on("parse:end", () => {
      context.reportUnused(ruleIds, unused, options, location);
    });
  }
  processDisableNextDirective(context, rules, parser, options, location) {
    const ruleIds = new Set(rules.map((it) => it.name));
    const unused = new Set(ruleIds);
    const blocker = createBlocker();
    for (const rule of rules) {
      rule.block(blocker);
    }
    const unregister = parser.on("tag:start", (event, data) => {
      data.target.blockRules(ruleIds, blocker);
    });
    parser.on("rule:error", (event, data) => {
      if (data.blockers.includes(blocker)) {
        unused.delete(data.ruleId);
      }
    });
    parser.on("parse:end", () => {
      context.reportUnused(ruleIds, unused, options, location);
    });
    parser.once("tag:ready, tag:end, attr", () => {
      unregister();
      parser.defer(() => {
        for (const rule of rules) {
          rule.unblock(blocker);
        }
      });
    });
  }
  /*
   * Initialize all plugins. This should only be done once for all sessions.
   */
  initPlugins(config) {
    for (const plugin of config.getPlugins()) {
      if (plugin.init) {
        plugin.init();
      }
    }
    return {
      availableRules: this.initRules(config)
    };
  }
  /**
   * Initializes all rules from plugins and returns an object with a mapping
   * between rule name and its constructor.
   */
  initRules(config) {
    const availableRules = {};
    for (const plugin of config.getPlugins()) {
      for (const [name, rule] of Object.entries(plugin.rules ?? {})) {
        if (!rule)
          continue;
        availableRules[name] = rule;
      }
    }
    return availableRules;
  }
  /**
   * Setup all plugins for this session.
   */
  setupPlugins(source, config, parser) {
    const eventHandler = parser.getEventHandler();
    for (const plugin of config.getPlugins()) {
      if (plugin.setup) {
        plugin.setup(source, eventHandler);
      }
    }
    return {
      rules: this.setupRules(config, parser)
    };
  }
  /**
   * Load and setup all rules for current configuration.
   */
  setupRules(config, parser) {
    const rules = {};
    for (const [ruleId, [severity, options]] of config.getRules().entries()) {
      rules[ruleId] = this.loadRule(ruleId, config, severity, options, parser, this.report);
    }
    return rules;
  }
  /**
   * Load and setup a rule using current config.
   */
  loadRule(ruleId, config, severity, options, parser, report) {
    const meta = config.getMetaTable();
    const rule = this.instantiateRule(ruleId, options);
    rule.name = ruleId;
    rule.init(parser, report, severity, meta);
    if (rule.setup) {
      rule.setup();
    }
    return rule;
  }
  instantiateRule(name, options) {
    if (this.availableRules[name]) {
      const RuleConstructor = this.availableRules[name];
      return new RuleConstructor(options);
    } else {
      return this.missingRule(name);
    }
  }
  missingRule(name) {
    return new class MissingRule extends Rule {
      setup() {
        this.on("dom:load", () => {
          this.report(null, `Definition for rule '${name}' was not found`);
        });
      }
    }();
  }
  reportError(ruleId, message, location) {
    this.report.addManual(location.filename, {
      ruleId,
      severity: Severity.ERROR,
      message,
      offset: location.offset,
      line: location.line,
      column: location.column,
      size: location.size,
      selector: () => null
    });
  }
}

const defaultResolvers = [];
function hasResolver(value) {
  return Array.isArray(value[0]);
}
class StaticConfigLoader extends ConfigLoader {
  constructor(...args) {
    if (hasResolver(args)) {
      const [resolvers, config] = args;
      super(resolvers, config);
    } else {
      const [config] = args;
      super(defaultResolvers, config);
    }
  }
  getConfigFor(_handle, configOverride) {
    const override = this.loadFromObject(configOverride ?? {});
    if (override.isRootFound()) {
      override.init();
      return override.resolve();
    }
    const merged = this.globalConfig.merge(this.resolvers, override);
    merged.init();
    return merged.resolve();
  }
  flushCache() {
  }
  defaultConfig() {
    return this.loadFromObject({
      extends: ["html-validate:recommended"],
      elements: ["html5"]
    });
  }
}

function isSourceHooks(value) {
  if (!value || typeof value === "string") {
    return false;
  }
  return Boolean(value.processAttribute || value.processElement);
}
function isConfigData(value) {
  if (!value || typeof value === "string") {
    return false;
  }
  return !(value.processAttribute || value.processElement);
}
class HtmlValidate {
  constructor(arg) {
    const [loader, config] = arg instanceof ConfigLoader ? [arg, void 0] : [void 0, arg];
    this.configLoader = loader ?? new StaticConfigLoader(config);
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  validateString(str, arg1, arg2, arg3) {
    const filename = typeof arg1 === "string" ? arg1 : "inline";
    const options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : void 0;
    const hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
    const source = {
      data: str,
      filename,
      line: 1,
      column: 1,
      offset: 0,
      hooks
    };
    return this.validateSource(source, options);
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  validateStringSync(str, arg1, arg2, arg3) {
    const filename = typeof arg1 === "string" ? arg1 : "inline";
    const options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : void 0;
    const hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
    const source = {
      data: str,
      filename,
      line: 1,
      column: 1,
      offset: 0,
      hooks
    };
    return this.validateSourceSync(source, options);
  }
  /**
   * Parse and validate HTML from [[Source]].
   *
   * @public
   * @param input - Source to parse.
   * @returns Report output.
   */
  async validateSource(input, configOverride) {
    const source = normalizeSource(input);
    const config = await this.getConfigFor(source.filename, configOverride);
    const transformedSource = config.transformSource(source);
    const engine = new Engine(config, Parser);
    return engine.lint(transformedSource);
  }
  /**
   * Parse and validate HTML from [[Source]].
   *
   * @public
   * @param input - Source to parse.
   * @returns Report output.
   */
  validateSourceSync(input, configOverride) {
    const source = normalizeSource(input);
    const config = this.getConfigForSync(source.filename, configOverride);
    const transformedSource = config.transformSource(source);
    const engine = new Engine(config, Parser);
    return engine.lint(transformedSource);
  }
  /**
   * Parse and validate HTML from file.
   *
   * @public
   * @param filename - Filename to read and parse.
   * @returns Report output.
   */
  async validateFile(filename) {
    const config = await this.getConfigFor(filename);
    const source = config.transformFilename(filename);
    const engine = new Engine(config, Parser);
    return Promise.resolve(engine.lint(source));
  }
  /**
   * Parse and validate HTML from file.
   *
   * @public
   * @param filename - Filename to read and parse.
   * @returns Report output.
   */
  validateFileSync(filename) {
    const config = this.getConfigForSync(filename);
    const source = config.transformFilename(filename);
    const engine = new Engine(config, Parser);
    return engine.lint(source);
  }
  /**
   * Parse and validate HTML from multiple files. Result is merged together to a
   * single report.
   *
   * @param filenames - Filenames to read and parse.
   * @returns Report output.
   */
  async validateMultipleFiles(filenames) {
    const report = Reporter.merge(filenames.map((filename) => this.validateFileSync(filename)));
    return Promise.resolve(report);
  }
  /**
   * Parse and validate HTML from multiple files. Result is merged together to a
   * single report.
   *
   * @param filenames - Filenames to read and parse.
   * @returns Report output.
   */
  validateMultipleFilesSync(filenames) {
    return Reporter.merge(filenames.map((filename) => this.validateFileSync(filename)));
  }
  /**
   * Returns true if the given filename can be validated.
   *
   * A file is considered to be validatable if the extension is `.html` or if a
   * transformer matches the filename.
   *
   * This is mostly useful for tooling to determine whenever to validate the
   * file or not. CLI tools will run on all the given files anyway.
   */
  async canValidate(filename) {
    if (filename.toLowerCase().endsWith(".html")) {
      return true;
    }
    const config = await this.getConfigFor(filename);
    return config.canTransform(filename);
  }
  /**
   * Returns true if the given filename can be validated.
   *
   * A file is considered to be validatable if the extension is `.html` or if a
   * transformer matches the filename.
   *
   * This is mostly useful for tooling to determine whenever to validate the
   * file or not. CLI tools will run on all the given files anyway.
   */
  canValidateSync(filename) {
    if (filename.toLowerCase().endsWith(".html")) {
      return true;
    }
    const config = this.getConfigForSync(filename);
    return config.canTransform(filename);
  }
  /**
   * Tokenize filename and output all tokens.
   *
   * Using CLI this is enabled with `--dump-tokens`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to tokenize.
   */
  dumpTokens(filename) {
    const config = this.getConfigForSync(filename);
    const source = config.transformFilename(filename);
    const engine = new Engine(config, Parser);
    return engine.dumpTokens(source);
  }
  /**
   * Parse filename and output all events.
   *
   * Using CLI this is enabled with `--dump-events`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to dump events from.
   */
  dumpEvents(filename) {
    const config = this.getConfigForSync(filename);
    const source = config.transformFilename(filename);
    const engine = new Engine(config, Parser);
    return engine.dumpEvents(source);
  }
  /**
   * Parse filename and output DOM tree.
   *
   * Using CLI this is enabled with `--dump-tree`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to dump DOM tree from.
   */
  dumpTree(filename) {
    const config = this.getConfigForSync(filename);
    const source = config.transformFilename(filename);
    const engine = new Engine(config, Parser);
    return engine.dumpTree(source);
  }
  /**
   * Transform filename and output source data.
   *
   * Using CLI this is enabled with `--dump-source`. Mostly useful for
   * debugging.
   *
   * @internal
   * @param filename - Filename to dump source from.
   */
  dumpSource(filename) {
    const config = this.getConfigForSync(filename);
    const sources = config.transformFilename(filename);
    return sources.reduce((result, source) => {
      const line = String(source.line);
      const column = String(source.column);
      const offset = String(source.offset);
      result.push(`Source ${source.filename}@${line}:${column} (offset: ${offset})`);
      if (source.transformedBy) {
        result.push("Transformed by:");
        result = result.concat(source.transformedBy.reverse().map((name) => ` - ${name}`));
      }
      if (source.hooks && Object.keys(source.hooks).length > 0) {
        result.push("Hooks");
        for (const [key, present] of Object.entries(source.hooks)) {
          if (present) {
            result.push(` - ${key}`);
          }
        }
      }
      result.push("---");
      result = result.concat(source.data.split("\n"));
      result.push("---");
      return result;
    }, []);
  }
  /**
   * Get effective configuration schema.
   */
  getConfigurationSchema() {
    return configurationSchema;
  }
  /**
   * Get effective metadata element schema.
   *
   * If a filename is given the configured plugins can extend the
   * schema. Filename must not be an existing file or a filetype normally
   * handled by html-validate but the path will be used when resolving
   * configuration. As a rule-of-thumb, set it to the elements json file.
   */
  async getElementsSchema(filename) {
    const config = await this.getConfigFor(filename ?? "inline");
    const metaTable = config.getMetaTable();
    return metaTable.getJSONSchema();
  }
  /**
   * Get effective metadata element schema.
   *
   * If a filename is given the configured plugins can extend the
   * schema. Filename must not be an existing file or a filetype normally
   * handled by html-validate but the path will be used when resolving
   * configuration. As a rule-of-thumb, set it to the elements json file.
   */
  getElementsSchemaSync(filename) {
    const config = this.getConfigForSync(filename ?? "inline");
    const metaTable = config.getMetaTable();
    return metaTable.getJSONSchema();
  }
  async getContextualDocumentation(message, filenameOrConfig = "inline") {
    const config = typeof filenameOrConfig === "string" ? await this.getConfigFor(filenameOrConfig) : await filenameOrConfig;
    const engine = new Engine(config, Parser);
    return engine.getRuleDocumentation(message);
  }
  getContextualDocumentationSync(message, filenameOrConfig = "inline") {
    const config = typeof filenameOrConfig === "string" ? this.getConfigForSync(filenameOrConfig) : filenameOrConfig;
    const engine = new Engine(config, Parser);
    return engine.getRuleDocumentation(message);
  }
  /**
   * Get contextual documentation for the given rule.
   *
   * Typical usage:
   *
   * ```js
   * const report = await htmlvalidate.validateFile("my-file.html");
   * for (const result of report.results){
   *   const config = await htmlvalidate.getConfigFor(result.filePath);
   *   for (const message of result.messages){
   *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);
   *     // do something with documentation
   *   }
   * }
   * ```
   *
   * @public
   * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.
   * @param ruleId - Rule to get documentation for.
   * @param config - If set it provides more accurate description by using the
   * correct configuration for the file.
   * @param context - If set to `Message.context` some rules can provide
   * contextual details and suggestions.
   */
  async getRuleDocumentation(ruleId, config = null, context = null) {
    const c = config ?? this.getConfigFor("inline");
    const engine = new Engine(await c, Parser);
    return engine.getRuleDocumentation({ ruleId, context });
  }
  /**
   * Get contextual documentation for the given rule.
   *
   * Typical usage:
   *
   * ```js
   * const report = htmlvalidate.validateFileSync("my-file.html");
   * for (const result of report.results){
   *   const config = htmlvalidate.getConfigForSync(result.filePath);
   *   for (const message of result.messages){
   *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);
   *     // do something with documentation
   *   }
   * }
   * ```
   *
   * @public
   * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.
   * @param ruleId - Rule to get documentation for.
   * @param config - If set it provides more accurate description by using the
   * correct configuration for the file.
   * @param context - If set to `Message.context` some rules can provide
   * contextual details and suggestions.
   */
  getRuleDocumentationSync(ruleId, config = null, context = null) {
    const c = config ?? this.getConfigForSync("inline");
    const engine = new Engine(c, Parser);
    return engine.getRuleDocumentation({ ruleId, context });
  }
  /**
   * Create a parser configured for given filename.
   *
   * @internal
   * @param source - Source to use.
   */
  async getParserFor(source) {
    const config = await this.getConfigFor(source.filename);
    return new Parser(config);
  }
  /**
   * Get configuration for given filename.
   *
   * See [[FileSystemConfigLoader]] for details.
   *
   * @public
   * @param filename - Filename to get configuration for.
   * @param configOverride - Configuration to apply last.
   */
  getConfigFor(filename, configOverride) {
    const config = this.configLoader.getConfigFor(filename, configOverride);
    return Promise.resolve(config);
  }
  /**
   * Get configuration for given filename.
   *
   * See [[FileSystemConfigLoader]] for details.
   *
   * @public
   * @param filename - Filename to get configuration for.
   * @param configOverride - Configuration to apply last.
   */
  getConfigForSync(filename, configOverride) {
    return this.configLoader.getConfigFor(filename, configOverride);
  }
  /**
   * Flush configuration cache. Clears full cache unless a filename is given.
   *
   * See [[FileSystemConfigLoader]] for details.
   *
   * @public
   * @param filename - If set, only flush cache for given filename.
   */
  flushConfigCache(filename) {
    this.configLoader.flushCache(filename);
  }
}

const name = "html-validate";
const version = "8.18.0";
const bugs = "https://gitlab.com/html-validate/html-validate/issues/new";

function definePlugin(plugin) {
  return plugin;
}

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = '';
const SPACE = ' ';
const ESCAPE = '\\';
const REGEX_TEST_BLANK_LINE = /^\s+$/;
const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
const REGEX_SPLITALL_CRLF = /\r?\n/g;
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;

const SLASH = '/';

// Do not use ternary expression here, since "istanbul ignore next" is buggy
let TMP_KEY_IGNORE = 'node-ignore';
/* istanbul ignore else */
if (typeof Symbol !== 'undefined') {
  TMP_KEY_IGNORE = Symbol.for('node-ignore');
}
const KEY_IGNORE = TMP_KEY_IGNORE;

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value});

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

const RETURN_FALSE = () => false;

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
);

// See fixtures #59
const cleanRangeBackSlash = slashes => {
  const {length} = slashes;
  return slashes.slice(0, length - length % 2)
};

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  [
    // remove BOM
    // TODO:
    // Other similar zero-width characters?
    /^\uFEFF/,
    () => EMPTY
  ],

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? SPACE
      : EMPTY
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => SPACE
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    match => `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // normal intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule,
    //    coz trailing single wildcard will be handed by [trailing wildcard]
    /(^|[^\\]+)(\\\*)+(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1, p2) => {
      // 1.
      // > An asterisk "*" matches anything except a slash.
      // 2.
      // > Other consecutive asterisks are considered regular asterisks
      // > and will match according to the previous rules.
      const unescaped = p2.replace(/\\\*/g, '[^\\/]*');
      return p1 + unescaped
    }
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],

  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],

  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === ']'
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]'
        : '[]'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*';

      return `${prefix}(?=$|\\/$)`
    }
  ],
];

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null);

// @param {pattern}
const makeRegex = (pattern, ignoreCase) => {
  let source = regexCache[pattern];

  if (!source) {
    source = REPLACERS.reduce(
      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
      pattern
    );
    regexCache[pattern] = source;
  }

  return ignoreCase
    ? new RegExp(source, 'i')
    : new RegExp(source)
};

const isString = subject => typeof subject === 'string';

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)
  && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0;

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin;
    this.pattern = pattern;
    this.negative = negative;
    this.regex = regex;
  }
}

const createRule = (pattern, ignoreCase) => {
  const origin = pattern;
  let negative = false;

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');

  const regex = makeRegex(pattern, ignoreCase);

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
};

const throwError = (message, Ctor) => {
  throw new Ctor(message)
};

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d';
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
};

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);

checkPath.isNotRelative = isNotRelative;
checkPath.convert = p => p;

class Ignore {
  constructor ({
    ignorecase = true,
    ignoreCase = ignorecase,
    allowRelativePaths = false
  } = {}) {
    define(this, KEY_IGNORE, true);

    this._rules = [];
    this._ignoreCase = ignoreCase;
    this._allowRelativePaths = allowRelativePaths;
    this._initCache();
  }

  _initCache () {
    this._ignoreCache = Object.create(null);
    this._testCache = Object.create(null);
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules);
      this._added = true;
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignoreCase);
      this._added = true;
      this._rules.push(rule);
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false;

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this);

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache();
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false;
    let unignored = false;

    this._rules.forEach(rule => {
      const {negative} = rule;
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path);

      if (matched) {
        ignored = !negative;
        unignored = negative;
      }
    });

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath);

    checkPath(
      path,
      originalPath,
      this._allowRelativePaths
        ? RETURN_FALSE
        : throwError
    );

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH);
    }

    slices.pop();

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    );

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options);

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, RETURN_FALSE);

factory.isPathValid = isPathValid;

// Fixes typescript
factory.default = factory;

var ignore = factory;

// Windows
// --------------------------------------------------------------
/* istanbul ignore if */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/');

  checkPath.convert = makePosix;

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path);
}

var ignore$1 = /*@__PURE__*/getDefaultExportFromCjs(ignore);

const entities = {
  ">": "&gt;",
  "<": "&lt;",
  "'": "&apos;",
  '"': "&quot;",
  "&": "&amp;"
};
function xmlescape(src) {
  return src.toString().replace(/[><'"&]/g, (match) => {
    return entities[match];
  });
}
function getMessageType(message) {
  switch (message.severity) {
    case 2:
      return "error";
    case 1:
      return "warning";
    default:
      return "error";
  }
}
function checkstyleFormatter(results) {
  let output = "";
  output += `<?xml version="1.0" encoding="utf-8"?>
`;
  output += `<checkstyle version="4.3">
`;
  results.forEach((result) => {
    const messages = result.messages;
    output += `  <file name="${xmlescape(result.filePath)}">
`;
    messages.forEach((message) => {
      const ruleId = xmlescape(`htmlvalidate.rules.${message.ruleId}`);
      output += "    ";
      output += [
        `<error line="${xmlescape(message.line)}"`,
        `column="${xmlescape(message.column)}"`,
        `severity="${xmlescape(getMessageType(message))}"`,
        `message="${xmlescape(message.message)} (${message.ruleId})"`,
        `source="${ruleId}" />`
      ].join(" ");
      output += "\n";
    });
    output += "  </file>\n";
  });
  output += "</checkstyle>\n";
  return output;
}
const formatter$3 = checkstyleFormatter;
var checkstyle = formatter$3;

const defaults = {
  showLink: true,
  showSummary: true,
  showSelector: false
};
function pluralize(word, count) {
  return count === 1 ? word : `${word}s`;
}
function formatFilePath(filePath, line, column) {
  if (line && column) {
    filePath += `:${String(line)}:${String(column)}`;
  }
  return kleur__default.default.green(filePath);
}
function getStartLocation(message) {
  return {
    line: message.line,
    column: message.column
  };
}
function getEndLocation(message, source) {
  let line = message.line;
  let column = message.column;
  for (let i = 0; i < message.size; i++) {
    if (source.charAt(message.offset + i) === "\n") {
      line++;
      column = 0;
    } else {
      column++;
    }
  }
  return { line, column };
}
function formatMessage(message, parentResult, options) {
  const type = message.severity === 2 ? kleur__default.default.red("error") : kleur__default.default.yellow("warning");
  const msg = kleur__default.default.bold(message.message.replace(/([^ ])\.$/, "$1"));
  const ruleId = kleur__default.default.dim(`(${message.ruleId})`);
  const filePath = formatFilePath(parentResult.filePath, message.line, message.column);
  const sourceCode = parentResult.source;
  const firstLine = [
    `${type}:`,
    msg,
    ruleId ? ruleId : "",
    sourceCode ? `at ${filePath}:` : `at ${filePath}`
  ].filter(String).join(" ");
  const result = [firstLine];
  if (sourceCode) {
    result.push(
      codeFrame.codeFrameColumns(
        sourceCode,
        {
          start: getStartLocation(message),
          end: getEndLocation(message, sourceCode)
        },
        { highlightCode: false }
      )
    );
  }
  if (options.showSelector) {
    result.push(`${kleur__default.default.bold("Selector:")} ${message.selector ?? "-"}`);
  }
  if (options.showLink && message.ruleUrl) {
    result.push(`${kleur__default.default.bold("Details:")} ${message.ruleUrl}`);
  }
  return result.join("\n");
}
function formatSummary(errors, warnings) {
  const summaryColor = errors > 0 ? "red" : "yellow";
  const summary = [];
  if (errors > 0) {
    summary.push(`${String(errors)} ${pluralize("error", errors)}`);
  }
  if (warnings > 0) {
    summary.push(`${String(warnings)} ${pluralize("warning", warnings)}`);
  }
  return kleur__default.default[summaryColor]().bold(`${summary.join(" and ")} found.`);
}
function codeframe(results, options) {
  const merged = { ...defaults, ...options };
  let errors = 0;
  let warnings = 0;
  const resultsWithMessages = results.filter((result) => result.messages.length > 0);
  let output = resultsWithMessages.reduce((resultsOutput, result) => {
    const messages = result.messages.map((message) => {
      return `${formatMessage(message, result, merged)}

`;
    });
    errors += result.errorCount;
    warnings += result.warningCount;
    return resultsOutput.concat(messages);
  }, []).join("\n");
  if (merged.showSummary) {
    output += "\n";
    output += formatSummary(errors, warnings);
    output += "\n";
  }
  return errors + warnings > 0 ? output : "";
}

function jsonFormatter(results) {
  return JSON.stringify(results);
}
const formatter$2 = jsonFormatter;
var json = formatter$2;

function linkSummary(results) {
  const urls = results.reduce((result, it) => {
    const urls2 = it.messages.map((error) => error.ruleUrl).filter((error) => Boolean(error));
    return [...result, ...urls2];
  }, []);
  const unique = Array.from(new Set(urls));
  if (unique.length === 0) {
    return "";
  }
  const lines = unique.map((url) => `  ${url}
`);
  return `
${kleur__default.default.bold("More information")}:
${lines.join("")}
`;
}
function stylish(results) {
  const errors = stylish$2.stylish(
    results.map((it) => ({
      ...it,
      fixableErrorCount: 0,
      fixableWarningCount: 0
    }))
  );
  const links = linkSummary(results);
  return `${errors}${links}`;
}
const formatter$1 = stylish;
var stylish$1 = formatter$1;

function textFormatter(results) {
  let output = "";
  let total = 0;
  results.forEach((result) => {
    const messages = result.messages;
    if (messages.length === 0) {
      return;
    }
    total += messages.length;
    output += messages.map((message) => {
      let messageType;
      if (message.severity === 2) {
        messageType = "error";
      } else {
        messageType = "warning";
      }
      const line = String(message.line);
      const column = String(message.column);
      const location = `${result.filePath}:${line}:${column}`;
      return `${location}: ${messageType} [${message.ruleId}] ${message.message}
`;
    }).join("");
  });
  return total > 0 ? output : "";
}
const formatter = textFormatter;
var text = formatter;

const availableFormatters = {
  checkstyle,
  codeframe,
  json,
  stylish: stylish$1,
  text
};
function getFormatter(name) {
  return availableFormatters[name] ?? null;
}

function compatibilityCheckImpl(name, declared, options) {
  const { silent, version: current, logger } = options;
  const valid = semver__default.default.satisfies(current, declared);
  if (valid || silent) {
    return valid;
  }
  const text = [
    "-----------------------------------------------------------------------------------------------------",
    `${name} requires html-validate version "${declared}" but current installed version is ${current}`,
    "This is not a supported configuration. Please install a supported version before reporting bugs.",
    "-----------------------------------------------------------------------------------------------------"
  ].join("\n");
  logger(text);
  return false;
}

exports.Attribute = Attribute;
exports.Config = Config;
exports.ConfigError = ConfigError;
exports.ConfigLoader = ConfigLoader;
exports.DOMNode = DOMNode;
exports.DOMTokenList = DOMTokenList;
exports.DOMTree = DOMTree;
exports.DynamicValue = DynamicValue;
exports.EventHandler = EventHandler;
exports.HtmlElement = HtmlElement;
exports.HtmlValidate = HtmlValidate;
exports.MetaCopyableProperty = MetaCopyableProperty;
exports.MetaTable = MetaTable;
exports.NestedError = NestedError;
exports.NodeClosed = NodeClosed;
exports.NodeType = NodeType;
exports.Parser = Parser;
exports.Presets = Presets;
exports.Reporter = Reporter;
exports.ResolvedConfig = ResolvedConfig;
exports.Rule = Rule;
exports.SchemaValidationError = SchemaValidationError;
exports.Severity = Severity;
exports.StaticConfigLoader = StaticConfigLoader;
exports.TextClassification = TextClassification;
exports.TextContent = TextContent$1;
exports.TextNode = TextNode;
exports.UserError = UserError;
exports.Validator = Validator;
exports.WrappedError = WrappedError;
exports.ariaNaming = ariaNaming;
exports.bugs = bugs;
exports.classifyNodeText = classifyNodeText;
exports.codeframe = codeframe;
exports.compatibilityCheckImpl = compatibilityCheckImpl;
exports.deepmerge = deepmerge$1;
exports.defineConfig = defineConfig;
exports.definePlugin = definePlugin;
exports.ensureError = ensureError;
exports.getFormatter = getFormatter;
exports.ignore = ignore$1;
exports.keywordPatternMatcher = keywordPatternMatcher;
exports.name = name;
exports.ruleExists = ruleExists;
exports.sliceLocation = sliceLocation;
exports.staticResolver = staticResolver;
exports.version = version;
//# sourceMappingURL=core.js.map
