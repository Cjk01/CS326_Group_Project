'use strict';

var coreNodejs = require('./core-nodejs.js');
var core = require('./core.js');
var path = require('node:path');
var fs = require('fs');
var glob = require('glob');
var prompts = require('prompts');
require('./meta-helper.js');
var fs$1 = require('node:fs');
var betterAjvErrors = require('@sidvind/better-ajv-errors');
var kleur = require('kleur');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var prompts__default = /*#__PURE__*/_interopDefault(prompts);
var fs__default$1 = /*#__PURE__*/_interopDefault(fs$1);
var betterAjvErrors__default = /*#__PURE__*/_interopDefault(betterAjvErrors);
var kleur__default = /*#__PURE__*/_interopDefault(kleur);

const DEFAULT_EXTENSIONS = ["html"];
function isDirectory(filename) {
  const st = fs__default.default.statSync(filename);
  return st.isDirectory();
}
function join(stem, filename) {
  if (path__default.default.isAbsolute(filename)) {
    return path__default.default.normalize(filename);
  } else {
    return path__default.default.normalize(path__default.default.join(stem, filename));
  }
}
function directoryPattern(extensions) {
  switch (extensions.length) {
    case 0:
      return "**/*";
    case 1:
      return `**/*.${extensions[0]}`;
    default:
      return `**/*.{${extensions.join(",")}}`;
  }
}
function expandFiles(patterns, options) {
  const cwd = options.cwd ?? process.cwd();
  const extensions = options.extensions ?? DEFAULT_EXTENSIONS;
  const files = patterns.reduce((result, pattern) => {
    if (pattern === "-") {
      result.push("/dev/stdin");
      return result;
    }
    for (const filename of glob.globSync(pattern, { cwd })) {
      const fullpath = join(cwd, filename);
      if (isDirectory(fullpath)) {
        const dir = expandFiles([directoryPattern(extensions)], { ...options, cwd: fullpath });
        result = result.concat(dir.map((cur) => join(filename, cur)));
        continue;
      }
      result.push(fullpath);
    }
    return result.sort((a, b) => {
      const pa = a.split("/").length;
      const pb = b.split("/").length;
      if (pa !== pb) {
        return pa - pb;
      } else {
        return a > b ? 1 : -1;
      }
    });
  }, []);
  return Array.from(new Set(files));
}

function wrap(formatter, dst) {
  return (results) => {
    const output = formatter(results);
    if (dst) {
      const dir = path__default.default.dirname(dst);
      if (!fs__default.default.existsSync(dir)) {
        fs__default.default.mkdirSync(dir, { recursive: true });
      }
      fs__default.default.writeFileSync(dst, output, "utf-8");
      return "";
    } else {
      return output;
    }
  };
}
function loadFormatter(name) {
  const fn = core.getFormatter(name);
  if (fn) {
    return fn;
  }
  try {
    return coreNodejs.legacyRequire(name);
  } catch (error) {
    throw new core.UserError(`No formatter named "${name}"`, core.ensureError(error));
  }
}
function getFormatter(formatters) {
  const fn = formatters.split(",").map((cur) => {
    const [name, dst] = cur.split("=", 2);
    const fn2 = loadFormatter(name);
    return wrap(fn2, dst);
  });
  return (report) => {
    return fn.map((formatter) => formatter(report.results)).filter(Boolean).join("\n");
  };
}

class IsIgnored {
  constructor() {
    this.cacheIgnore = /* @__PURE__ */ new Map();
  }
  /**
   * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
   * one of them contains a pattern matching given filename.
   */
  isIgnored(filename) {
    return this.match(filename);
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.cacheIgnore.clear();
  }
  match(target) {
    let current = path__default.default.dirname(target);
    while (true) {
      const relative = path__default.default.relative(current, target);
      const filename = path__default.default.join(current, ".htmlvalidateignore");
      const ig = this.parseFile(filename);
      if (ig && ig.ignores(relative)) {
        return true;
      }
      const child = current;
      current = path__default.default.dirname(current);
      if (current === child) {
        break;
      }
    }
    return false;
  }
  parseFile(filename) {
    if (this.cacheIgnore.has(filename)) {
      return this.cacheIgnore.get(filename);
    }
    if (!fs__default.default.existsSync(filename)) {
      this.cacheIgnore.set(filename, void 0);
      return void 0;
    }
    const content = fs__default.default.readFileSync(filename, "utf-8");
    const ig = core.ignore().add(content);
    this.cacheIgnore.set(filename, ig);
    return ig;
  }
}

const frameworkConfig = {
  ["AngularJS" /* angularjs */]: {
    transform: {
      "^.*\\.js$": "html-validate-angular/js",
      "^.*\\.html$": "html-validate-angular/html"
    }
  },
  ["Vue.js" /* vuejs */]: {
    plugins: ["html-validate-vue"],
    extends: ["html-validate-vue:recommended"],
    transform: {
      "^.*\\.vue$": "html-validate-vue"
    }
  },
  ["Markdown" /* markdown */]: {
    transform: {
      "^.*\\.md$": "html-validate-markdown"
    }
  }
};
function addFrameworks(src, frameworks) {
  let config = src;
  for (const framework of frameworks) {
    config = core.deepmerge(config, frameworkConfig[framework]);
  }
  return config;
}
function writeConfig(dst, config) {
  return new Promise((resolve, reject) => {
    fs__default.default.writeFile(dst, JSON.stringify(config, null, 2), (err) => {
      if (err)
        reject(err);
      resolve();
    });
  });
}
async function init$1(cwd) {
  const filename = `${cwd}/.htmlvalidate.json`;
  const exists = fs__default.default.existsSync(filename);
  const initialConfig = {
    elements: ["html5"],
    extends: ["html-validate:recommended"]
  };
  if (exists) {
    const result = await prompts__default.default({
      name: "overwrite",
      type: "confirm",
      message: "A .htmlvalidate.json file already exists, do you want to overwrite it?"
    });
    if (!result.overwrite) {
      return Promise.reject();
    }
  }
  const questions = [
    {
      name: "frameworks",
      type: "multiselect",
      choices: [
        { title: "AngularJS" /* angularjs */, value: "AngularJS" /* angularjs */ },
        { title: "Vue.js" /* vuejs */, value: "Vue.js" /* vuejs */ },
        { title: "Markdown" /* markdown */, value: "Markdown" /* markdown */ }
      ],
      message: "Support additional frameworks?"
    }
  ];
  const answers = await prompts__default.default(questions);
  let config = initialConfig;
  config = addFrameworks(config, answers.frameworks);
  await writeConfig(filename, config);
  return {
    filename
  };
}

function parseSeverity(ruleId, severity) {
  switch (severity) {
    case "off":
    case "0":
      return core.Severity.DISABLED;
    case "warn":
    case "1":
      return core.Severity.WARN;
    case "error":
    case "2":
      return core.Severity.ERROR;
    default:
      throw new Error(`Invalid severity "${severity}" for rule "${ruleId}"`);
  }
}

function parseItem(value) {
  if (value.includes(":")) {
    const [ruleId, severity] = value.split(":", 2);
    return { ruleId, severity: parseSeverity(ruleId, severity) };
  } else {
    return { ruleId: value, severity: core.Severity.ERROR };
  }
}
function getRuleConfig(values) {
  if (typeof values === "string") {
    return getRuleConfig([values]);
  }
  return values.reduce((parsedRules, value) => {
    const { ruleId, severity } = parseItem(value.trim());
    return { [ruleId]: severity, ...parsedRules };
  }, {});
}

const defaultConfig = {
  extends: ["html-validate:recommended"]
};
function getBaseConfig(filename) {
  if (filename) {
    const resolver = coreNodejs.cjsResolver();
    const configData = resolver.resolveConfig(path__default.default.resolve(filename), { cache: false });
    if (!configData) {
      throw new core.UserError(`Failed to read configuration from "${filename}"`);
    }
    return configData;
  } else {
    return defaultConfig;
  }
}
class CLI {
  /**
   * Create new CLI helper.
   *
   * Can be used to create tooling with similar properties to bundled CLI
   * script.
   */
  constructor(options) {
    this.options = options ?? {};
    this.config = null;
    this.loader = null;
    this.ignored = new IsIgnored();
  }
  /**
   * Returns list of files matching patterns and are not ignored. Filenames will
   * have absolute paths.
   *
   * @public
   */
  expandFiles(patterns, options = {}) {
    return expandFiles(patterns, options).filter((filename) => !this.isIgnored(filename));
  }
  getFormatter(formatters) {
    return getFormatter(formatters);
  }
  /**
   * Initialize project with a new configuration.
   *
   * A new `.htmlvalidate.json` file will be placed in the path provided by
   * `cwd`.
   */
  init(cwd) {
    return init$1(cwd);
  }
  /**
   * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
   * one of them contains a pattern matching given filename.
   */
  isIgnored(filename) {
    return this.ignored.isIgnored(filename);
  }
  /**
   * Clear cache.
   *
   * Previously fetched [[HtmlValidate]] instances must either be fetched again
   * or call [[HtmlValidate.flushConfigCache]].
   */
  /* istanbul ignore next: each method is tested separately */
  clearCache() {
    if (this.loader) {
      this.loader.flushCache();
    }
    this.ignored.clearCache();
  }
  /**
   * Get HtmlValidate instance with configuration based on options passed to the
   * constructor.
   *
   * @internal
   */
  getLoader() {
    if (!this.loader) {
      this.loader = new coreNodejs.FileSystemConfigLoader(this.getConfig());
    }
    return this.loader;
  }
  /**
   * Get HtmlValidate instance with configuration based on options passed to the
   * constructor.
   *
   * @public
   */
  getValidator() {
    const loader = this.getLoader();
    return new core.HtmlValidate(loader);
  }
  /**
   * @internal
   */
  getConfig() {
    if (!this.config) {
      this.config = this.resolveConfig();
    }
    return this.config;
  }
  resolveConfig() {
    const { options } = this;
    const config = getBaseConfig(options.configFile);
    if (options.rules) {
      config.extends = [];
      config.rules = getRuleConfig(options.rules);
    }
    return config;
  }
}

function prettyError(err) {
  let json;
  if (err.filename && fs__default$1.default.existsSync(err.filename)) {
    json = fs__default$1.default.readFileSync(err.filename, "utf-8");
  }
  return betterAjvErrors__default.default(err.schema, err.obj, err.errors, {
    format: "cli",
    indent: 2,
    json
  });
}
function handleSchemaValidationError(console, err) {
  if (err.filename) {
    const filename = path__default.default.relative(process.cwd(), err.filename);
    console.error(kleur__default.default.red(`A configuration error was found in "${filename}":`));
  } else {
    console.error(kleur__default.default.red(`A configuration error was found:`));
  }
  console.group();
  {
    console.error(prettyError(err));
  }
  console.groupEnd();
}

var Mode = /* @__PURE__ */ ((Mode2) => {
  Mode2[Mode2["LINT"] = 0] = "LINT";
  Mode2[Mode2["INIT"] = 1] = "INIT";
  Mode2[Mode2["DUMP_EVENTS"] = 2] = "DUMP_EVENTS";
  Mode2[Mode2["DUMP_TOKENS"] = 3] = "DUMP_TOKENS";
  Mode2[Mode2["DUMP_TREE"] = 4] = "DUMP_TREE";
  Mode2[Mode2["DUMP_SOURCE"] = 5] = "DUMP_SOURCE";
  Mode2[Mode2["PRINT_CONFIG"] = 6] = "PRINT_CONFIG";
  return Mode2;
})(Mode || {});
function modeToFlag(mode) {
  switch (mode) {
    case 0 /* LINT */:
      return null;
    case 1 /* INIT */:
      return "--init";
    case 2 /* DUMP_EVENTS */:
      return "--dump-events";
    case 3 /* DUMP_TOKENS */:
      return "--dump-tokens";
    case 4 /* DUMP_TREE */:
      return "--dump-tree";
    case 5 /* DUMP_SOURCE */:
      return "--dump-source";
    case 6 /* PRINT_CONFIG */:
      return "--print-config";
  }
}

function renameStdin(report, filename) {
  const stdin = report.results.find((cur) => cur.filePath === "/dev/stdin");
  if (stdin) {
    stdin.filePath = filename;
  }
}
async function lint(htmlvalidate, output, files, options) {
  const reports = files.map(async (filename) => {
    try {
      return await htmlvalidate.validateFile(filename);
    } catch (err) {
      const message = kleur__default.default.red(`Validator crashed when parsing "${filename}"`);
      output.write(`${message}
`);
      throw err;
    }
  });
  const merged = await core.Reporter.merge(reports);
  if (options.stdinFilename) {
    renameStdin(merged, options.stdinFilename);
  }
  output.write(options.formatter(merged));
  if (options.maxWarnings >= 0 && merged.warningCount > options.maxWarnings) {
    output.write(
      `
html-validate found too many warnings (maximum: ${String(options.maxWarnings)}).
`
    );
    return false;
  }
  return merged.valid;
}

async function init(cli, output, options) {
  const result = await cli.init(options.cwd);
  output.write(`Configuration written to "${result.filename}"
`);
  return true;
}

async function printConfig(htmlvalidate, output, files) {
  if (files.length > 1) {
    output.write(`\`--print-config\` expected a single filename but got multiple:

`);
    for (const filename of files) {
      output.write(`  - ${filename}
`);
    }
    output.write("\n");
    return false;
  }
  const config = await htmlvalidate.getConfigFor(files[0]);
  const json = JSON.stringify(config.getConfigData(), null, 2);
  output.write(`${json}
`);
  return true;
}

const jsonIgnored = [
  "annotation",
  "blockedRules",
  "cache",
  "closed",
  "depth",
  "disabledRules",
  "nodeType",
  "unique",
  "voidElement"
];
const jsonFiltered = [
  "childNodes",
  "children",
  "data",
  "meta",
  "metaElement",
  "originalData",
  "parent"
];
function isLocation(key, value) {
  return Boolean(value && (key === "location" || key.endsWith("Location")));
}
function isIgnored(key) {
  return Boolean(key.startsWith("_") || jsonIgnored.includes(key));
}
function isFiltered(key, value) {
  return Boolean(value && jsonFiltered.includes(key));
}
function eventReplacer(key, value) {
  if (isLocation(key, value)) {
    const filename = value.filename;
    const line = String(value.line);
    const column = String(value.column);
    return `${filename}:${line}:${column}`;
  }
  if (isIgnored(key)) {
    return void 0;
  }
  if (isFiltered(key, value)) {
    return "[truncated]";
  }
  return value;
}
function eventFormatter(entry) {
  const strdata = JSON.stringify(entry.data, eventReplacer, 2);
  return `${entry.event}: ${strdata}`;
}

function dump(htmlvalidate, output, files, mode) {
  let lines = [];
  switch (mode) {
    case Mode.DUMP_EVENTS:
      lines = files.map(
        (filename) => htmlvalidate.dumpEvents(filename).map(eventFormatter)
      );
      break;
    case Mode.DUMP_TOKENS:
      lines = files.map(
        (filename) => htmlvalidate.dumpTokens(filename).map((entry) => {
          const data = JSON.stringify(entry.data);
          return `TOKEN: ${entry.token}
  Data: ${data}
  Location: ${entry.location}`;
        })
      );
      break;
    case Mode.DUMP_TREE:
      lines = files.map((filename) => htmlvalidate.dumpTree(filename));
      break;
    case Mode.DUMP_SOURCE:
      lines = files.map((filename) => htmlvalidate.dumpSource(filename));
      break;
    default:
      throw new Error(`Unknown mode "${String(mode)}"`);
  }
  const flat = lines.reduce((s, c) => s.concat(c), []);
  output.write(flat.join("\n"));
  output.write("\n");
  return Promise.resolve(true);
}

exports.CLI = CLI;
exports.Mode = Mode;
exports.dump = dump;
exports.handleSchemaValidationError = handleSchemaValidationError;
exports.init = init;
exports.lint = lint;
exports.modeToFlag = modeToFlag;
exports.printConfig = printConfig;
//# sourceMappingURL=cli.js.map
