'use strict';

var fs = require('node:fs');
var path = require('node:path');
var core = require('./core.js');
var kleur = require('kleur');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var kleur__default = /*#__PURE__*/_interopDefault(kleur);

function requireUncached(require, moduleId) {
  const filename = require.resolve(moduleId);
  const m = require.cache[filename];
  if (m == null ? void 0 : m.parent) {
    const { parent } = m;
    for (let i = parent.children.length - 1; i >= 0; i--) {
      if (parent.children[i].id === filename) {
        parent.children.splice(i, 1);
      }
    }
  }
  delete require.cache[filename];
  return require(filename);
}

const legacyRequire = require;

let cachedRootDir = null;
function determineRootDirImpl(intial, fs2) {
  let current = intial;
  while (true) {
    const search = path__default.default.join(current, "package.json");
    if (fs2.existsSync(search)) {
      return current;
    }
    const child = current;
    current = path__default.default.dirname(current);
    if (current === child) {
      break;
    }
  }
  return intial;
}
function determineRootDir() {
  if (cachedRootDir === null) {
    cachedRootDir = determineRootDirImpl(process.cwd(), fs__default.default);
  }
  return cachedRootDir;
}

function expandRelativePath(value, { cwd }) {
  if (typeof value === "string" && value.startsWith(".")) {
    return path__default.default.normalize(path__default.default.join(cwd, value));
  } else {
    return value;
  }
}

function isRequireError(error) {
  return Boolean(error && typeof error === "object" && "code" in error);
}
function isTransformer(value) {
  return typeof value === "function";
}
function cjsResolver(options = {}) {
  const rootDir = options.rootDir ?? determineRootDir();
  function internalRequire(id, { cache }) {
    const moduleName = id.replace("<rootDir>", rootDir);
    try {
      if (cache) {
        return legacyRequire(moduleName);
      } else {
        return requireUncached(legacyRequire, moduleName);
      }
    } catch (err) {
      if (isRequireError(err) && err.code === "MODULE_NOT_FOUND") {
        return null;
      }
      throw err;
    }
  }
  return {
    name: "nodejs-resolver",
    resolveElements(id, options2) {
      return internalRequire(id, options2);
    },
    resolveConfig(id, options2) {
      const configData = internalRequire(id, options2);
      if (!configData) {
        return null;
      }
      const cwd = path__default.default.dirname(id);
      const expand = (value) => expandRelativePath(value, { cwd });
      if (Array.isArray(configData.elements)) {
        configData.elements = configData.elements.map(expand);
      }
      if (Array.isArray(configData.extends)) {
        configData.extends = configData.extends.map(expand);
      }
      if (Array.isArray(configData.plugins)) {
        configData.plugins = configData.plugins.map(expand);
      }
      return configData;
    },
    resolvePlugin(id, options2) {
      return internalRequire(id, options2);
    },
    resolveTransformer(id, options2) {
      const mod = internalRequire(id, options2);
      if (!mod) {
        return null;
      }
      if (isTransformer(mod)) {
        return mod;
      }
      if (mod.transformer) {
        throw new core.ConfigError(
          `Module "${id}" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`
        );
      }
      throw new core.ConfigError(`Module "${id}" is not a valid transformer.`);
    }
  };
}
function nodejsResolver(options = {}) {
  return cjsResolver(options);
}

function findConfigurationFiles(fs2, directory) {
  return ["json", "cjs", "js"].map((extension) => path__default.default.join(directory, `.htmlvalidate.${extension}`)).filter((filePath) => fs2.existsSync(filePath));
}
const defaultResolvers = [cjsResolver()];
function hasResolver(value) {
  return Array.isArray(value[0]);
}
class FileSystemConfigLoader extends core.ConfigLoader {
  constructor(...args) {
    var __super = (...args) => {
      super(...args);
    };
    if (hasResolver(args)) {
      const [resolvers, config, options = {}] = args;
      __super(resolvers, config);
      this.fs = /* istanbul ignore next */
      options.fs ?? fs__default.default;
    } else {
      const [config, options = {}] = args;
      __super(defaultResolvers, config);
      this.fs = /* istanbul ignore next */
      options.fs ?? fs__default.default;
    }
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get configuration for given filename.
   *
   * @param filename - Filename to get configuration for.
   * @param configOverride - Configuration to merge final result with.
   */
  getConfigFor(filename, configOverride) {
    const override = this.loadFromObject(configOverride ?? {});
    if (override.isRootFound()) {
      override.init();
      return override.resolve();
    }
    if (this.globalConfig.isRootFound()) {
      const merged2 = this.globalConfig.merge(this.resolvers, override);
      merged2.init();
      return merged2.resolve();
    }
    const config = this.fromFilename(filename);
    const merged = config ? config.merge(this.resolvers, override) : this.globalConfig.merge(this.resolvers, override);
    merged.init();
    return merged.resolve();
  }
  /**
   * Flush configuration cache.
   *
   * @param filename - If given only the cache for that file is flushed.
   */
  flushCache(filename) {
    if (filename) {
      this.cache.delete(filename);
    } else {
      this.cache.clear();
    }
  }
  /**
   * Load raw configuration from directory traversal.
   *
   * This configuration is not merged with global configuration and may return
   * `null` if no configuration files are found.
   */
  fromFilename(filename) {
    if (filename === "inline") {
      return null;
    }
    const cache = this.cache.get(filename);
    if (cache) {
      return cache;
    }
    let found = false;
    let current = path__default.default.resolve(path__default.default.dirname(filename));
    let config = this.empty();
    while (true) {
      for (const configFile of findConfigurationFiles(this.fs, current)) {
        const local = this.loadFromFile(configFile);
        found = true;
        config = local.merge(this.resolvers, config);
      }
      if (config.isRootFound()) {
        break;
      }
      const child = current;
      current = path__default.default.dirname(current);
      if (current === child) {
        break;
      }
    }
    if (!found) {
      this.cache.set(filename, null);
      return null;
    }
    this.cache.set(filename, config);
    return config;
  }
  /**
   * @internal For testing only
   */
  _getInternalCache() {
    return this.cache;
  }
  defaultConfig() {
    return core.Config.defaultConfig();
  }
}

const defaults = {
  silent: false,
  version: core.version,
  logger(text) {
    console.error(kleur__default.default.red(text));
  }
};
function compatibilityCheck(name, declared, options) {
  return core.compatibilityCheckImpl(name, declared, {
    ...defaults,
    ...options
  });
}

exports.FileSystemConfigLoader = FileSystemConfigLoader;
exports.cjsResolver = cjsResolver;
exports.compatibilityCheck = compatibilityCheck;
exports.legacyRequire = legacyRequire;
exports.nodejsResolver = nodejsResolver;
//# sourceMappingURL=core-nodejs.js.map
