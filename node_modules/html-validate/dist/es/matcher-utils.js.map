{"version":3,"file":"matcher-utils.js","sources":["../../src/jest/utils/is-thenable.ts","../../src/jest/utils/diverge.ts","../../src/jest/utils/flatten-messages.ts"],"sourcesContent":["/**\n * @internal\n */\nexport function isThenable<T>(value: T | Promise<T>): value is Promise<T> {\n\treturn value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\";\n}\n","import { isThenable } from \"./is-thenable\";\nimport { type MatcherContext } from \"./matcher-context\";\nimport { type MatcherResult } from \"./matcher-result\";\n\ntype SyncCallback<T, TArgs extends any[]> = (\n\tthis: MatcherContext,\n\tactual: T,\n\t...args: TArgs\n) => MatcherResult;\n\n/**\n * @internal\n */\nexport interface MaybeAsyncCallback<TActual, TArgs extends any[]> {\n\t(this: MatcherContext, actual: TActual, ...args: TArgs): MatcherResult;\n\t(this: MatcherContext, actual: Promise<TActual>, ...args: TArgs): Promise<MatcherResult>;\n}\n\n/**\n * Creates a wrapped function based on the passed function.\n *\n * The returned function takes either a `T` or `Promise<T>`. If `T` the result\n * will be synchronous or if `Promise<T>` the result will be asynchronous.\n *\n * In practice this means that if you pass a synchronous object into it you will\n * maintain synchronous code but if you pass an asynchronous object you must\n * await the result.\n *\n * @internal\n */\nexport function diverge<T, TArgs extends any[]>(\n\tfn: SyncCallback<T, TArgs>,\n): MaybeAsyncCallback<T, TArgs> {\n\tfunction diverged(this: MatcherContext, actual: T, ...args: TArgs): MatcherResult;\n\tfunction diverged(\n\t\tthis: MatcherContext,\n\t\tactual: Promise<T>,\n\t\t...args: TArgs\n\t): Promise<MatcherResult>;\n\tfunction diverged(\n\t\tthis: MatcherContext,\n\t\tactual: T | Promise<T>,\n\t\t...args: TArgs\n\t): MatcherResult | Promise<MatcherResult> {\n\t\tif (isThenable(actual)) {\n\t\t\treturn actual.then((resolved) => fn.call(this, resolved, ...args));\n\t\t} else {\n\t\t\treturn fn.call(this, actual, ...args);\n\t\t}\n\t}\n\treturn diverged;\n}\n","import { type Message, type Report, type Result } from \"../../reporter\";\n\n/**\n * Takes all messages from all files and flattens to a single array.\n */\nexport function flattenMessages(report: Report): Message[] {\n\treturn report.results.reduce((aggregated: Message[], result: Result) => {\n\t\treturn aggregated.concat(result.messages);\n\t}, []);\n}\n"],"names":[],"mappings":"AAGO,SAAS,WAAc,KAA4C,EAAA;AACzE,EAAO,OAAA,KAAA,IAAS,OAAO,KAAU,KAAA,QAAA,IAAY,UAAU,KAAS,IAAA,OAAO,MAAM,IAAS,KAAA,UAAA,CAAA;AACvF;;ACyBO,SAAS,QACf,EAC+B,EAAA;AAO/B,EAAS,SAAA,QAAA,CAER,WACG,IACsC,EAAA;AACzC,IAAI,IAAA,UAAA,CAAW,MAAM,CAAG,EAAA;AACvB,MAAO,OAAA,MAAA,CAAO,IAAK,CAAA,CAAC,QAAa,KAAA,EAAA,CAAG,KAAK,IAAM,EAAA,QAAA,EAAU,GAAG,IAAI,CAAC,CAAA,CAAA;AAAA,KAC3D,MAAA;AACN,MAAA,OAAO,EAAG,CAAA,IAAA,CAAK,IAAM,EAAA,MAAA,EAAQ,GAAG,IAAI,CAAA,CAAA;AAAA,KACrC;AAAA,GACD;AACA,EAAO,OAAA,QAAA,CAAA;AACR;;AC9CO,SAAS,gBAAgB,MAA2B,EAAA;AAC1D,EAAA,OAAO,MAAO,CAAA,OAAA,CAAQ,MAAO,CAAA,CAAC,YAAuB,MAAmB,KAAA;AACvE,IAAO,OAAA,UAAA,CAAW,MAAO,CAAA,MAAA,CAAO,QAAQ,CAAA,CAAA;AAAA,GACzC,EAAG,EAAE,CAAA,CAAA;AACN;;;;"}