import { d as diverge, f as flattenMessages } from './matcher-utils.js';
import { d as deepmerge, H as HtmlValidate } from './core.js';
import { F as FileSystemConfigLoader } from './core-nodejs.js';

function createMatcher$4() {
  function toBeValid(report) {
    if (report.valid) {
      return {
        pass: true,
        message: (
          /* istanbul ignore next */
          () => "Result should not contain error"
        )
      };
    } else {
      const firstError = report.results[0].messages[0];
      return {
        pass: false,
        message: () => `Result should be valid but had error "${firstError.message}"`
      };
    }
  }
  return diverge(toBeValid);
}

function createMatcher$3() {
  function toBeInvalid(report) {
    if (report.valid) {
      return {
        pass: false,
        message: () => "Result should be invalid but had no errors"
      };
    } else {
      return {
        pass: true,
        message: (
          /* istanbul ignore next */
          () => "Result should not contain error"
        )
      };
    }
  }
  return diverge(toBeInvalid);
}

function isMessage(arg) {
  if (!arg) {
    return false;
  }
  return Boolean(
    arg.ruleId || arg.severity || arg.message || arg.offset || arg.line || arg.column || arg.size || arg.selector || arg.context
  );
}
function isConfig(arg) {
  if (!arg) {
    return false;
  }
  return Boolean(
    arg.root || arg.extends || arg.elements || arg.plugin || arg.transform || arg.rules
  );
}
function isString(arg) {
  return typeof arg === "string";
}
function getMarkup(src) {
  if (typeof HTMLElement !== "undefined" && src instanceof HTMLElement) {
    return src.outerHTML;
  }
  if (typeof src === "string") {
    return src;
  } else {
    throw new Error(`Failed to get markup from "${typeof src}" argument`);
  }
}
function createMatcher$2(expect, diff) {
  function toHTMLValidate(actual, arg0, arg1, arg2) {
    const markup = getMarkup(actual);
    const message = isMessage(arg0) ? arg0 : void 0;
    const config = isConfig(arg0) ? arg0 : isConfig(arg1) ? arg1 : void 0;
    const filename = isString(arg0) ? arg0 : isString(arg1) ? arg1 : arg2;
    return toHTMLValidateImpl.call(this, expect, diff, markup, message, config, filename);
  }
  return diverge(toHTMLValidate);
}
function toHTMLValidateImpl(expect, diff, actual, expectedError, userConfig, filename) {
  const defaultConfig = {
    rules: {
      /* jsdom normalizes style so disabling rule when using this matcher or it
       * gets quite noisy when configured with self-closing */
      "void-style": "off"
    }
  };
  const config = deepmerge(defaultConfig, userConfig ?? {});
  const actualFilename = filename ?? this.testPath ?? "inline";
  const loader = new FileSystemConfigLoader({
    extends: ["html-validate:recommended"]
  });
  const htmlvalidate = new HtmlValidate(loader);
  const report = htmlvalidate.validateStringSync(actual, actualFilename, config);
  const pass = report.valid;
  const result = report.results[0];
  if (pass) {
    return { pass, message: () => "HTML is valid when an error was expected" };
  } else {
    if (expectedError) {
      const actual2 = result.messages;
      const expected = expect.arrayContaining([expect.objectContaining(expectedError)]);
      const errorPass = this.equals(actual2, expected);
      const diffString = diff ? diff(expected, actual2, {
        expand: this.expand,
        aAnnotation: "Expected error",
        bAnnotation: "Actual error"
      }) : (
        /* istanbul ignore next */
        void 0
      );
      const hint = this.utils.matcherHint(".not.toHTMLValidate", void 0, void 0, {
        comment: "expected error"
      });
      const expectedErrorMessage = () => [
        hint,
        "",
        "Expected error to be present:",
        this.utils.printExpected(expectedError),
        /* istanbul ignore next */
        diffString ? `
${diffString}` : ""
      ].join("\n");
      return { pass: !errorPass, message: expectedErrorMessage, actual: actual2, expected };
    }
    const errors = result.messages.map((message) => `  ${message.message} [${message.ruleId}]`);
    return {
      pass,
      message: () => ["Expected HTML to be valid but had the following errors:", ""].concat(errors).join("\n")
    };
  }
}

function toHaveErrorImpl(context, expect, diff, actual, expected) {
  const flattened = flattenMessages(actual);
  const matcher = [expect.objectContaining(expected)];
  const pass = context.equals(flattened, matcher);
  const diffString = diff ? diff(matcher, flattened, { expand: context.expand }) : (
    /* istanbul ignore next */
    void 0
  );
  const hint = context.utils.matcherHint(".toHaveError");
  const prettyExpected = context.utils.printExpected(matcher);
  const prettyReceived = context.utils.printReceived(flattened);
  const resultMessage = () => {
    return [
      hint,
      "",
      "Expected error to equal:",
      `  ${prettyExpected}`,
      "Received:",
      `  ${prettyReceived}`,
      /* istanbul ignore next */
      diffString ? `
Difference:

${diffString}` : ""
    ].join("\n");
  };
  return { pass, message: resultMessage, actual: flattened, expected: matcher };
}
function createMatcher$1(expect, diff) {
  function toHaveError(actual, arg1, arg2, arg3) {
    if (typeof arg1 === "string") {
      const expected = {
        ruleId: arg1,
        message: arg2
      };
      if (arg3) {
        expected.context = arg3;
      }
      return toHaveErrorImpl(this, expect, diff, actual, expected);
    } else {
      return toHaveErrorImpl(this, expect, diff, actual, arg1);
    }
  }
  return diverge(toHaveError);
}

function createMatcher(expect, diff) {
  function toHaveErrors(report, errors) {
    const flattened = flattenMessages(report);
    const matcher = errors.map((entry) => {
      if (Array.isArray(entry)) {
        const [ruleId, message] = entry;
        return expect.objectContaining({ ruleId, message });
      } else {
        return expect.objectContaining(entry);
      }
    });
    const pass = this.equals(flattened, matcher);
    const diffString = diff ? diff(matcher, flattened, { expand: this.expand }) : (
      /* istanbul ignore next */
      void 0
    );
    const resultMessage = () => this.utils.matcherHint(".toHaveErrors") + `

Expected error to equal:
  ${this.utils.printExpected(matcher)}
Received:
  ${this.utils.printReceived(flattened)}` + /* istanbul ignore next */
    (diffString ? `

Difference:

${diffString}` : "");
    return { pass, message: resultMessage };
  }
  return diverge(toHaveErrors);
}

function getResults(filename, value) {
  if (typeof value === "string") {
    const loader = new FileSystemConfigLoader({
      extends: ["html-validate:recommended"]
    });
    const htmlvalidate = new HtmlValidate(loader);
    const report = htmlvalidate.validateStringSync(value, filename, {
      rules: {
        "void-style": "off"
      }
    });
    return report.results.map((it) => {
      return { ...it, filePath: "inline" };
    });
  } else {
    return value.results;
  }
}

export { createMatcher$3 as a, createMatcher$2 as b, createMatcher$4 as c, createMatcher$1 as d, createMatcher as e, getResults as g };
//# sourceMappingURL=matchers.js.map
